<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端Store</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-25T03:06:39.870Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>J.K</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://example.com/2021/04/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2021/04/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-04-07T07:31:46.000Z</published>
    <updated>2021-04-25T03:06:39.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1.元字符"></a><strong>1.元字符</strong></h2><table><thead><tr><th>字符</th><th align="right">技能</th></tr></thead><tbody><tr><td>\</td><td align="right">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\‘ 匹配 “\“ 而 “\(“ 则匹配 “(“。</td></tr><tr><td>^</td><td align="right">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td></tr><tr><td>$</td><td align="right">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 \n 或 \r。要匹配 $ 字符本身，请使用 \$。</td></tr><tr><td>*</td><td align="right">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。要匹配 * 字符，请使用 \*。</td></tr><tr><td>+</td><td align="right">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。要匹配 + 字符，请使用 \+。</td></tr><tr><td>?</td><td align="right">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。要匹配 ? 字符，请使用 \?。</td></tr><tr><td>{n}</td><td align="right">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>{n,}</td><td align="right">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td>{n,m}</td><td align="right">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>?</td><td align="right">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td>.</td><td align="right">匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.</td></tr><tr><td>(pattern)</td><td align="right">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td></tr><tr><td>(?:pattern)</td><td align="right">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (</td></tr><tr><td>(?=pattern)</td><td align="right">正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95</td></tr><tr><td>(?!pattern)</td><td align="right">正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95</td></tr><tr><td>(?&lt;=pattern)</td><td align="right">反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”(?&lt;=95</td></tr><tr><td>(?&lt;!pattern)</td><td align="right">反向否定预查，与正向否定预查类似，只是方向相反。例如”(?&lt;!95</td></tr><tr><td>x|y</td><td align="right">匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td>[xyz]</td><td align="right">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td>[^xyz]</td><td align="right">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td></tr><tr><td>[a-z]</td><td align="right">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td>[^a-z]</td><td align="right">负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td>\b</td><td align="right">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td>\B</td><td align="right">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td>\cx</td><td align="right">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td>\d</td><td align="right">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td>\D</td><td align="right">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td>\s</td><td align="right">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td align="right">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td>\w</td><td align="right">匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td>\W</td><td align="right">匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-元字符&quot;&gt;&lt;a href=&quot;#1-元字符&quot; class=&quot;headerlink&quot; title=&quot;1.元字符&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.元字符&lt;/strong&gt;&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th align=&quot;</summary>
      
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="正则" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列要点</title>
    <link href="http://example.com/2021/03/30/ES6%E7%B3%BB%E5%88%97%E8%A6%81%E7%82%B9/"/>
    <id>http://example.com/2021/03/30/ES6%E7%B3%BB%E5%88%97%E8%A6%81%E7%82%B9/</id>
    <published>2021-03-30T01:36:32.000Z</published>
    <updated>2021-04-25T03:06:39.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-说说var、let、const之间的区别"><a href="#1-说说var、let、const之间的区别" class="headerlink" title="1.说说var、let、const之间的区别"></a><strong>1.说说var、let、const之间的区别</strong></h2><h3 id="1-1-var"><a href="#1-1-var" class="headerlink" title="1.1 var"></a><strong>1.1 var</strong></h3><p>在ES5中，顶层对象的属性和全局变量是等价的，用var声明的变量既是全局变量，也是顶层变量</p><p>注意：顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>使用var声明的变量存在变量提升的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>在编译阶段，编译器会将其变成以下执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">a = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>使用var，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">30</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>在函数中使用使用var声明变量时候，该变量是局部的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line">change()</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 20 </span></span><br></pre></td></tr></table></figure><p>而如果在函数内不使用var，该变量是全局的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line">change()</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><h3 id="1-2-let"><a href="#1-2-let" class="headerlink" title="1.2 let"></a><strong>1.2 let</strong></h3><p>let是ES6新增的命令，用来声明变量</p><p>用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// ReferenceError: a is not defined.</span></span><br></pre></td></tr></table></figure><p>不存在变量提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 报错ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这表示在声明它之前，变量a是不存在的，这时如果用到它，就会抛出一个错误</p><p>只要块级作用域内存在let命令，这个区域就不再受外部影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  a = <span class="string">&#x27;abc&#x27;</span> <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用let声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”</p><p>最后，let不允许在相同作用域中重复声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">30</span></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><p>注意的是相同作用域，下面这种情况是不会报错的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们不能在函数内部重新声明参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">func()</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier &#x27;arg&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><h3 id="1-3-const"><a href="#1-3-const" class="headerlink" title="1.3 const"></a><strong>1.3 const</strong></h3><p>const声明一个只读的常量，一旦声明，常量的值就不能改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p>如果之前用var或let声明过变量，再用const声明同样会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">30</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span></span><br><span class="line"><span class="comment">// 都会报错</span></span><br></pre></td></tr></table></figure><p>const实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</p><p>对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量</p><p>对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的，并不能确保改变量的结构不变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure><p>其它情况，const与let一致</p><h3 id="1-4-区别"><a href="#1-4-区别" class="headerlink" title="1.4 区别"></a><strong>1.4 区别</strong></h3><p>var、let、const三者区别可以围绕下面五点展开：</p><blockquote><ul><li>变量提升</li><li>暂时性死区</li><li>块级作用域</li><li>重复声明</li><li>修改声明的变量</li><li>使用</li></ul></blockquote><p><b class="c42b983">变量提升</b></p><p>var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined</p><p>let和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)  <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// let </span></span><br><span class="line">  <span class="built_in">console</span>.log(b)  <span class="comment">// Cannot access &#x27;b&#x27; before initialization</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// const</span></span><br><span class="line">  <span class="built_in">console</span>.log(c)  <span class="comment">// Cannot access &#x27;c&#x27; before initialization</span></span><br><span class="line">  <span class="keyword">const</span> c = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">暂时性死区</b></p><p>var不存在暂时性死区</p><p>let和const存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// Cannot access &#x27;b&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="built_in">console</span>.log(c)  <span class="comment">// Cannot access &#x27;c&#x27; before initialization</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">块级作用域</b></p><p>var不存在块级作用域</p><p>let和const存在块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c)  <span class="comment">// Uncaught ReferenceError: c is not defined</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">重复声明</b></p><p>var允许重复声明变量</p><p>let和const在同一作用域不允许重复声明变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">20</span> <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// let</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">20</span> <span class="comment">// Identifier &#x27;b&#x27; has already been declared</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// const</span></span><br><span class="line">  <span class="keyword">const</span> c = <span class="number">10</span></span><br><span class="line">  <span class="keyword">const</span> c = <span class="number">20</span> <span class="comment">// Identifier &#x27;c&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">修改声明的变量</b></p><p>var和let可以</p><p>const声明一个只读的常量。一旦声明，常量的值就不能改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//let</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br><span class="line">c = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// Uncaught TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">使用</b></p><blockquote><p>能用const的情况尽量使用const，其他情况下大多数使用let，避免使用var</p></blockquote><h2 id="2-ES6中数组新增了哪些扩展"><a href="#2-ES6中数组新增了哪些扩展" class="headerlink" title="2.ES6中数组新增了哪些扩展?"></a><strong>2.ES6中数组新增了哪些扩展?</strong></h2><h3 id="2-1-扩展运算符的应用"><a href="#2-1-扩展运算符的应用" class="headerlink" title="2.1 扩展运算符的应用"></a><strong>2.1 扩展运算符的应用</strong></h3><p>ES6通过扩展元素符…，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure><p>主要用于函数调用的时候，将一个数组变为参数序列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>可以将某些数据结构转为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>能够更简单实现数组复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br><span class="line"><span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><p>数组的合并也更为简洁了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure><p>注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组</p><p>下面看个例子就清楚多了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,[<span class="number">1</span>,<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3  = [...arr1,...arr2]</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">9999</span> <span class="comment">// 修改arr1里面数组成员值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">3</span>]) <span class="comment">// 影响到arr3,[&#x27;a&#x27;,&#x27;b&#x27;,[9999,2],&#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>扩展运算符可以与解构赋值结合起来，用于生成数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">first  <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">rest   <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>可以将字符串转为真正的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure><p>定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure><h3 id="2-2-构造函数新增的方法"><a href="#2-2-构造函数新增的方法" class="headerlink" title="2.2 构造函数新增的方法"></a><strong>2.2 构造函数新增的方法</strong></h3><p>关于构造函数，数组新增的方法有如下：</p><blockquote><ul><li>Array.from()</li><li>Array.of()</li></ul></blockquote><p><b class="c42b983">Array.from()</b></p><p>将两类对象转为真正的数组：类似数组的对象和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">Array.of()</b></p><p>用于将一组值，转换为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br></pre></td></tr></table></figure><p>没有参数的时候，返回一个空数组</p><p>当参数只有一个的时候，实际上是指定数组的长度</p><p>参数个数不少于 2 个时，Array()才会返回由参数组成的新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><h3 id="2-3-实例对象新增的方法"><a href="#2-3-实例对象新增的方法" class="headerlink" title="2.3 实例对象新增的方法"></a><strong>2.3 实例对象新增的方法</strong></h3><p>关于数组实例对象新增的方法有如下：</p><blockquote><ul><li>copyWithin()</li><li>find()、findIndex()</li><li>fill()</li><li>entries()，keys()，values()</li><li>includes()</li><li>flat()，flatMap()</li></ul></blockquote><p><b class="c42b983">copyWithin()</b></p><p>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p><p>参数如下：</p><blockquote><p>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。<br>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2</span></span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5] </span></span><br></pre></td></tr></table></figure><p><b class="c42b983">find()、findIndex()</b></p><p>find()用于找出第一个符合条件的数组成员</p><p>参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>findIndex返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="built_in">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].find(f, person);    <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">fill()</b></p><p>使用给定值，填充一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure><p>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>注意，如果填充的类型为对象，则是浅拷贝</p><p><b class="c42b983">entries()，keys()，values()</b></p><p>keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">includes()</b></p><p>用于判断数组是否包含给定的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>方法的第二个参数表示搜索的起始位置，默认为0</p><p>参数为负数则表示倒数的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">flat()，flatMap()</b></p><p>将数组扁平化处理，返回一个新数组，对原数据没有影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>flatMap()方法对原数组的每个成员执行一个函数相当于执行Array.prototype.map()，然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure><p>flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this</p><h3 id="2-4-数组的空位"><a href="#2-4-数组的空位" class="headerlink" title="2.4 数组的空位"></a><strong>2.4 数组的空位</strong></h3><p>数组的空位指，数组的某一个位置没有任何值</p><p>ES6 则是明确将空位转为undefined，包括Array.from、扩展运算符、copyWithin()、fill()、entries()、keys()、values()、find()和findIndex()</p><p>建议大家在日常书写中，避免出现空位</p><h3 id="2-5-排序稳定性"><a href="#2-5-排序稳定性" class="headerlink" title="2.5 排序稳定性"></a><strong>2.5 排序稳定性</strong></h3><p>将sort()默认设置为稳定的排序算法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  <span class="string">&#x27;peach&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;straw&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;spork&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stableSorting = <span class="function">(<span class="params">s1, s2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (s1[<span class="number">0</span>] &lt; s2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">arr.sort(stableSorting)</span><br><span class="line"><span class="comment">// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]</span></span><br></pre></td></tr></table></figure><p>排序结果中，straw在spork的前面，跟原始顺序一致</p><h2 id="3-ES6中对象新增了哪些扩展"><a href="#3-ES6中对象新增了哪些扩展" class="headerlink" title="3.ES6中对象新增了哪些扩展?"></a><strong>3.ES6中对象新增了哪些扩展?</strong></h2><h3 id="3-1-属性的简写"><a href="#3-1-属性的简写" class="headerlink" title="3.1 属性的简写"></a><strong>3.1 属性的简写</strong></h3><p>ES6中，当对象键名与对应值名相等的时候，可以进行简写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>:foo&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;</span><br></pre></td></tr></table></figure><p>方法也能够进行简写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数内作为返回值，也会变得方便很多</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPoint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPoint()</span><br><span class="line"><span class="comment">// &#123;x:1, y:10&#125;</span></span><br></pre></td></tr></table></figure><p>注意：简写的对象方法不能用作构造函数，否则会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.f() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="3-2-属性名表达式"><a href="#3-2-属性名表达式" class="headerlink" title="3.2 属性名表达式"></a><strong>3.2 属性名表达式</strong></h3><p>ES6 允许字面量定义对象时，将表达式放在括号内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastWord = <span class="string">&#x27;last word&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="string">&#x27;first word&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  [lastWord]: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;first word&#x27;</span>] <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">a[lastWord] <span class="comment">// &quot;world&quot;</span></span><br><span class="line">a[<span class="string">&#x27;last word&#x27;</span>] <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>表达式还可以用于定义方法名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span> + <span class="string">&#x27;ello&#x27;</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo]: <span class="string">&#x27;abc&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keyA = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> keyB = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  [keyA]: <span class="string">&#x27;valueA&#x27;</span>,</span><br><span class="line">  [keyB]: <span class="string">&#x27;valueB&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject <span class="comment">// Object &#123;[object Object]: &quot;valueB&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-super关键字"><a href="#3-3-super关键字" class="headerlink" title="3.3 super关键字"></a><strong>3.3 super关键字</strong></h3><p>this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto); <span class="comment">// 为obj设置原型对象</span></span><br><span class="line">obj.find() <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-4-扩展运算符的应用"><a href="#3-4-扩展运算符的应用" class="headerlink" title="3.4 扩展运算符的应用"></a><strong>3.4 扩展运算符的应用</strong></h3><p>在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>注意：解构赋值必须是最后一个参数，否则会报错</p><p>解构赋值是浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.a.b = <span class="number">2</span>; <span class="comment">// 修改obj里面a属性中键值</span></span><br><span class="line">x.a.b <span class="comment">// 2，影响到了结构出来x的值</span></span><br></pre></td></tr></table></figure><p>对象的扩展运算符等同于使用Object.assign()方法</p><h3 id="3-5-属性的遍历"><a href="#3-5-属性的遍历" class="headerlink" title="3.5 属性的遍历"></a><strong>3.5 属性的遍历</strong></h3><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><blockquote><ul><li>for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li></ul></blockquote><blockquote><ul><li>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</li></ul></blockquote><blockquote><ul><li>Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</li></ul></blockquote><blockquote><ul><li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名</li></ul></blockquote><blockquote><ul><li>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li></ul></blockquote><p>上述遍历，都遵守同样的属性遍历的次序规则：</p><blockquote><ul><li>首先遍历所有数值键，按照数值升序排列</li><li>其次遍历所有字符串键，按照加入时间升序排列</li><li>最后遍历所有 Symbol 键，按照加入时间升序排</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()]</span></span><br></pre></td></tr></table></figure><h3 id="3-6-对象新增的方法"><a href="#3-6-对象新增的方法" class="headerlink" title="3.6 对象新增的方法"></a><strong>3.6 对象新增的方法</strong></h3><p>关于对象新增的方法，分别有以下：</p><blockquote><ul><li>Object.is()</li><li>Object.assign()</li><li>Object.getOwnPropertyDescriptors()</li><li>Object.setPrototypeOf()，Object.getPrototypeOf()</li><li>Object.keys()，Object.values()，Object.entries()</li><li>Object.fromEntries()</li></ul></blockquote><p><b class="c42b983">Object.is()</b></p><p>严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">Object.assign()</b></p><p>Object.assign()方法用于对象的合并，将源对象source的所有可枚举属性，复制到目标对象target</p><p>Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>注意：Object.assign()方法是浅拷贝，遇到同名属性会进行替换</p><p><b class="c42b983">Object.getOwnPropertyDescriptors()</b></p><p>返回指定对象所有自身属性（非继承属性）的描述对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">Object.setPrototypeOf()</b></p><p>Object.setPrototypeOf方法用来设置一个对象的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><b class="c42b983">Object.getPrototypeOf()</b></p><p>用于读取一个对象的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure><p><b class="c42b983">Object.keys()</b></p><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">Object.values()</b></p><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">Object.entries()</b></p><p>返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj)</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br><span class="line"><span class="built_in">Object</span>.fromEntries()</span><br></pre></td></tr></table></figure><p>用于将一个键值对数组转为对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="4-ES6中函数新增了哪些扩展"><a href="#4-ES6中函数新增了哪些扩展" class="headerlink" title="4.ES6中函数新增了哪些扩展?"></a><strong>4.ES6中函数新增了哪些扩展?</strong></h2><h3 id="4-1-参数"><a href="#4-1-参数" class="headerlink" title="4.1 参数"></a><strong>4.1 参数</strong></h3><p>ES6允许为函数的参数设置默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>函数的形参是默认声明的，不能使用let或const再次声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数默认值可以与解构赋值的默认值结合起来使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>上面的foo函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量x和y就不会生成，从而报错，这里设置默认值避免</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure><p>参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line">f(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br></pre></td></tr></table></figure><h3 id="4-2-属性"><a href="#4-2-属性" class="headerlink" title="4.2 属性"></a><strong>4.2 属性</strong></h3><p>函数的length属性</p><p>length将返回没有指定默认值的参数个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>rest 参数也不会计入length属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>name属性</p><p>返回该函数的函数名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.name <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.name <span class="comment">// &quot;f&quot;</span></span><br></pre></td></tr></table></figure><p>如果将一个具名函数赋值给一个变量，则 name属性都返回这个具名函数原本的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">bar.name <span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure><p>Function构造函数返回的函数实例，name属性的值为anonymous</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// &quot;anonymous&quot;</span></span><br></pre></td></tr></table></figure><p>bind返回的函数，name属性值会加上bound前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name <span class="comment">// &quot;bound foo&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// &quot;bound &quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-作用域"><a href="#4-3-作用域" class="headerlink" title="4.3 作用域"></a><strong>4.3 作用域</strong></h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域</p><p>等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的</p><p>下面例子中，y=x会形成一个单独作用域，x没有被定义，所以指向全局变量x</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 等同于 let y = x  </span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>; </span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="4-4-严格模式"><a href="#4-4-严格模式" class="headerlink" title="4.4 严格模式"></a><strong>4.4 严格模式</strong></h3><p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b = a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;a, b&#125;</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">...a</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="function"><span class="title">doSomething</span>(<span class="params">&#123;a, b&#125;</span>)</span> &#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-5-箭头函数"><a href="#4-5-箭头函数" class="headerlink" title="4.5 箭头函数"></a><strong>4.5 箭头函数</strong></h3><p>使用“箭头”（=&gt;）定义函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure><p>如果返回对象，需要加括号将对象包裹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>注意点：</p><blockquote><ul><li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象</li><li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误</li><li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替</li><li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数</li></ul></blockquote><h2 id="5-Set、Map两种数据结构怎么理解"><a href="#5-Set、Map两种数据结构怎么理解" class="headerlink" title="5.Set、Map两种数据结构怎么理解?"></a><strong>5.Set、Map两种数据结构怎么理解?</strong></h2><blockquote><p>Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构<br>集合: 是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合<br>字典: 是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同</p></blockquote><blockquote><p>共同点: 集合、字典都可以存储不重复的值<br>不同点: 集合是以<b class="c42b983">[值，值]</b>的形式存储元素，字典是以<b class="c42b983">[键，值]</a>的形式存储</p></blockquote><h3 id="5-1-Set"><a href="#5-1-Set" class="headerlink" title="5.1 Set"></a><strong>5.1 Set</strong></h3><p>Set是es6新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合</p><p>Set本身是一个构造函数，用来生成 Set 数据结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure><p>增删改查</p><p>Set的实例关于增删改查的方法：</p><blockquote><ul><li>add()</li><li>delete()</li><li>has()</li><li>clear()</li><li>add()</li></ul></blockquote><p>添加某个值，返回 Set 结构本身</p><p>当添加实例中已经存在的元素，set不会进行处理添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>); <span class="comment">// 2只被添加了一次</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">delete()</b></p><p>删除某个值，返回一个布尔值，表示删除是否成功</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><b class="c42b983">has()</b></p><p>返回一个布尔值，判断该值是否为Set的成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.has(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><b class="c42b983">clear()</b></p><p>清除所有成员，没有返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure><p>遍历</p><p>Set实例遍历的方法有如下：</p><p>关于遍历的方法，有如下：</p><blockquote><ul><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回键值对的遍历器</li><li>forEach()：使用回调函数遍历每个成员</li></ul></blockquote><p>Set的遍历顺序就是插入顺序</p><p>keys方法、values方法、entries方法返回的都是遍历器对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure><p>forEach()用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的forEach方法有第二个参数，用于绑定处理函数的this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure><p>扩展运算符和Set 结构相结合实现数组或字符串去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)]; <span class="comment">// [3, 5, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;352255&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(str)].join(<span class="string">&quot;&quot;</span>); <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure><p>实现并集、交集、和差集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-Map"><a href="#5-2-Map" class="headerlink" title="5.2 Map"></a><strong>5.2 Map</strong></h3><p>Map类型是键值对的有序列表，而键和值都可以是任意类型</p><p>Map本身是一个构造函数，用来生成 Map 数据结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br></pre></td></tr></table></figure><p>增删改查<br>Map 结构的实例针对增删改查有以下属性和操作方法：</p><blockquote><ul><li>size 属性</li><li>set()</li><li>get()</li><li>has()</li><li>delete()</li><li>clear()</li></ul></blockquote><p><b class="c42b983">size</b></p><p>size属性返回 Map 结构的成员总数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">set()</b></p><p>设置键名key对应的键值为value，然后返回整个 Map 结构</p><p>如果key已经有值，则键值会被更新，否则就新生成该键</p><p>同时返回的是当前Map对象，可采用链式写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line">m.set(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>).set(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>).set(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>) <span class="comment">// 链式操作</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">get()</b></p><p>get方法读取key对应的键值，如果找不到key，返回undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);&#125;;</span><br><span class="line">m.set(hello, <span class="string">&#x27;Hello ES6!&#x27;</span>) <span class="comment">// 键是函数</span></span><br><span class="line"></span><br><span class="line">m.get(hello)  <span class="comment">// Hello ES6!</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">has()</b></p><p>has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>);</span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line"></span><br><span class="line">m.has(<span class="string">&#x27;edition&#x27;</span>)     <span class="comment">// true</span></span><br><span class="line">m.has(<span class="string">&#x27;years&#x27;</span>)       <span class="comment">// false</span></span><br><span class="line">m.has(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">delete()</b></p><p>delete方法删除某个键，返回true。如果删除失败，返回false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line">m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m.delete(<span class="literal">undefined</span>)</span><br><span class="line">m.has(<span class="literal">undefined</span>)       <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><b class="c42b983">clear()</b></p><p>clear方法清除所有成员，没有返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.clear()</span><br><span class="line">map.size <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>遍历</p><p>Map结构原生提供三个遍历器生成函数和一个遍历方法：</p><blockquote><ul><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回所有成员的遍历器</li><li>forEach()：遍历 Map 的所有成员</li></ul></blockquote><p>遍历顺序就是插入顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;T&#x27;</span>,  <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-3-WeakSet-和-WeakMap"><a href="#5-3-WeakSet-和-WeakMap" class="headerlink" title="5.3 WeakSet 和 WeakMap"></a><strong>5.3 WeakSet 和 WeakMap</strong></h3><p>WeakSet</p><p>创建WeakSet实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br></pre></td></tr></table></figure><p>WeakSet可以接受一个具有 Iterable接口的对象作为参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure><p>在API中WeakSet与Set有两个区别：</p><blockquote><p>没有遍历操作的API<br>没有size属性</p></blockquote><p>WeackSet只能成员只能是引用类型，而不能是其他类型的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws=<span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员不是引用类型</span></span><br><span class="line"><span class="keyword">let</span> weakSet=<span class="keyword">new</span> <span class="built_in">WeakSet</span>([<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(weakSet) <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员为引用类型</span></span><br><span class="line"><span class="keyword">let</span> obj1=&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2=&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> ws=<span class="keyword">new</span> <span class="built_in">WeakSet</span>([obj1,obj2]); </span><br><span class="line"><span class="built_in">console</span>.log(ws) <span class="comment">//WeakSet &#123;&#123;…&#125;, &#123;…&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>WeakSet里面的引用只要在外部消失，它在 WeakSet里面的引用就会自动消失</p><p>WeakMap</p><p>WeakMap结构与Map结构类似，也是用于生成键值对的集合</p><p>在API中WeakMap与Map有两个区别：</p><blockquote><p>没有遍历操作的API<br>没有clear清空方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakMap 可以使用 set 方法添加成员</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line">wm1.set(key, <span class="number">2</span>);</span><br><span class="line">wm1.get(key) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap 也可以接受一个数组，</span></span><br><span class="line"><span class="comment">// 作为构造函数的参数</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[k1, <span class="string">&#x27;foo&#x27;</span>], [k2, <span class="string">&#x27;bar&#x27;</span>]]);</span><br><span class="line">wm2.get(k2) <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.set(<span class="built_in">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure><p>WeakMap的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用</p><p>举个场景例子：</p><p>在网页的 DOM 元素上添加数据，就可以使用WeakMap结构，当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">&#x27;some information&#x27;</span>);</span><br><span class="line">wm.get(element) <span class="comment">// &quot;some information&quot;</span></span><br></pre></td></tr></table></figure><p>注意：WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用</p><p>下面代码中，键值obj会在WeakMap产生新的引用，当你修改obj不会影响到内部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.get(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure><h2 id="6-怎么理解ES6中-Decorator-的？使用场景？"><a href="#6-怎么理解ES6中-Decorator-的？使用场景？" class="headerlink" title="6.怎么理解ES6中 Decorator 的？使用场景？"></a><strong>6.怎么理解ES6中 Decorator 的？使用场景？</strong></h2><p>Docorator修饰对象为下面两种：</p><blockquote><p>类的装饰<br>类属性的装饰</p></blockquote><h3 id="6-1-类的装饰"><a href="#6-1-类的装饰" class="headerlink" title="6.1 类的装饰"></a><strong>6.1 类的装饰</strong></h3><p>当对类本身进行装饰的时候，能够接受一个参数，即类本身</p><p>将装饰器行为进行分解，大家能够有个更深入的了解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure><p>下面@testable就是一个装饰器，target就是传入的类，即MyTestableClass，实现了为类添加静态属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTestableClass.isTestable <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果想要传递参数，可以在装饰器外层再封装一层函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line">MyClass.isTestable <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="6-2-类属性的装饰"><a href="#6-2-类属性的装饰" class="headerlink" title="6.2 类属性的装饰"></a><strong>6.2 类属性的装饰</strong></h3><p>当对类属性进行装饰的时候，能够接受三个参数：</p><blockquote><p>类的原型对象<br>需要装饰的属性名<br>装饰属性名的描述对象</p></blockquote><p>首先定义一个readonly装饰器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>)</span>&#123;</span><br><span class="line">  descriptor.writable = <span class="literal">false</span>; <span class="comment">// 将可写属性设为false</span></span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用readonly装饰类的name方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  <span class="function"><span class="title">name</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于以下调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readonly(Person.prototype, <span class="string">&#x27;name&#x27;</span>, descriptor);</span><br></pre></td></tr></table></figure><p>如果一个方法有多个装饰器，就像洋葱一样，先从外到内进入，再由内到外执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;evaluated&#x27;</span>, id);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, property, descriptor</span>) =&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;executed&#x27;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    @dec(<span class="number">1</span>)</span><br><span class="line">    @dec(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="title">method</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// evaluated 1</span></span><br><span class="line"><span class="comment">// evaluated 2</span></span><br><span class="line"><span class="comment">// executed 2</span></span><br><span class="line"><span class="comment">// executed 1</span></span><br></pre></td></tr></table></figure><p>外层装饰器@dec(1)先进入，但是内层装饰器@dec(2)先执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-说说var、let、const之间的区别&quot;&gt;&lt;a href=&quot;#1-说说var、let、const之间的区别&quot; class=&quot;headerlink&quot; title=&quot;1.说说var、let、const之间的区别&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.说说var、let、</summary>
      
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="es6" scheme="http://example.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>提升webpack打包速度的方法</title>
    <link href="http://example.com/2021/03/25/%E6%8F%90%E5%8D%87webpack%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/03/25/%E6%8F%90%E5%8D%87webpack%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2021-03-25T11:28:40.000Z</published>
    <updated>2021-04-25T03:06:39.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-跟上技术的迭代，尽可能使用新版本的webpack-node-npm-yarn"><a href="#1-跟上技术的迭代，尽可能使用新版本的webpack-node-npm-yarn" class="headerlink" title="1.跟上技术的迭代，尽可能使用新版本的webpack,node,npm, yarn"></a><strong>1.跟上技术的迭代，尽可能使用新版本的webpack,node,npm, yarn</strong></h2><h2 id="2-在尽可能少的模块上应用loader"><a href="#2-在尽可能少的模块上应用loader" class="headerlink" title="2.在尽可能少的模块上应用loader"></a><strong>2.在尽可能少的模块上应用loader</strong></h2><blockquote><ul><li>合理的使用include或者exclude可以降低loader的使用频率，提高打包速度</li><li>那么图片文件是否需要配置include或者exclude呢，实际上是不需要的，因为无论引入哪里的图片，实际上都需要url-loader来帮我们打包到dist目录下</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        include: path.resolve(__dirname,<span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Plugin尽可能精简，并确保可靠"><a href="#3-Plugin尽可能精简，并确保可靠" class="headerlink" title="3.Plugin尽可能精简，并确保可靠"></a><strong>3.Plugin尽可能精简，并确保可靠</strong></h2><blockquote><ul><li>比如线上环境的配置文件中使用了optimize-css-assets-webpack-plugin这样一个插件，对我们的CSS文件进行了压缩，可是如果我们在开发环境下，是没有必要对代码进行压缩的。</li></ul></blockquote><h2 id="4-resolve参数合理配置"><a href="#4-resolve参数合理配置" class="headerlink" title="4.resolve参数合理配置"></a><strong>4.resolve参数合理配置</strong></h2><blockquote><ol><li>引入一个模块的时候，省略这个模块的后缀</li><li>引入一个文件夹路径时, 自动匹配路径下的index文件或child文件，一般不建议配置; 虽然mainFiles配置解决了我们的问题，但是它也会带来性能上的问题，因为需要在路径下不停的去找我们配置的名字的文件是否匹配,所以一般情况下我们不会配置这个参数</li><li>设置路径别名; 当看到的是lee这个路径的时候，实际上它是path.resolve(__dirname, ‘../src/child’)这个路径的别名</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>], <span class="comment">// 引入文件省略后缀</span></span><br><span class="line">    mainFiles: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;child&#x27;</span>], <span class="comment">// 引入路径，自动查找文件</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: path.resolve(__dirname,<span class="string">&#x27;../src&#x27;</span>) <span class="comment">// 设置路径别名</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-使用DLLPlugin提升打包速度"><a href="#5-使用DLLPlugin提升打包速度" class="headerlink" title="5.使用DLLPlugin提升打包速度"></a><strong>5.使用DLLPlugin提升打包速度</strong></h2><blockquote><p>背景: 我们在引入第三方模块的时候，每次重新打包的时候，webpack都要重新分析这些第三方模块，然后把它们打包到我们的项目之中。</p></blockquote><blockquote><p>解决方案: 我们可以把这些第三方模块单独打包生成一个文件，只在第一次打包的时候去分析这个文件里的代码，之后再打包的时候，直接用这个分析过的结果就可以了，这是一个最理想的优化方式。</p></blockquote><p>具体操作:</p><ol><li>创建一个配置文件，姑且命名为webpack.dll.js</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendors: [<span class="string">&#x27;vue&#x27;</span>, <span class="string">&#x27;vue-router&#x27;</span>, <span class="string">&#x27;vuex&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;[name].dll.js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;../dll&#x27;</span>),</span><br><span class="line">    <span class="comment">//  打包生成了webpack.dll.js这个文件，通过一个全局变量暴露出来</span></span><br><span class="line">    library: <span class="string">&#x27;[name]&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 用DllPlugin这个插件, 来分析上面生成的库文件</span></span><br><span class="line">    <span class="comment">// 把库里一些第三方模块的映射关系，放到vendors.manifest.json文件中</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      name: <span class="string">&#x27;[name]&#x27;</span>, <span class="comment">// 要分析文件的名字，要跟库保持一致</span></span><br><span class="line">      path: path.resolve(__dirname, <span class="string">&#x27;../dll/[name].manifest.json&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后再在package.json里再配置一个命令</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scrtpts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build:dll&quot;</span>: <span class="string">&quot;webpack --config ./webpack.dll.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>然后我们运行打包命令npm run build:dll把引入的三个模块，打包到了dll文件夹下的vendors.dll.js文件</p></li><li><p>然后再html中引入vendors.dll.js文件; 需要安装一个插件 npm install add-asset-html-webpack-plugin –save,这个插件的作用就是往html-webpack-plugin上再去增加一些静态的资源</p></li><li><p>结合全局变量和刚才生成的vendors.manifest.json文件, 对我们源代码进行分析，一旦分析出来，使用的模块内容，是在vendors.dll.js里，那么它就会直接去使用vendors.dll.js里的内容了，就不会去node_modules引入第三方模块了</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addAssetHtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;add-asset-html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> addAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">      filePath: path.resolve(__dirname, <span class="string">&#x27;../dll/vendors.dll.js&#x27;</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 使用DllReferencePlugin这个插件, 当去打包src下的index.js时候，会引入一些第三方的模块</span></span><br><span class="line">    <span class="comment">// 当发现我们在引入一些第三方模块时，会到vendors.manifest.json去找第三方模块的映射关系</span></span><br><span class="line">    <span class="comment">// 如果能找到映射关系，它就知道没必要再打包出来，直接从vendors.dll.js里拿过来用就可以了</span></span><br><span class="line">    <span class="comment">// 它会从定义的全局变量中拿，但是如果发现引入的第三方模块不在映射关系里，才会到node_modules中拿过来打包</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      manifest: path.resolve(__dirname, <span class="string">&#x27;../dll/vendors.manifest.json&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-控制包文件的大小"><a href="#6-控制包文件的大小" class="headerlink" title="6.控制包文件的大小"></a><strong>6.控制包文件的大小</strong></h2><blockquote><ul><li>一些用不到的包，要通过Tree Shaking去除掉</li><li>还可以通过splitchunksplugin这样的插件对代码进行拆分，把一个大的文件拆分成小的文件，进行webpack的打包处理，这样也可以提升webpack的打包速度</li></ul></blockquote><h2 id="7-thread-loader-parallel-webpack-happypack-多进程进行打包"><a href="#7-thread-loader-parallel-webpack-happypack-多进程进行打包" class="headerlink" title="7.thread-loader,parallel-webpack,happypack 多进程进行打包"></a><strong>7.thread-loader,parallel-webpack,happypack 多进程进行打包</strong></h2><blockquote><p>webpack默认是同构NodeJS来运行的，所以是一个单进程的打包过程，有时候，我们可以借助node里的多进程来帮助我们提升webpack的打包速度</p></blockquote><h2 id="8-合理使用-sourceMap"><a href="#8-合理使用-sourceMap" class="headerlink" title="8.合理使用 sourceMap"></a><strong>8.合理使用 sourceMap</strong></h2><blockquote><p>打包的时候，生成的sourceMap越详细，打包的速度就越慢，所以我们要思考，不同环境打包的时候，什么样的sourceMap是最合适的，既要保证我们及时发现代码里的问题。<br>production模式下配置cheap-module-source-map;<br>development模式下配置eval-cheap-module-source-map</p></blockquote><h2 id="9-开发环境内存编译"><a href="#9-开发环境内存编译" class="headerlink" title="9.开发环境内存编译"></a><strong>9.开发环境内存编译</strong></h2><blockquote><p>我们在开发环境的时候使用的是webpack dev server,它在做打包的时候，不会生成dist目录，他会把编译生成的内容放到内存里，内存的读取，肯定要比硬盘的读取快的多，所以通过这种手段，也可以让我们在开发的过程中，webpack的性能得到很大的提升</p></blockquote><h2 id="10-开发环境，无用插件剔除"><a href="#10-开发环境，无用插件剔除" class="headerlink" title="10.开发环境，无用插件剔除"></a><strong>10.开发环境，无用插件剔除</strong></h2><blockquote><p>比如项目调试的时候，我们并不需要对代码进行压缩，我们就应该把mode设置成development而不是production,如果开发环境下就压缩的话是没用意义的，这会降低webpack的打包速度</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-跟上技术的迭代，尽可能使用新版本的webpack-node-npm-yarn&quot;&gt;&lt;a href=&quot;#1-跟上技术的迭代，尽可能使用新版本的webpack-node-npm-yarn&quot; class=&quot;headerlink&quot; title=&quot;1.跟上技术的迭代，尽可</summary>
      
    
    
    
    <category term="webpack" scheme="http://example.com/categories/webpack/"/>
    
    
    <category term="webpack" scheme="http://example.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件间通信方式</title>
    <link href="http://example.com/2021/03/24/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2021/03/24/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2021-03-24T08:28:36.000Z</published>
    <updated>2021-04-25T03:06:39.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件间通信的分类"><a href="#组件间通信的分类" class="headerlink" title="组件间通信的分类"></a><strong>组件间通信的分类</strong></h2><blockquote><ul><li>父子组件之间的通信</li><li>兄弟组件之间的通信</li><li>祖孙与后代组件之间的通信</li><li>非关系组件间之间的通信</li></ul></blockquote><h2 id="组件间通信的方案"><a href="#组件间通信的方案" class="headerlink" title="组件间通信的方案"></a><strong>组件间通信的方案</strong></h2><p>整理vue中8种常规的通信方案</p><blockquote><ol><li>通过 props 传递</li><li>通过 $emit 触发自定义事件</li><li>使用 ref</li><li>EventBus</li><li>parent 或 root</li><li>attrs 与 listeners</li><li>Provide 与 Inject</li><li>Vuex</li></ol></blockquote><h3 id="1-props传递数据"><a href="#1-props传递数据" class="headerlink" title="1.props传递数据"></a><strong>1.props传递数据</strong></h3><blockquote><ul><li>适用场景：父组件传递数据给子组件</li><li>子组件设置props属性，定义接收父组件传递过来的参数</li><li>父组件在使用子组件标签中通过字面量来传递值</li></ul></blockquote><p>Children.vue组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">  <span class="comment">// 字符串形式</span></span><br><span class="line">  name:<span class="built_in">String</span> <span class="comment">// 接收的类型参数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象形式</span></span><br><span class="line">  age:&#123;  </span><br><span class="line">    type:<span class="built_in">Number</span>, <span class="comment">// 接收的类型为数值</span></span><br><span class="line">    defaule:<span class="number">18</span>,  <span class="comment">// 默认值为18</span></span><br><span class="line">    <span class="built_in">require</span>:<span class="literal">true</span> <span class="comment">// age属性必须传递</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Father.vue组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Children</span> <span class="attr">name</span>=<span class="string">&quot;jack&quot;</span> <span class="attr">age</span>=<span class="string">18</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-emit-触发自定义事件"><a href="#2-emit-触发自定义事件" class="headerlink" title="2.$emit 触发自定义事件"></a><strong>2.$emit 触发自定义事件</strong></h3><blockquote><ul><li>适用场景：子组件传递数据给父组件</li><li>子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值</li><li>父组件绑定监听器获取到子组件传递过来的参数</li></ul></blockquote><p>Children.vue组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;add&#x27;</span>, good)</span><br></pre></td></tr></table></figure><p>Father.vue组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Children</span> @<span class="attr">add</span>=<span class="string">&quot;cartAdd($event)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-ref"><a href="#3-ref" class="headerlink" title="3.ref"></a><strong>3.ref</strong></h3><blockquote><ul><li>父组件在使用子组件的时候设置ref</li><li>父组件通过设置子组件ref来获取数据</li></ul></blockquote><p>父组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Children ref=<span class="string">&quot;foo&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$refs.foo  <span class="comment">// 获取子组件实例，通过子组件实例我们就能拿到对应的数据</span></span><br></pre></td></tr></table></figure><h3 id="4-EventBus"><a href="#4-EventBus" class="headerlink" title="4.EventBus"></a><strong>4.EventBus</strong></h3><blockquote><ul><li>使用场景：兄弟组件传值</li><li>创建一个中央时间总线EventBus</li><li>兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值</li><li>另一个兄弟组件通过$on监听自定义事件</li></ul></blockquote><p>Bus.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue()</span><br><span class="line">vm.$on(<span class="string">&#x27;listener&#x27;</span>, callback)</span><br><span class="line">vm.$emit(<span class="string">&#x27;listener&#x27;</span>, data)</span><br><span class="line">vm.$off(<span class="string">&#x27;listener&#x27;</span>, callback)</span><br></pre></td></tr></table></figure><p>自定义Bus.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 存放事件的名字</span></span><br><span class="line">    <span class="built_in">this</span>.callbacks = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  $on(name, fn) &#123;</span><br><span class="line">    <span class="built_in">this</span>.callbacks[name] = <span class="built_in">this</span>.callbacks[name] || []</span><br><span class="line">    <span class="built_in">this</span>.callbacks[name].push(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  $emit(name, args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.callbacks[name]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks[name].forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  $off(name, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.callbacks[name]) &#123;</span><br><span class="line">      <span class="keyword">let</span> delIndex = <span class="built_in">this</span>.callbacks[name].indexOf(fn)</span><br><span class="line">      <span class="built_in">this</span>.callbacks[name].splice(delIndex, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-parent或root"><a href="#5-parent或root" class="headerlink" title="5.parent或root"></a><strong>5.parent或root</strong></h3><p>通过共同祖辈$parent或者$root搭建通信侨联</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 兄弟组件</span></span><br><span class="line"><span class="built_in">this</span>.$parent.on(<span class="string">&#x27;add&#x27;</span>,<span class="built_in">this</span>.add)</span><br><span class="line"><span class="comment">// 另一个兄弟组件</span></span><br><span class="line"><span class="built_in">this</span>.$parent.emit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接通过$parent.$refs访问另一个兄弟组件</span></span><br><span class="line"><span class="built_in">this</span>.$parent.$refs.foo</span><br></pre></td></tr></table></figure><h3 id="6-attrs与listeners"><a href="#6-attrs与listeners" class="headerlink" title="6.attrs与listeners"></a><strong>6.attrs与listeners</strong></h3><blockquote><ul><li>适用场景：祖先传递数据给子孙</li><li>设置批量向下传属性$attrs和 $listeners</li><li>包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。</li><li>可以通过 v-bind=”$attrs” 传⼊内部组件</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- child组件：并未在props中声明foo --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$attrs.foo&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- parent组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">foo</span>=<span class="string">&quot;foo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 给Grandson隔代传值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">msg</span>=<span class="string">&quot;lalala&quot;</span> @<span class="attr">some-event</span>=<span class="string">&quot;onSomeEvent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在Child组件中引用Grandson组件时直接做展开 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Grandson</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Grandson</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Grandson使⽤ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from grandson&#x27;)&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;msg&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-provide-与-inject"><a href="#7-provide-与-inject" class="headerlink" title="7.provide 与 inject"></a><strong>7.provide 与 inject</strong></h3><blockquote><ul><li>在祖先组件定义provide属性，返回传递的值</li><li>在后代组件通过inject接收组件传递过来的值</li></ul></blockquote><p>祖先组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">provide</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo:<span class="string">&#x27;foo&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后代组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inject:[<span class="string">&#x27;foo&#x27;</span>] <span class="comment">// 获取到祖先组件传递过来的值</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><blockquote><ul><li>父子关系的组件数据传递选择 props  与 $emit进行传递，也可选择ref</li><li>兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递</li><li>祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject</li><li>复杂关系的组件数据传递可以通过vuex存放共享的变量</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组件间通信的分类&quot;&gt;&lt;a href=&quot;#组件间通信的分类&quot; class=&quot;headerlink&quot; title=&quot;组件间通信的分类&quot;&gt;&lt;/a&gt;&lt;strong&gt;组件间通信的分类&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;父子组件之间的通信&lt;</summary>
      
    
    
    
    <category term="vue.js" scheme="http://example.com/categories/vue-js/"/>
    
    
    <category term="组件间通信" scheme="http://example.com/tags/%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>自定义指令模拟v-model</title>
    <link href="http://example.com/2021/03/23/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E6%A8%A1%E6%8B%9Fv-model/"/>
    <id>http://example.com/2021/03/23/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E6%A8%A1%E6%8B%9Fv-model/</id>
    <published>2021-03-23T09:50:07.000Z</published>
    <updated>2021-04-25T03:06:39.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a><strong>钩子函数</strong></h2><p><img src="/images/gzhs.png" alt="指令"></p><h2 id="钩子函数的参数"><a href="#钩子函数的参数" class="headerlink" title="钩子函数的参数"></a><strong>钩子函数的参数</strong></h2><p><img src="/images/gzcs.png" alt="指令"></p><h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a><strong>模拟实现</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;mymodel&#x27;</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding, vnode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm = vnode.context</span><br><span class="line">    <span class="keyword">const</span> &#123; value, expression &#125; = binding</span><br><span class="line">    el.value = value</span><br><span class="line">    el.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      vm[expression] = e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当数据被更新的时候，需要更新指令绑定的元素</span></span><br><span class="line">  update: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = binding</span><br><span class="line">    el.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;钩子函数&quot;&gt;&lt;a href=&quot;#钩子函数&quot; class=&quot;headerlink&quot; title=&quot;钩子函数&quot;&gt;&lt;/a&gt;&lt;strong&gt;钩子函数&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/gzhs.png&quot; alt=&quot;指令&quot;&gt;&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="vue.js" scheme="http://example.com/categories/vue-js/"/>
    
    
    <category term="指令" scheme="http://example.com/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目性能优化</title>
    <link href="http://example.com/2021/03/17/Vue%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/03/17/Vue%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-03-17T05:46:38.000Z</published>
    <updated>2021-04-25T03:06:39.862Z</updated>
    
    <content type="html"><![CDATA[<p>Vue项目优化, 以下三部分组成:</p><blockquote><ul><li>基础的 Web 技术层面的优化。</li><li>webpack 配置层面的优化；</li><li>Vue 代码层面的优化；</li></ul></blockquote><h2 id="一-基础的-Web-技术优化"><a href="#一-基础的-Web-技术优化" class="headerlink" title="一.基础的 Web 技术优化"></a><strong>一.基础的 Web 技术优化</strong></h2><h3 id="1-开启-gzip-压缩"><a href="#1-开启-gzip-压缩" class="headerlink" title="1.开启 gzip 压缩"></a><strong>1.开启 gzip 压缩</strong></h3><p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。</p><p>目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右</p><h3 id="2-浏览器缓存"><a href="#2-浏览器缓存" class="headerlink" title="2.浏览器缓存"></a><strong>2.浏览器缓存</strong></h3><p>为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强缓存，协商缓存）</p><h3 id="3-CDN-的使用"><a href="#3-CDN-的使用" class="headerlink" title="3.CDN 的使用"></a><strong>3.CDN 的使用</strong></h3><p>浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。</p><h3 id="4-使用-Chrome-Performance-查找性能瓶颈"><a href="#4-使用-Chrome-Performance-查找性能瓶颈" class="headerlink" title="4.使用 Chrome Performance 查找性能瓶颈"></a><strong>4.使用 Chrome Performance 查找性能瓶颈</strong></h3><p>window.performance是W3C性能小组引入的新的API，目前IE9以上的浏览器都支持。</p><p><img src="/images/performance.png" alt="Performance"></p><p>字段说明:</p><p><b class="c42b983">connectStart</b> 和 <b class="c42b983">connectEnd</b>: 分别代表TCP建立连接和连接成功的时间节点。</p><p><b class="c42b983">domComplete</b>：html文档完全解析完毕的时间节点。</p><p><b class="c42b983">domContentLoadedEventStart</b> 和 <b class="c42b983">domContentLoadedEventEnd</b>：代表DOMContentLoaded事件触发和完成的时间节点。页面文档完全加载并解析完毕之后,会触发DOMContentLoaded事件，HTML文档不会等待样式文件,图片文件,子框架页面的加载(load事件可以用来检测HTML页面是否完全加载完毕(fully-loaded))。</p><p><b class="c42b983">domInteractive</b>：代表浏览器解析html文档的状态为interactive时的时间节点。domInteractive并非DOMReady，它早于DOMReady触发，代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点。</p><p><b class="c42b983">domLoading</b>：代表浏览器开始解析html文档的时间节点。我们知道IE浏览器下的document有readyState属性，domLoading的值就等于readyState改变为loading的时间节点。</p><p><b class="c42b983">domainLookupStart</b> 和 <b class="c42b983">domainLookupEnd</b>：分别代表DNS查询的开始和结束时间节点。如果浏览器没有进行DNS查询（比如使用了cache），则两者的值都等于fetchStart。</p><p><b class="c42b983">fetchStart</b>：是指在浏览器发起任何请求之前的时间值。在fetchStart和domainLookupStart之间，浏览器会检查当前文档的缓存。</p><p><b class="c42b983">loadEventStart</b> 和 <b class="c42b983">loadEventEnd</b>：分别代表onload事件触发和结束的时间节点。</p><p><b class="c42b983">navigationStart</b>：代表浏览器开始unload前一个页面文档的开始时间节点。比如我们当前正在浏览baidu.com，在地址栏输入google.com并回车，浏览器的执行动作依次为：unload当前文档（即baidu.com）-&gt;请求下一文档（即google.com）。navigationStart的值便是触发unload当前文档的时间节点。</p><p><b class="c42b983">redirectStart</b> 和 <b class="c42b983">redirectEnd</b>：如果页面是由redirect而来，则redirectStart和redirectEnd分别代表redirect开始和结束的时间节点。</p><p><b class="c42b983">requestStart</b>：代表浏览器发起请求的时间节点，请求的方式可以是请求服务器、缓存、本地资源等。</p><p><b class="c42b983">responseStart</b> 和 <b class="c42b983">responseEnd</b>：分别代表浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻。</p><p><b class="c42b983">secureConnectionStart</b>：可选。如果页面使用HTTPS，它的值是安全连接握手之前的时刻。如果该属性不可用，则返回undefined。如果该属性可用，但没有使用HTTPS，则返回0。</p><p><b class="c42b983">unloadEventStart</b> 和 <b class="c42b983">unloadEventEnd</b>：如果前一个文档和请求的文档是同一个域的，则unloadEventStart和unloadEventEnd分别代表浏览器unload前一个文档的开始和结束时间节点。否则两者都等于0。</p><p>主要性能指标：</p><blockquote><ul><li>DNS查询耗时 = domainLookupEnd - domainLookupStart</li><li>TCP链接耗时 = connectEnd - connectStart</li><li>request请求耗时 = responseEnd - responseStart</li><li>解析dom树耗时 = domComplete - domInteractive</li><li>白屏时间 = domLoading - fetchStart</li><li>domready时间 = domContentLoadedEventEnd - fetchStart</li><li>onload时间 = loadEventEnd - fetchStart</li></ul></blockquote><h2 id="二-Webpack-层面的优化"><a href="#二-Webpack-层面的优化" class="headerlink" title="二.Webpack 层面的优化"></a><strong>二.Webpack 层面的优化</strong></h2><h3 id="1-Webpack-对图片进行压缩"><a href="#1-Webpack-对图片进行压缩" class="headerlink" title="1 Webpack 对图片进行压缩"></a><strong>1 Webpack 对图片进行压缩</strong></h3><p>在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。</p><p>所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片：</p><ol><li>首先，安装 image-webpack-loader:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install image-webpack-loader --save-dev</span><br></pre></td></tr></table></figure><ol start="2"><li>然后，在 webpack.base.conf.js 中进行配置：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,</span><br><span class="line">  use:[</span><br><span class="line">    &#123;</span><br><span class="line">    loader: &#x27;url-loader&#x27;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: 10000,</span><br><span class="line">      name: utils.assetsPath(&#x27;img/[name].[hash:7].[ext]&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &#x27;image-webpack-loader&#x27;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        bypassOnDebug: true,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-减少-ES6-转为-ES5-的冗余代码"><a href="#2-减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="2.减少 ES6 转为 ES5 的冗余代码"></a><strong>2.减少 ES6 转为 ES5 的冗余代码</strong></h3><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class HelloWebpack extends Component&#123;...&#125;</span><br></pre></td></tr></table></figure><p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">babel-runtime&#x2F;helpers&#x2F;createClass  &#x2F;&#x2F; 用于实现 class 语法</span><br><span class="line">babel-runtime&#x2F;helpers&#x2F;inherits  &#x2F;&#x2F; 用于实现 extends 语法</span><br></pre></td></tr></table></figure><p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。</p><p>为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime/helpers/createClass’) 的方式导入，这样就能做到只让它们出现一次。</p><p>babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p><ol><li>首先，安装 babel-plugin-transform-runtime ：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-transform-runtime --save-dev</span><br></pre></td></tr></table></figure><ol start="2"><li>然后，修改 .babelrc 配置文件为：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    <span class="string">&quot;transform-runtime&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="3-提取公共代码"><a href="#3-提取公共代码" class="headerlink" title="3.提取公共代码"></a><strong>3.提取公共代码</strong></h3><p>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：</p><blockquote><ul><li>相同的资源被重复加载，浪费用户的流量和服务器的成本。</li><li>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。</li></ul></blockquote><p>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">&#x27;vendor&#x27;</span>,</span><br><span class="line">  minChunks: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">      /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">      <span class="built_in">module</span>.resource.indexOf(</span><br><span class="line">        path.join(__dirname, <span class="string">&#x27;../node_modules&#x27;</span>)</span><br><span class="line">      ) === <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 抽取出代码模块的映射关系</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">&#x27;manifest&#x27;</span>,</span><br><span class="line">  chunks: [<span class="string">&#x27;vendor&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-模板预编译"><a href="#4-模板预编译" class="headerlink" title="4.模板预编译"></a><strong>4.模板预编译</strong></h3><p>当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。</p><p>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。</p><p>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p><h3 id="5-提取组件的-CSS"><a href="#5-提取组件的-CSS" class="headerlink" title="5.提取组件的 CSS"></a><strong>5.提取组件的 CSS</strong></h3><p>当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。</p><p>将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。</p><h3 id="6-优化-SourceMap"><a href="#6-优化-SourceMap" class="headerlink" title="6.优化 SourceMap"></a><strong>6.优化 SourceMap</strong></h3><p>我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，</p><p>当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。</p><p>SourceMap 的可选值如下（+ 号越多，代表速度越快，- 号越多，代表速度越慢, o 代表中等速度 ）</p><p><img src="/images/yy.png" alt="SourceMap"></p><p>开发环境推荐：cheap-module-eval-source-map</p><p>生产环境推荐：cheap-module-source-map</p><p>原因如下：</p><blockquote><p>cheap：源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；</p></blockquote><blockquote><p>module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；</p></blockquote><blockquote><p>soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性；</p></blockquote><blockquote><p>eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。</p></blockquote><h3 id="7-构建结果输出分析"><a href="#7-构建结果输出分析" class="headerlink" title="7.构建结果输出分析"></a><strong>7.构建结果输出分析</strong></h3><p>Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。</p><p>为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。</p><p>接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。</p><p>我们在项目中 webpack.prod.conf.js 进行配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.build.bundleAnalyzerReport) &#123;</span><br><span class="line">  <span class="keyword">var</span> BundleAnalyzerPlugin =   <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).BundleAnalyzerPlugin;</span><br><span class="line">  webpackConfig.plugins.push(<span class="keyword">new</span> BundleAnalyzerPlugin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 $ npm run build --report 后生成分析报告：</p><h3 id="8-Vue-项目的编译优化"><a href="#8-Vue-项目的编译优化" class="headerlink" title="8.Vue 项目的编译优化"></a><strong>8.Vue 项目的编译优化</strong></h3><p>如果你的 Vue 项目使用 Webpack 编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的 Webpack 配置进行优化，提高 Webpack 的构建效率。</p><h2 id="Vue-代码层面的优化"><a href="#Vue-代码层面的优化" class="headerlink" title="Vue 代码层面的优化"></a><strong>Vue 代码层面的优化</strong></h2><h3 id="1-v-if-和-v-show-区分使用场景"><a href="#1-v-if-和-v-show-区分使用场景" class="headerlink" title="1.v-if 和 v-show 区分使用场景"></a><strong>1.v-if 和 v-show 区分使用场景</strong></h3><h3 id="2-computed-和-watch-区分使用场景"><a href="#2-computed-和-watch-区分使用场景" class="headerlink" title="2.computed 和 watch 区分使用场景"></a><strong>2.computed 和 watch 区分使用场景</strong></h3><p>computed：是计算属性，依赖其它属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值；</p><p>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p>运用场景：</p><blockquote><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p></blockquote><h3 id="3-v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#3-v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="3.v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a><strong>3.v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</strong></h3><ol><li><p>v-for 遍历必须为 item 添加 key<br>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p></li><li><p>v-for 遍历避免同时使用 v-if<br>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p></li></ol><h3 id="4-路由懒加载"><a href="#4-路由懒加载" class="headerlink" title="4.路由懒加载"></a><strong>4.路由懒加载</strong></h3><p>Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。</p><p>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。</p><h3 id="5-第三方插件的按需引入"><a href="#5-第三方插件的按需引入" class="headerlink" title="5.第三方插件的按需引入"></a><strong>5.第三方插件的按需引入</strong></h3><p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：</p><ol><li><p>首先，安装 babel-plugin-component ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure></li><li><p>然后，将 .babelrc 修改为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [[<span class="string">&quot;es2015&quot;</span>, &#123; <span class="attr">&quot;modules&quot;</span>: <span class="literal">false</span> &#125;]],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;component&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;libraryName&quot;</span>: <span class="string">&quot;element-ui&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;styleLibraryName&quot;</span>: <span class="string">&quot;theme-chalk&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>3.在 main.js 中引入部分组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Button)</span><br><span class="line">Vue.use(Select)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vue项目优化, 以下三部分组成:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;基础的 Web 技术层面的优化。&lt;/li&gt;
&lt;li&gt;webpack 配置层面的优化；&lt;/li&gt;
&lt;li&gt;Vue 代码层面的优化；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2</summary>
      
    
    
    
    <category term="性能优化" scheme="http://example.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端常见跨域解决方案</title>
    <link href="http://example.com/2021/03/17/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2021/03/17/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-03-17T02:08:26.000Z</published>
    <updated>2021-04-25T03:06:39.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a><strong>什么是跨域？</strong></h2><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</p><p>什么是同源策略？</p><p>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”<b class="c42b983">协议+域名+端口</b>“三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>同源策略限制以下几种行为：</p><blockquote><ul><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM 和 Js对象无法获得</li><li>AJAX 请求不能发送</li></ul></blockquote><h2 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a><strong>常见跨域场景</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">URL                                      说明                    是否允许通信</span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;a.js</span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;b.js         同一域名，不同文件或路径           允许</span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;lab&#x2F;c.js</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;www.domain.com:8000&#x2F;a.js</span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;b.js         同一域名，不同端口                不允许</span><br><span class="line"> </span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;a.js</span><br><span class="line">https:&#x2F;&#x2F;www.domain.com&#x2F;b.js        同一域名，不同协议                不允许</span><br><span class="line"> </span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;a.js</span><br><span class="line">http:&#x2F;&#x2F;192.168.4.12&#x2F;b.js           域名和域名对应相同ip              不允许</span><br><span class="line"> </span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;a.js</span><br><span class="line">http:&#x2F;&#x2F;x.domain.com&#x2F;b.js           主域相同，子域不同                不允许</span><br><span class="line">http:&#x2F;&#x2F;domain.com&#x2F;c.js</span><br><span class="line"> </span><br><span class="line">http:&#x2F;&#x2F;www.domain1.com&#x2F;a.js</span><br><span class="line">http:&#x2F;&#x2F;www.domain2.com&#x2F;b.js        不同域名                         不允许</span><br></pre></td></tr></table></figure><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a><strong>跨域解决方案</strong></h2><blockquote><p>1.通过jsonp跨域<br>2.document.domain + iframe跨域<br>3.location.hash + iframe<br>4.window.name + iframe跨域<br>5.postMessage跨域<br>6.跨域资源共享（CORS）<br>7.nginx代理跨域<br>8.nodejs中间件代理跨域<br>9.WebSocket协议跨域</p></blockquote><h3 id="1-通过jsonp跨域"><a href="#1-通过jsonp跨域" class="headerlink" title="1.通过jsonp跨域"></a><strong>1.通过jsonp跨域</strong></h3><p>1.原生实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.type = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span><br><span class="line">script.src = <span class="string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleCallback</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端返回</span></span><br><span class="line">handleCallback(&#123;<span class="string">&quot;status&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;user&quot;</span>: <span class="string">&quot;admin&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>2.jquery ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>,</span><br><span class="line">  type: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  dataType: <span class="string">&#x27;jsonp&#x27;</span>,  <span class="comment">// 请求方式为jsonp</span></span><br><span class="line">  jsonpCallback: <span class="string">&quot;handleCallback&quot;</span>,    <span class="comment">// 自定义回调函数名</span></span><br><span class="line">  data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><b class="c42b983">jsonp缺点：只能实现get一种请求。</b></p><h3 id="2-document-domain-iframe跨域"><a href="#2-document-domain-iframe跨域" class="headerlink" title="2.document.domain + iframe跨域"></a><strong>2.document.domain + iframe跨域</strong></h3><p>此方案仅限主域相同，子域不同的跨域应用场景。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>1.父窗口：(<a href="http://www.domain.com/a.html">http://www.domain.com/a.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://child.domain.com/b.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.domain = <span class="string">&#x27;domain.com&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> user = <span class="string">&#x27;admin&#x27;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.子窗口：(<a href="http://child.domain.com/b.html">http://child.domain.com/b.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.domain = <span class="string">&#x27;domain.com&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取父窗口中变量</span></span></span><br><span class="line"><span class="javascript">  alert(<span class="string">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class="built_in">window</span>.parent.user);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-location-hash-iframe跨域"><a href="#3-location-hash-iframe跨域" class="headerlink" title="3.location.hash + iframe跨域"></a><strong>3.location.hash + iframe跨域</strong></h3><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p><p>1.a.html：(<a href="http://www.domain1.com/a.html">http://www.domain1.com/a.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 向b.html传hash值</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      iframe.src = iframe.src + <span class="string">&#x27;#user=admin&#x27;</span>;</span></span><br><span class="line">  &#125;, 1000);</span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="comment">// 开放给同域c.html的回调方法</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">onCallback</span>(<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">&#x27;data from c.html ---&gt; &#x27;</span> + res);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.b.html：(<a href="http://www.domain2.com/b.html">http://www.domain2.com/b.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain1.com/c.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 监听a.html传来的hash值，再传给c.html</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">      iframe.src = iframe.src + location.hash;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.c.html：(<a href="http://www.domain1.com/c.html">http://www.domain1.com/c.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 监听b.html传来的hash值</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 再通过操作同域a.html的js回调，将结果传回</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.parent.parent.onCallback(<span class="string">&#x27;hello: &#x27;</span> + location.hash.replace(<span class="string">&#x27;#user=&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-window-name-iframe跨域"><a href="#4-window-name-iframe跨域" class="headerlink" title="4.window.name + iframe跨域"></a><strong>4.window.name + iframe跨域</strong></h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>1.a.html：(<a href="http://www.domain1.com/a.html">http://www.domain1.com/a.html</a>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="function"><span class="keyword">function</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载跨域页面</span></span><br><span class="line">  iframe.src = url;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">  <span class="comment">// IE Firefox仅触发1次，Chrome Safari Opera会触发2次</span></span><br><span class="line">  <span class="comment">// Chrome Safari Opera 浏览器中当 IFRAME 标记被插入文档树后，载入&quot;about:blank&quot; 页面速度非常快立即就触发了 load 事件，以至于还没来得及执行为他指定新 URL 的语句；当新 URL 指定后，当前页面加载完成时又触发了一次 IFRAME 标记的 load 事件，这样总共就触发了两次。</span></span><br><span class="line">  <span class="comment">// 而IE Firefox等其他浏览器则是载入 &quot;about:blank&quot; 页花费时间加多，页面并未完全加载时其 URL 已经被改变，因此相对 Chrome Safari Opera 浏览器第一次 load 事件并没有触发，只有等新 URL 中的页面加载完毕后 load 事件才被触发，这样总共只触发了一次。</span></span><br><span class="line">  iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span></span><br><span class="line">      callback(iframe.contentWindow.name);</span><br><span class="line">      destoryFrame();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">      iframe.contentWindow.location = <span class="string">&#x27;http://www.domain1.com/proxy.html&#x27;</span>;</span><br><span class="line">      state = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">destoryFrame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    iframe.contentWindow.document.write(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    iframe.contentWindow.close();</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求跨域b页面数据</span></span><br><span class="line">proxy(<span class="string">&#x27;http://www.domain2.com/b.html&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  alert(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.proxy.html：(<a href="http://www.domain1.com/proxy.html">http://www.domain1.com/proxy.html</a>)</p><p>中间代理页，与a.html同域，内容为空即可。</p><p>3.b.html：(<a href="http://www.domain2.com/b.html">http://www.domain2.com/b.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.name = <span class="string">&#x27;This is domain2 data!&#x27;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="5-postMessage跨域"><a href="#5-postMessage跨域" class="headerlink" title="5.postMessage跨域"></a><strong>5.postMessage跨域</strong></h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><blockquote><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul></blockquote><p>用法：postMessage(data,origin)方法接受两个参数</p><p>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</p><p>origin： 协议+主机+端口号，可以设置为”*”，表示可以传递给任意窗口; 如果要指定和当前窗口同源的话设置为”/“。</p><p>1.a.html：(<a href="http://www.domain1.com/a.html">http://www.domain1.com/a.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>       </span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;aym&#x27;</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="comment">// 向domain2传送跨域数据</span></span></span><br><span class="line"><span class="javascript">    iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain2.com&#x27;</span>);</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 接受domain2返回数据</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;data from domain2 ---&gt; &#x27;</span> + e.data);</span></span><br><span class="line"><span class="javascript">  &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.b.html：(<a href="http://www.domain2.com/b.html">http://www.domain2.com/b.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 接收domain1的数据</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.data);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span></span><br><span class="line">    if (data) &#123;</span><br><span class="line">        data.number = 16;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 处理后再发回domain1</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">  &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-跨域资源共享（CORS）"><a href="#6-跨域资源共享（CORS）" class="headerlink" title="6.跨域资源共享（CORS）"></a><strong>6.跨域资源共享（CORS）</strong></h3><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p><p>需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。</p><p>目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p><p>1.前端设置</p><p>原生ajax</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials &#x3D; true;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.send(<span class="string">&#x27;user=admin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>axios设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.withCredentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>2.服务端设置</p><p>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p><p>nodejs设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跨域后台设置</span></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">  <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">  <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">  <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://www.domain1.com&#x27;</span>,    </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span></span><br><span class="line">  <span class="comment">// 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span></span><br><span class="line">  <span class="comment">// HttpOnly的作用是让js无法读取cookie </span></span><br><span class="line">  <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-nginx代理跨域"><a href="#7-nginx代理跨域" class="headerlink" title="7.nginx代理跨域"></a><strong>7.nginx代理跨域</strong></h3><h3 id="8-Nodejs中间件代理跨域"><a href="#8-Nodejs中间件代理跨域" class="headerlink" title="8.Nodejs中间件代理跨域"></a><strong>8.Nodejs中间件代理跨域</strong></h3><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p><h3 id="9-WebSocket协议跨域"><a href="#9-WebSocket协议跨域" class="headerlink" title="9.WebSocket协议跨域"></a><strong>9.WebSocket协议跨域</strong></h3><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p><p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1.前端代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>user input：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> socket = io(<span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="javascript">  socket.on(<span class="string">&#x27;connect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="javascript">      socket.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;data from server: ---&gt; &#x27;</span> + msg); </span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 监听服务端关闭</span></span></span><br><span class="line"><span class="javascript">      socket.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;Server socket has closed.&#x27;</span>); </span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    socket.send(<span class="built_in">this</span>.value);</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.Nodejs socket后台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接收信息</span></span><br><span class="line">  client.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    client.send(<span class="string">&#x27;hello：&#x27;</span> + msg);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data from client: ---&gt; &#x27;</span> + msg);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开处理</span></span><br><span class="line">  client.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Client socket has closed.&#x27;</span>); </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是跨域？&quot;&gt;&lt;a href=&quot;#什么是跨域？&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域？&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是跨域？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</summary>
      
    
    
    
    <category term="浏览器特性" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="跨域" scheme="http://example.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>javascript中的call和apply和bind</title>
    <link href="http://example.com/2021/03/12/javascript%E4%B8%AD%E7%9A%84call%E5%92%8Capply%E5%92%8Cbind/"/>
    <id>http://example.com/2021/03/12/javascript%E4%B8%AD%E7%9A%84call%E5%92%8Capply%E5%92%8Cbind/</id>
    <published>2021-03-12T08:35:55.000Z</published>
    <updated>2021-04-25T03:06:39.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="call-apply-bind的基本介绍"><a href="#call-apply-bind的基本介绍" class="headerlink" title="call,apply,bind的基本介绍"></a><strong>call,apply,bind的基本介绍</strong></h2><p>语法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, param1, param2, ...)</span><br><span class="line">fun.apply(thisArg, [param1,param2,...])</span><br><span class="line">fun.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></table></figure><p>返回值:</p><blockquote><p>call/apply：fun执行的结果<br>bind：返回fun的拷贝，并拥有指定的this值和初始参数</p></blockquote><p>参数: thisArg(可选)</p><blockquote><ul><li>fun的this指向thisArg对象</li><li>非严格模式下：thisArg指定为null，undefined，fun中的this指向window对象.</li><li>严格模式下：fun的this为undefined</li><li>值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象，如 String、Number、Boolean</li></ul></blockquote><p>param1,param2(可选): 传给fun的参数。</p><blockquote><ul><li>如果param不传或为 null/undefined，则表示不需要传入任何参数.</li><li>apply第二个参数为数组，数组内的值为传给fun的参数。</li></ul></blockquote><p>调用call/apply/bind的必须是个函数</p><p>call、apply和bind是挂在Function对象上的三个方法,只有函数才有这些方法。</p><p>只要是函数就可以，比如: Object.prototype.toString就是个函数，我们经常看到这样的用法：Object.prototype.toString.call(data)</p><p>区别：</p><p>call与apply的唯一区别</p><p>传给fun的参数写法不同：</p><p>apply是第2个参数，这个参数是一个数组：传给fun参数都写在数组中。</p><p>call从第2~n的参数都是传给fun的。</p><p>call/apply与bind的区别</p><p>执行：</p><p>call/apply改变了函数的this上下文后马上执行该函数</p><p>bind则是返回改变了上下文后的函数,不执行该函数</p><p>返回值:</p><p>call/apply 返回fun的执行结果</p><p>bind返回fun的拷贝，并指定了fun的this指向，保存了fun的参数。</p><p><span class="c42b983">bind</span> 是返回对应函数，便于稍后调用；<span class="c42b983">apply 、call</span> 则是立即调用 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)</span></span><br><span class="line">  <span class="comment">// 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象</span></span><br><span class="line">  context = (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) ? <span class="built_in">window</span> : <span class="built_in">Object</span>(context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于临时储存函数</span></span><br><span class="line">  <span class="keyword">const</span> specialPrototype = <span class="built_in">Symbol</span>(<span class="string">&#x27;唯一性&#x27;</span>);</span><br><span class="line">  <span class="comment">// 函数的this指向隐式绑定到context上</span></span><br><span class="line">  context[specialPrototype] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 通过隐式绑定执行函数并传递参数</span></span><br><span class="line">  <span class="keyword">let</span> res = context[specialPrototype](...args);</span><br><span class="line">  <span class="comment">// 删除上下文对象的属性</span></span><br><span class="line">  <span class="keyword">delete</span> context[specialPrototype];</span><br><span class="line">  <span class="comment">// 返回函数执行结果</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) ? <span class="built_in">window</span> : <span class="built_in">Object</span>(context)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp;  <span class="comment">// o不是null、undefined等</span></span><br><span class="line">        <span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> &amp;&amp;  <span class="comment">// o是对象</span></span><br><span class="line">        <span class="built_in">isFinite</span>(o.length) &amp;&amp; <span class="comment">// o.length是有限数值</span></span><br><span class="line">        o.length &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">// o.length为非负值</span></span><br><span class="line">        o.length === <span class="built_in">Math</span>.floor(o.length) &amp;&amp;    <span class="comment">// o.length是整数</span></span><br><span class="line">        o.length &lt; <span class="number">4294967296</span> <span class="comment">// o.length &lt; 2^32</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> specialPrototype = <span class="built_in">Symbol</span>(<span class="string">&#x27;唯一性&#x27;</span>);</span><br><span class="line">  context[specialPrototype] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(args) &amp;&amp; !isArrayLike(args)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;myApply 第二个参数不为数组并且不为类数组对象抛出错误&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 执行函数并展开数组，传递函数参数</span></span><br><span class="line">      res = context[specialPrototype](...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res = context[specialPrototype]();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context[specialPrototype];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> thisfn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> context = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    [].push.call(args, ..._args);</span><br><span class="line">    thisfn.call(context, ...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apply、call"><a href="#apply、call" class="headerlink" title="apply、call"></a><strong>apply、call</strong></h2><p>在 javascript 中，<span class="c42b983">call</span> 和 <span class="c42b983">apply</span> 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 <span class="c42b983">this</span> 的指向。<br>JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fruits</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fruits.prototype = &#123;</span><br><span class="line">    color: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;My color is &quot;</span> + <span class="built_in">this</span>.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> fruits;</span><br><span class="line">apple.say();    <span class="comment">//My color is red</span></span><br></pre></td></tr></table></figure><p>但是如果我们有一个对象 banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 <span class="c42b983">call</span> 或 <span class="c42b983">apply</span> 用 apple 的 say 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">banana = &#123;</span><br><span class="line">    color: <span class="string">&quot;yellow&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">apple.say.call(banana);     <span class="comment">//My color is yellow</span></span><br><span class="line">apple.say.apply(banana);    <span class="comment">//My color is yellow</span></span><br></pre></td></tr></table></figure><p>所以，可以看出 <span class="c42b983">call</span> 和 <span class="c42b983">apply</span> 是为了动态改变 <span class="c42b983">this</span> 而出现的，当一个 object 没有某个方法（本栗子中banana没有say方法），但是其他的有（本栗子中apple有say方法），我们可以借助<span class="c42b983">call</span> 或 <span class="c42b983">apply</span>用其它对象的方法来操作。</p><h2 id="apply、call-区别"><a href="#apply、call-区别" class="headerlink" title="apply、call 区别"></a><strong>apply、call 区别</strong></h2><p>对于 <span class="c42b983">apply</span>、<span class="c42b983">call</span> 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就可以通过如下方式来调用:</span></span><br><span class="line"></span><br><span class="line">func.call(<span class="built_in">this</span>, arg1, arg2);</span><br><span class="line">func.apply(<span class="built_in">this</span>, [arg1, arg2])</span><br></pre></td></tr></table></figure><p>其中 <span class="c42b983">this</span> 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，<span class="c42b983">call</span> 需要把参数按顺序传递进去，而 <span class="c42b983">apply</span> 则是把参数放在数组里。　　<br>为了巩固加深记忆，下面列举一些常用用法：</p><h2 id="apply、call实例"><a href="#apply、call实例" class="headerlink" title="apply、call实例"></a><strong>apply、call实例</strong></h2><h3 id="数组之间追加"><a href="#数组之间追加" class="headerlink" title="数组之间追加"></a><strong>数组之间追加</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">12</span> , <span class="string">&quot;foo&quot;</span> , &#123;<span class="attr">name</span>:<span class="string">&quot;Joe&quot;</span>&#125; , -<span class="number">2458</span>]; </span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">&quot;Doe&quot;</span> , <span class="number">555</span> , <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(array1, array2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// array1 值为  [12 , &quot;foo&quot; , &#123;name:&quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100] </span></span><br></pre></td></tr></table></figure><h3 id="获取数组中的最大值和最小值"><a href="#获取数组中的最大值和最小值" class="headerlink" title="获取数组中的最大值和最小值"></a><strong>获取数组中的最大值和最小值</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  numbers = [<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , -<span class="number">215</span> ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, numbers);   <span class="comment">//458</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>,<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , -<span class="number">215</span>); <span class="comment">//458</span></span><br></pre></td></tr></table></figure><p>number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。</p><h3 id="验证是否是数组（前提是toString-方法没有被重写过）"><a href="#验证是否是数组（前提是toString-方法没有被重写过）" class="headerlink" title="验证是否是数组（前提是toString()方法没有被重写过）"></a><strong>验证是否是数组（前提是toString()方法没有被重写过）</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">functionisArray</span>(<span class="params">obj</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&#x27;[object Array]&#x27;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类（伪）数组使用数组方法"><a href="#类（伪）数组使用数组方法" class="headerlink" title="类（伪）数组使用数组方法"></a><strong>类（伪）数组使用数组方法</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domNodes = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;*&quot;</span>));</span><br></pre></td></tr></table></figure><p>Javascript中存在一种名为伪数组的对象结构。比较特别的是 <span class="c42b983">arguments</span> 对象，还有像调用 <span class="c42b983">getElementsByTagName</span> , <span class="c42b983">document.childNodes</span> 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。<br>但是我们能通过 <span class="c42b983">Array.prototype.slice.call</span> 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a><strong>bind</strong></h2><p>在讨论<span class="c42b983">bind()</span>方法之前我们先来看一道题目：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> altwrite = <span class="built_in">document</span>.write;</span><br><span class="line">altwrite(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>结果：Uncaught TypeError: Illegal invocation<br>altwrite()函数改变<span class="c42b983">this的指向global或window对象</span>，导致执行时提示非法调用异常，正确的方案就是使用bind()方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">altwrite.bind(<span class="built_in">document</span>)(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>当然也可以使用<span class="c42b983">call()</span>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">altwrite.call(<span class="built_in">document</span>, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="绑定函数"><a href="#绑定函数" class="headerlink" title="绑定函数"></a><strong>绑定函数</strong></h3><p><span class="c42b983">bind()</span>最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。常见的错误就像上面的例子一样，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。如果不做特殊处理，一般会丢失原来的对象。使用bind()方法能够很漂亮的解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.num = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">var</span> mymodule = &#123;</span><br><span class="line">  num: <span class="number">81</span>,</span><br><span class="line">  getNum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mymodule.getNum(); <span class="comment">// 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNum = mymodule.getNum;</span><br><span class="line">getNum(); <span class="comment">// 9, 因为在这个例子中，&quot;this&quot;指向全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundGetNum = getNum.bind(mymodule);</span><br><span class="line">boundGetNum(); <span class="comment">// 81</span></span><br></pre></td></tr></table></figure><p><span class="c42b983">bind()</span> 方法与 <span class="c42b983">apply</span> 和 <span class="c42b983">call</span> 很相似，也是可以改变函数体内 <span class="c42b983">this</span> 的指向。</p><p>MDN的解释是：<span class="c42b983">bind()</span>方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 <span class="c42b983">bind()</span>方法的第一个参数作为 <span class="c42b983">this</span>，传入 <span class="c42b983">bind()</span> 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><p>直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 <span class="c42b983">_this</span> , <span class="c42b983">that</span> , <span class="c42b983">self</span> 等保存 <span class="c42b983">this</span> ，这样我们可以在改变了上下文之后继续引用到它。 像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar : <span class="number">1</span>,</span><br><span class="line">  eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    $(<span class="string">&#x27;.someClass&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/* Act on the event */</span></span><br><span class="line">      <span class="built_in">console</span>.log(_this.bar);     <span class="comment">//1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar : <span class="number">1</span>,</span><br><span class="line">  eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;.someClass&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* Act on the event */</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.bar);      <span class="comment">//1</span></span><br><span class="line">    &#125;.bind(<span class="built_in">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码里，<span class="c42b983">bind()</span> 创建了一个函数，当这个click事件绑定在被调用的时候，它的 <span class="c42b983">this</span> 关键词会被设置成被传入的值（这里指调用<span class="c42b983">bind()</span>时传入的参数）。因此，这里我们传入想要的上下文 <span class="c42b983">this</span>(其实就是 foo )，到 <span class="c42b983">bind()</span> 函数中。然后，当回调函数被执行的时候， <span class="c42b983">this</span> 便指向 foo 对象。再来一个简单的栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  x:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo);</span><br><span class="line">func(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这里我们创建了一个新的函数 func，当使用 <span class="c42b983">bind()</span> 创建一个绑定函数之后，它被执行的时候，它的 <span class="c42b983">this</span> 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。</p><h3 id="偏函数（Partial-Functions）"><a href="#偏函数（Partial-Functions）" class="headerlink" title="偏函数（Partial Functions）"></a><strong>偏函数（Partial Functions）</strong></h3><p>这是一个很好的特性，使用<span class="c42b983">bind()</span>我们设定函数的预定义参数，然后调用的时候传入其他参数即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预定义参数37</span></span><br><span class="line"><span class="keyword">var</span> leadingThirtysevenList = list.bind(<span class="literal">undefined</span>, <span class="number">37</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list2 = leadingThirtysevenList(); <span class="comment">// [37]</span></span><br><span class="line"><span class="keyword">var</span> list3 = leadingThirtysevenList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [37, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="和setTimeout一起使用"><a href="#和setTimeout一起使用" class="headerlink" title="和setTimeout一起使用"></a><strong>和setTimeout一起使用</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bloomer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.petalCount = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">12</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1秒后调用declare函数</span></span><br><span class="line">Bloomer.prototype.bloom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="built_in">this</span>.declare.bind(<span class="built_in">this</span>), <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bloomer.prototype.declare = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我有 &#x27;</span> + <span class="built_in">this</span>.petalCount + <span class="string">&#x27; 朵花瓣!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bloo = <span class="keyword">new</span> Bloomer();</span><br><span class="line">bloo.bloom(); <span class="comment">//我有 5 朵花瓣!</span></span><br></pre></td></tr></table></figure><p>注意：对于事件处理函数和setInterval方法也可以使用上面的方法</p><h3 id="绑定函数作为构造函数"><a href="#绑定函数作为构造函数" class="headerlink" title="绑定函数作为构造函数"></a><strong>绑定函数作为构造函数</strong></h3><p>绑定函数也适用于使用<span class="c42b983">new操作符</span>来构造目标函数的实例。当使用绑定函数来构造实例，注意：<span class="c42b983">this</span>会被忽略，但是传入的参数仍然可用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.x + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">this</span>.y);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">p.toString(); <span class="comment">// &#x27;1,2&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emptyObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> YAxisPoint = Point.bind(emptyObj, <span class="number">0</span><span class="comment">/*x*/</span>);</span><br><span class="line"><span class="comment">// 实现中的例子不支持,</span></span><br><span class="line"><span class="comment">// 原生bind支持:</span></span><br><span class="line"><span class="keyword">var</span> YAxisPoint = Point.bind(<span class="literal">null</span>, <span class="number">0</span><span class="comment">/*x*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> axisPoint = <span class="keyword">new</span> YAxisPoint(<span class="number">5</span>);</span><br><span class="line">axisPoint.toString(); <span class="comment">// &#x27;0,5&#x27;</span></span><br><span class="line"></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> Point; <span class="comment">// true</span></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> YAxisPoint; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Point(<span class="number">17</span>, <span class="number">42</span>) <span class="keyword">instanceof</span> YAxisPoint; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h3><p>上面的几个小节可以看出<span class="c42b983">bind()</span>有很多的使用场景，但是<span class="c42b983">bind()</span>函数是在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。这就需要我们自己实现<span class="c42b983">bind()</span>函数了。</p><p>首先我们可以通过给目标函数指定作用域来简单实现<span class="c42b983">bind()</span>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  self = <span class="built_in">this</span>;  <span class="comment">//保存this，即调用bind方法的目标函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.apply(context,<span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>考虑到函数柯里化的情况，我们可以构建一个更加健壮的<span class="c42b983">bind()</span>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">  self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">    <span class="keyword">return</span> self.apply(context,finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这次的<span class="c42b983">bind()</span>方法可以绑定对象，也支持在绑定的时候传参。</p><p>继续，Javascript的函数还可以作为构造函数，那么绑定后的函数用这种方式调用时，情况就比较微妙了，需要涉及到原型链的传递：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">  F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  self = <span class="built_in">this</span>,</span><br><span class="line">  bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">    <span class="keyword">return</span> self.apply((<span class="built_in">this</span> <span class="keyword">instanceof</span> F ? <span class="built_in">this</span> : context), finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  F.prototype = self.prototype;</span><br><span class="line">  bound.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是《JavaScript Web Application》一书中对<span class="c42b983">bind()</span>的实现：通过设置一个中转构造函数F，使绑定后的函数与调用<span class="c42b983">bind()</span>的函数处于同一原型链上，用new操作符调用绑定后的函数，返回的对象也能正常使用instanceof，因此这是最严谨的<span class="c42b983">bind()</span>实现。</p><p>对于为了在浏览器中能支持<span class="c42b983">bind()</span>函数，只需要对上述函数稍微修改即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), </span><br><span class="line">    fToBind = <span class="built_in">this</span>, </span><br><span class="line">    fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fToBind.apply(</span><br><span class="line">          <span class="built_in">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis ? <span class="built_in">this</span> : oThis || <span class="built_in">window</span>,</span><br><span class="line">          aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有个有趣的问题，如果连续 <span class="c42b983">bind()</span> 两次，亦或者是连续 <span class="c42b983">bind()</span> 三次那么输出的值是什么呢？像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    x:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sed = &#123;</span><br><span class="line">    x:<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo).bind(sed);</span><br><span class="line">func(); <span class="comment">//?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fiv = &#123;</span><br><span class="line">    x:<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo).bind(sed).bind(fiv);</span><br><span class="line">func(); <span class="comment">//?</span></span><br></pre></td></tr></table></figure><p>答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在Javascript中，多次 <span class="c42b983">bind()</span> 是无效的。更深层次的原因， <span class="c42b983">bind()</span> 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 <span class="c42b983">bind()</span> 相当于再包住第一次 <span class="c42b983">bind()</span> ,故第二次以后的 bind 是无法生效的。</p><h2 id="apply、call、bind比较"><a href="#apply、call、bind比较" class="headerlink" title="apply、call、bind比较"></a><strong>apply、call、bind比较</strong></h2><p>那么 <span class="c42b983">apply、call、bind</span> 三者相比较，之间又有什么异同呢？何时使用 <span class="c42b983">apply、call</span>，何时使用 <span class="c42b983">bind</span> 呢。简单的一个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">81</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.bind(obj)());  <span class="comment">//81</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.call(obj));    <span class="comment">//81</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.apply(obj));   <span class="comment">//81</span></span><br></pre></td></tr></table></figure><p>三个输出的都是81，但是注意看使用 <span class="c42b983">bind()</span> 方法的，他后面多了对括号。</p><p>也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 <span class="c42b983">bind()</span> 方法。而 <span class="c42b983">apply</span>/<span class="c42b983">call</span> 则会立即执行函数。</p><p>再总结一下：</p><p><span class="c42b983">apply 、 call 、bind</span> 三者都是用来改变函数的this对象的指向的；<br><span class="c42b983">apply 、 call 、bind</span> 三者第一个参数都是this要指向的对象，也就是想指定的上下文；<br><span class="c42b983">apply 、 call 、bind</span> 三者都可以利用后续参数传参；<br><span class="c42b983">bind</span> 是返回对应函数，便于稍后调用；<span class="c42b983">apply 、call</span> 则是立即调用 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;call-apply-bind的基本介绍&quot;&gt;&lt;a href=&quot;#call-apply-bind的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;call,apply,bind的基本介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;call,apply,bind的基本</summary>
      
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="call和apply和bind" scheme="http://example.com/tags/call%E5%92%8Capply%E5%92%8Cbind/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化的理解</title>
    <link href="http://example.com/2021/03/11/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/03/11/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2021-03-11T03:08:39.000Z</published>
    <updated>2021-04-25T03:06:39.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块的定义"><a href="#模块的定义" class="headerlink" title="模块的定义:"></a><strong>模块的定义:</strong></h2><p>可以理解成实现特定功能的相互独立的一组方法</p><h2 id="为什么要使用模块化"><a href="#为什么要使用模块化" class="headerlink" title="为什么要使用模块化:"></a><strong>为什么要使用模块化:</strong></h2><blockquote><ul><li>可维护性</li><li>命名空间</li><li>可复用性</li></ul></blockquote><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a><strong>模块化规范</strong></h2><blockquote><ul><li>CommonJS</li><li>Module(es6)</li><li>AMD</li><li>UMD</li><li>CMD</li></ul></blockquote><h2 id="common-js-和-es6-中模块引入的区别？"><a href="#common-js-和-es6-中模块引入的区别？" class="headerlink" title="common.js 和 es6 中模块引入的区别？"></a><strong>common.js 和 es6 中模块引入的区别？</strong></h2><p>CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。</p><p>运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。</p><p>自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。</p><p>但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。</p><p>在使用上的差别主要有：</p><blockquote><p>1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p></blockquote><blockquote><p>2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p></blockquote><blockquote><p>3、CommonJs 是单个值导出，ES6 Module可以导出多个</p></blockquote><blockquote><p>4、CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层</p></blockquote><blockquote><p>5、CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined</p></blockquote><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a><strong>CommonJS</strong></h3><p>CommonJS 是一套 Javascript 模块规范，用于服务端</p><p>CommonJS 扩展了JavaScript声明模块的API,</p><p>通过CommonJS，每个JS文件独立地存储它模块的内容（就像一个被括起来的闭包一样）。在这种作用域中，我们通过 module.exports 语句来导出对象为模块，再通过 require 语句来引入</p><blockquote><ul><li>所有代码都运行在模块作用域，不会污染全局作用域</li><li>模块是同步加载的，即只有加载完成，才能执行后面的操作</li><li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li><li>require返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li></ul></blockquote><p>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = myModule;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后再通过require去加载</span></span><br></pre></td></tr></table></figure><h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a><strong>ES Module</strong></h3><p>原生ＪＳ(es6)解决方案, ES6设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p><p>模块功能主要由两个命令构成：</p><blockquote><p>export：用于规定模块的对外接口<br>import：用于输入其他模块提供的功能</p></blockquote><p>如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myModule</span><br><span class="line"><span class="keyword">import</span> myModule <span class="keyword">from</span> <span class="string">&#x27;./myModule&#x27;</span></span><br></pre></td></tr></table></figure><p>动态加载</p><p>允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势</p><p>这个新功能允许您将import()作为函数调用，将其作为参数传递给模块的路径。它返回一个 promise，它用一个模块对象来实现，让你可以访问该对象的导出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;/modules/myModule.mjs&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Do something with the module.</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>复合写法</p><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure><p>同理能够搭配as、*搭配使用</p><h3 id="AMD-（Asynchronous-Module-Definition）"><a href="#AMD-（Asynchronous-Module-Definition）" class="headerlink" title="AMD （Asynchronous Module Definition）"></a><strong>AMD （Asynchronous Module Definition）</strong></h3><p>提倡依赖前置，在定义模块的时候就要声明其依赖的模块</p><p>异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行</p><p>代表库为require.js</p><p>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">&quot;js/lib&quot;</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;jquery&quot;</span>,<span class="string">&quot;underscore&quot;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$,_</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="CMD-Common-Module-Definition"><a href="#CMD-Common-Module-Definition" class="headerlink" title="CMD (Common Module Definition)"></a><strong>CMD (Common Module Definition)</strong></h3><p>CMD规范是国内SeaJS的推广过程中产生的<br>提倡就近依赖（按需加载），在用到某个模块的时候再去require</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="built_in">require</span>(<span class="string">&#x27;./one&#x27;</span>)</span><br><span class="line">  one.do()</span><br><span class="line"><span class="comment">// 就近依赖，按需加载</span></span><br><span class="line">  <span class="keyword">var</span>  two = <span class="built_in">require</span>(<span class="string">&#x27;./two&#x27;</span>)</span><br><span class="line">  two.do() </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="UMD-Universal-Module-Definition"><a href="#UMD-Universal-Module-Definition" class="headerlink" title="UMD (Universal Module Definition)"></a><strong>UMD (Universal Module Definition)</strong></h3><p>AMD和CommonJS的结合,跨平台的解决方案,UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块</p><p>如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = factory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        define(factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.eventUtil = factory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//module ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模块的定义&quot;&gt;&lt;a href=&quot;#模块的定义&quot; class=&quot;headerlink&quot; title=&quot;模块的定义:&quot;&gt;&lt;/a&gt;&lt;strong&gt;模块的定义:&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;可以理解成实现特定功能的相互独立的一组方法&lt;/p&gt;
&lt;h2 id=&quot;为什么要使</summary>
      
    
    
    
    <category term="工程化" scheme="http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="模块化" scheme="http://example.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>web安全攻击手段以及如何防范</title>
    <link href="http://example.com/2021/03/11/web%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83/"/>
    <id>http://example.com/2021/03/11/web%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83/</id>
    <published>2021-03-11T02:50:38.000Z</published>
    <updated>2021-04-25T03:06:39.866Z</updated>
    
    <content type="html"><![CDATA[<p>对于常规的Web攻击手段，如XSS、CRSF、SQL注入、（常规的不包括文件上传漏洞、DDoS攻击）等</p><p>比如XSS的防范需要转义掉输入的尖括号; 防止CRSF攻击需要将cookie设置为httponly，以及增加session相关的Hash token码; SQL注入的防范需要将分号等字符转义，</p><h2 id="xss-cross-site-scripting-跨站脚本攻击"><a href="#xss-cross-site-scripting-跨站脚本攻击" class="headerlink" title="xss(cross site scripting) 跨站脚本攻击"></a><strong>xss(cross site scripting) 跨站脚本攻击</strong></h2><p>定义: 指攻击者在网页嵌入脚本，用户浏览网页触发恶意脚本执行</p><blockquote><p>XSS攻击分为3类：存储型（持久型）、反射型（非持久型）、基于DOM</p></blockquote><p>如何防范:</p><blockquote><ul><li>设置HttpOnly以避免cookie劫持的危险 </li><li>过滤，对诸如script、img、a等标签进行过滤 </li><li>编码，像一些常见的符号，如&lt;&gt;在输入的时候要对其进行转换编码 </li><li>限制，对于一些可以预期的输入可以通过限制长度强制截断来进行防御</li></ul></blockquote><h2 id="CSRF-cross-site-request-forgery-跨站请求伪造-CSRF-或者-XSRF"><a href="#CSRF-cross-site-request-forgery-跨站请求伪造-CSRF-或者-XSRF" class="headerlink" title="CSRF(cross site request forgery) 跨站请求伪造(CSRF 或者 XSRF)"></a><strong>CSRF(cross site request forgery) 跨站请求伪造(CSRF 或者 XSRF)</strong></h2><p>CSRF攻击的全称是跨站请求伪造（ cross site request forgery)，是一种对网站的恶意利用，尽管听起来跟XSS跨站脚本攻击有点相似，但事实上CSRF与XSS差别很大，XSS利用的是站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的网站。</p><h3 id="CSRF攻击原理"><a href="#CSRF攻击原理" class="headerlink" title="CSRF攻击原理"></a><strong>CSRF攻击原理</strong></h3><blockquote><ol><li>首先用户C浏览并登录了受信任站点A；</li><li>登录信息验证通过以后，站点A会在返回给浏览器的信息中带上已登录的cookie，cookie信息会在浏览器端保存一定时间（根据服务端设置而定）；</li><li>完成这一步以后，用户在没有登出（清除站点A的cookie）站点A的情况下，访问恶意站点B；</li><li>这时恶意站点 B的某个页面向站点A发起请求，而这个请求会带上浏览器端所保存的站点A的cookie；</li><li>站点A根据请求所带的cookie，判断此请求为用户C所发送的。</li></ol></blockquote><p>因此，站点A会报据用户C的权限来处理恶意站点B所发起的请求，而这个请求可能以用户C的身份发送 邮件、短信、消息，以及进行转账支付等操作，这样恶意站点B就达到了伪造用户C请求站点 A的目的。</p><p>受害者只需要做下面两件事情，攻击者就能够完成CSRF攻击：</p><blockquote><ul><li>登录受信任站点 A，并在本地生成cookie；</li><li>在不登出站点A（清除站点A的cookie）的情况下，访问恶意站点B。</li></ul></blockquote><h3 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a><strong>CSRF的防御</strong></h3><p>1、尽量使用POST，限制GET</p><p>GET接口太容易被拿来做CSRF攻击，看上面示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。</p><p>当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。</p><p>2、将cookie设置为HttpOnly</p><p>CRSF攻击很大程度上是利用了浏览器的cookie，为了防止站内的XSS漏洞盗取cookie,需要在cookie中设置“HttpOnly”属性，这样通过程序（如JavaScript脚本、Applet等）就无法读取到cookie信息，避免了攻击者伪造cookie的情况出现。<br>在Java的Servlet的API中设置cookie为HttpOnly的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.cookies.set(<span class="string">&#x27;cookiename&#x27;</span>, <span class="string">&#x27;cookievalue&#x27;</span>, &#123; <span class="attr">httpOnly</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><p>3、增加token</p><p>CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于cookie中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。</p><p>由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信总不存在于cookie之中。鉴于此，系统开发人员可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务端进行token校验，如果请求中没有token或者token内容不正确，则认为是CSRF攻击而拒绝该请求。</p><p>假设请求通过POST方式提交，则可以在相应的表单中增加一个隐藏域：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_toicen&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tokenvalue&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>token的值通过服务端生成，表单提交后token的值通过POST请求与参数一同带到服务端，每次会话可以使用相同的token，会话过期，则token失效，攻击者因无法获取到token，也就无法伪造请求。</p><p>在session中添加token的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">Object token = session.getAttribute(<span class="string">&quot;_token&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(token == <span class="keyword">null</span> I I <span class="string">&quot;&quot;</span>.equals(token)) &#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;_token&quot;</span>, UUID.randomUUIDO .toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、通过Referer识别</p><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。</p><p>在通常情况下，访问一个安全受限的页面的请求都来自于同一个网站。比如某银行的转账是通过用户访问<a href="http://www.xxx.com/transfer.do%E9%A1%B5%E9%9D%A2%E5%AE%8C%E6%88%90%E7%9A%84%EF%BC%8C%E7%94%A8%E6%88%B7%E5%BF%85%E9%A1%BB%E5%85%88%E7%99%BB%E5%BD%95www.xxx.com%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%E5%8D%95%E5%87%BB%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%8F%90%E4%BA%A4%E6%8C%89%E9%92%AE%E6%9D%A5%E8%A7%A6%E5%8F%91%E8%BD%AC%E8%B4%A6%E4%BA%8B%E4%BB%B6%E3%80%82">http://www.xxx.com/transfer.do页面完成的，用户必须先登录www.xxx.com，然后通过单击页面上的提交按钮来触发转账事件。</a></p><p>当用户提交请求时，该转账请求的Referer值就会是提交按钮所在页面的URL（本例为<a href="http://www.xxx/">www.xxx</a>. com/transfer.do）。</p><p>如果攻击者要对银行网站实施CSRF攻击，他只能在其他网站构造请求，当用户通过其他网站发送请求到银行时，该请求的Referer的值是其他网站的地址，而不是银行转账页面的地址。</p><p>因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值即可，如果是以<a href="http://www.xx.om域名开头的地址,则说明该请求是来自银行网站自己的请求,是合法的;/">www.xx.om域名开头的地址，则说明该请求是来自银行网站自己的请求，是合法的；</a></p><p>如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。</p><p>取得HTTP请求Referer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.headers[<span class="string">&quot;Referer&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="sql注入-SQL-injection"><a href="#sql注入-SQL-injection" class="headerlink" title="sql注入(SQL injection)"></a><strong>sql注入(SQL injection)</strong></h2><p>定义: 在未授权情况下，非法访问数据库信息</p><p>如何防范:</p><blockquote><ul><li>杜绝用户提交的参数入库并且执行 </li><li>在代码层，不准出现sql语句 </li><li>在web输入参数处，对所有的参数做sql转义 </li><li>上线测试，需要使用sql自动注入工具进行所有的页面sql注入测试</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于常规的Web攻击手段，如XSS、CRSF、SQL注入、（常规的不包括文件上传漏洞、DDoS攻击）等&lt;/p&gt;
&lt;p&gt;比如XSS的防范需要转义掉输入的尖括号; 防止CRSF攻击需要将cookie设置为httponly，以及增加session相关的Hash token码; S</summary>
      
    
    
    
    <category term="浏览器特性" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="web安全" scheme="http://example.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>函数相关知识</title>
    <link href="http://example.com/2021/03/03/%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/03/03/%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</id>
    <published>2021-03-03T07:36:12.000Z</published>
    <updated>2021-04-25T03:06:39.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a><strong>箭头函数</strong></h2><blockquote><ul><li>如果形参只有一个，则小括号可以省略</li><li>函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果，所以 return也要去掉</li><li>箭头函数 this 指向声明时所在作用域下 this 的值，this是静态的</li><li>箭头函数不能作为构造函数实例化</li><li>不能使用 arguments</li></ul></blockquote><p>箭头函数不会更改 this 指向，用来指定回调函数会非常合适。<br>因为其this是静态的，指向声明时所在的作用域</p><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a><strong>函数柯里化</strong></h2><blockquote><p>是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通的add函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingAdd</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)           <span class="comment">// 3</span></span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>)   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>但是问题来了费这么大劲封装一层，到底有什么用处呢？</p><p>来列一列柯里化有哪些好处呢？</p><p>1.参数复用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常正则验证字符串 reg.test(txt)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数封装后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg, txt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;test&#x27;</span>)       <span class="comment">//false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>, <span class="string">&#x27;test&#x27;</span>)    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = curryingCheck(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line"></span><br><span class="line">hasNumber(<span class="string">&#x27;test1&#x27;</span>)      <span class="comment">// true</span></span><br><span class="line">hasNumber(<span class="string">&#x27;testtest&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">hasLetter(<span class="string">&#x27;21212&#x27;</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面的示例是一个正则的校验，正常来说直接调用check函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便。</p><p>2.提前确认</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> on = <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">        element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">        element.attachEvent(<span class="string">&#x27;on&#x27;</span> + event, handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> on = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">        element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">        element.attachEvent(<span class="string">&#x27;on&#x27;</span> + event, handler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//换一种写法可能比较好理解一点，上面就是把isSupport这个参数给先确定下来了</span></span><br><span class="line"><span class="keyword">var</span> on = <span class="function"><span class="keyword">function</span>(<span class="params">isSupport, element, event, handler</span>) </span>&#123;</span><br><span class="line">  isSupport = isSupport || <span class="built_in">document</span>.addEventListener;</span><br><span class="line">  <span class="keyword">if</span> (isSupport) &#123;</span><br><span class="line">    <span class="keyword">return</span> element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element.attachEvent(<span class="string">&#x27;on&#x27;</span> + event, handler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在做项目的过程中，封装一些dom操作可以说再常见不过，上面第一种写法也是比较常见，但是我们看看第二种写法，它相对一第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了会走哪一个方法，避免每次都进行判断。</p><p>3.延迟运行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像我们js中经常使用的bind，实现的机制就是Currying.</p><p>说了这几点好处之后，发现还有个问题，难道每次使用Currying都要对底层函数去做修改，</p><p>有没有什么通用的封装方法？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// args 获取第一个方法内的全部参数</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将后面方法里的全部参数和args进行合并</span></span><br><span class="line">    <span class="keyword">var</span> newArgs = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="comment">// 把合并后的参数通过apply作为fn的参数并执行</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, newArgs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边首先是初步封装,通过闭包把初步参数给保存下来，然后通过获取剩下的arguments进行拼接，最后执行需要currying的函数。</p><p>但是好像还有些什么缺陷，这样返回的话其实只能多扩展一个参数，currying(a)(b)(c)这样的话，貌似就不支持了（不支持多参数调用），一般这种情况都会想到使用递归再进行封装一层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">progressCurrying</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> length = fn.length;</span><br><span class="line">  <span class="keyword">let</span> args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">Array</span>.prototype.push.apply(args, _args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果参数个数小于最初的fn.length，则递归调用，继续收集参数</span></span><br><span class="line">    <span class="keyword">if</span> (_args.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> progressCurrying.call(_this, fn, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数收集完毕，则执行fn</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(_this, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边其实是在初步的基础上，加上了递归的调用，只要参数个数小于最初的fn.length，就会继续执行递归。</p><p>curry的一些性能问题你只要知道下面四点就差不多了：</p><blockquote><ul><li>存取arguments对象通常要比存取命名参数要慢一点</li><li>一些老版本的浏览器在arguments.length的实现上是相当慢的</li><li>使用fn.apply( … ) 和 fn.call( … )通常比直接调用fn( … ) 稍微慢点</li><li>创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上</li></ul></blockquote><p>其实在大部分应用中，主要的性能瓶颈是在操作DOM节点上，这js的性能损耗基本是可以忽略不计的，所以curry是可以直接放心的使用。</p><p>最后再扩展一道经典面试题</p><p>// 实现一个add方法，使计算结果能够满足如下预期：<br>add(1)(2)(3) = 6;<br>add(1, 2, 3)(4) = 10;<br>add(1)(2)(3)(4)(5) = 15;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></span><br><span class="line">  <span class="keyword">let</span> _args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></span><br><span class="line">  <span class="keyword">let</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _args.push(...arguments);</span><br><span class="line">    <span class="keyword">return</span> _adder;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">  _adder.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _adder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)                <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>)             <span class="comment">// 10</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)          <span class="comment">// 15</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">6</span>)(<span class="number">1</span>)                <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;箭头函数&quot;&gt;&lt;a href=&quot;#箭头函数&quot; class=&quot;headerlink&quot; title=&quot;箭头函数&quot;&gt;&lt;/a&gt;&lt;strong&gt;箭头函数&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果形参只有一个，则小括号可以省略&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="函数" scheme="http://example.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>浅谈小程序运行机制</title>
    <link href="http://example.com/2021/03/03/%E6%B5%85%E8%B0%88%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/03/03/%E6%B5%85%E8%B0%88%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2021-03-03T02:26:27.000Z</published>
    <updated>2021-04-25T03:06:39.870Z</updated>
    
    <content type="html"><![CDATA[<p>小程序与普通网页开发的区别</p><p>小程序的开发同普通的网页开发相比有很大的相似性，小程序的主要开发语言也是 JavaScript，但是二者还是有些差别的。</p><blockquote><ul><li>普通网页开发可以使用各种浏览器提供的 DOM API，进行 DOM 操作，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore<br>中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM<br>API。</li><li>普通网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。</li><li>网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。</li><li>小程序的执行环境</li></ul></blockquote><p><img src="/images/w1.png" alt="微信小程序"></p><p>小程序架构</p><h2 id="1-技术选型"><a href="#1-技术选型" class="headerlink" title="1.技术选型"></a><strong>1.技术选型</strong></h2><p>一般来说，渲染界面的技术有三种：</p><blockquote><ul><li>用纯客户端原生技术来渲染</li><li>用纯 Web 技术来渲染</li><li>用客户端原生技术与 Web 技术结合的混合技术（简称 Hybrid 技术）来渲染</li></ul></blockquote><p>通过以下几个方面分析，小程序采用哪种技术方案</p><blockquote><ul><li>开发门槛：Web 门槛低，Native 也有像 RN 这样的框架支持</li><li>体验：Native 体验比 Web 要好太多，Hybrid 在一定程度上比 Web 接近原生体验</li><li>版本更新：Web 支持在线更新，Native 则需要打包到微信一起审核发布</li><li>管控和安全：Web 可跳转或是改变页面内容，存在一些不可控因素和安全风险</li></ul></blockquote><p>由于小程序的宿主环境是微信，如果用纯客户端原生技术来编写小程序，那么小程序代码每次都需要与微信代码一起发版，这种方式肯定是不行的。</p><p>所以需要像web技术那样，有一份随时可更新的资源包放在云端，通过下载到本地，动态执行后即可渲染出界面。</p><p>如果用纯web技术来渲染小程序，在一些复杂的交互上可能会面临一些性能问题，这是因为在web技术中，UI渲染跟JavaScript的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。</p><p>所以最终采用了两者结合起来的Hybrid 技术来渲染小程序，可以用一种近似web的方式来开发，并且可以实现在线更新代码，同时引入组件也有以下好处：</p><blockquote><ul><li>扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力</li><li>体验更好，同时也减轻 WebView 的渲染工作</li><li>绕过 setData、数据通信和重渲染流程，使渲染性能更好</li><li>用客户端原生渲染内置一些复杂组件，可以提供更好的性能</li></ul></blockquote><h2 id="2-双线程模型"><a href="#2-双线程模型" class="headerlink" title="2.双线程模型"></a><strong>2.双线程模型</strong></h2><blockquote><p>小程序的渲染层和逻辑层分别由 2 个线程管理：视图层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS脚本。</p></blockquote><p><img src="/images/w2.png" alt="微信小程序"></p><p><img src="/images/w3.jpeg" alt="微信小程序"></p><p>那么为什么要这样设计呢，前面也提到了管控和安全，为了解决这些问题，我们需要阻止开发者使用一些，例如浏览器的window对象，跳转页面、操作DOM、动态执行脚本的开放性接口。</p><p>我们可以使用客户端系统的 JavaScript 引擎，iOS 下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境。</p><p>这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口。</p><p>这就是小程序双线程模型的由来：</p><blockquote><ul><li>逻辑层：创建一个单独的线程去执行 JavaScript，在这里执行的都是有关小程序业务逻辑的代码，负责逻辑处理、数据请求、接口调用等</li><li>视图层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以视图层存在多个 WebView 线程</li><li>JSBridge 起到架起上层开发与Native（系统层）的桥梁，使得小程序可通过API使用原生的功能，且部分组件为原生组件实现，从而有良好体验</li></ul></blockquote><h2 id="3-双线程通信"><a href="#3-双线程通信" class="headerlink" title="3.双线程通信"></a><strong>3.双线程通信</strong></h2><p>把开发者的 JS 逻辑代码放到单独的线程去运行，但在 Webview 线程里，开发者就没法直接操作 DOM。</p><p>那要怎么去实现动态更改界面呢？</p><p>如上图所示，逻辑层和试图层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。</p><p>这也就是说，我们可以把 DOM 的更新通过简单的数据通信来实现。</p><p>Virtual DOM 相信大家都已有了解，大概是这么个过程：用 JS 对象模拟 DOM 树 -&gt; 比较两棵虚拟 DOM 树的差异 -&gt; 把差异应用到真正的 DOM 树上。</p><p><img src="/images/w4.png" alt="微信小程序"></p><blockquote><ol><li>在渲染层把 WXML 转化成对应的 JS 对象。</li><li>在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。</li><li>经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。</li></ol></blockquote><p>我们通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。</p><p>而这样一个完整的框架，离不开小程序的基础库。</p><h2 id="4-小程序的基础库"><a href="#4-小程序的基础库" class="headerlink" title="4.小程序的基础库"></a><strong>4.小程序的基础库</strong></h2><p>小程序的基础库可以被注入到视图层和逻辑层运行，主要用于以下几个方面：</p><blockquote><ul><li>在视图层，提供各类组件来组建界面的元素</li><li>在逻辑层，提供各类 API 来处理各种逻辑</li><li>处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑</li></ul></blockquote><p>由于小程序的渲染层和逻辑层是两个线程管理，两个线程各自注入了基础库。</p><p>小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。</p><p>这样可以：</p><blockquote><ul><li>降低业务小程序的代码包大小</li><li>可以单独修复基础库中的 Bug，无需修改到业务小程序的代码包</li></ul></blockquote><h2 id="5-Exparser-框架"><a href="#5-Exparser-框架" class="headerlink" title="5.Exparser 框架"></a><strong>5.Exparser 框架</strong></h2><p>Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。</p><p>小程序内的所有组件，包括内置组件和自定义组件，都由Exparser组织管理。</p><p>Exparser的主要特点包括以下几点：</p><blockquote><ul><li>基于Shadow, DOM模型：模型上与WebComponents的ShadowDOM高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性&gt; + 地增加了其他API以支持小程序组件编程。</li><li>可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。</li><li>高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。</li></ul></blockquote><blockquote><p>小程序中，所有节点树相关的操作都依赖于Exparser，包括WXML到页面最终节点树的构建、createSelectorQuery调用和自定义组件特性等。</p></blockquote><p>内置组件</p><p>基于Exparser框架，小程序内置了一套组件，提供了视图容器类、表单类、导航类、媒体类、开放类等几十种组件。</p><p>有了这么丰富的组件，再配合WXSS，可以搭建出任何效果的界面。在功能层面上，也满足绝大部分需求。</p><h2 id="6-运行机制"><a href="#6-运行机制" class="headerlink" title="6.运行机制"></a><strong>6.运行机制</strong></h2><blockquote><p>小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。<br>假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台状态的小程序切换到前台，这个过程就是热启动；冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。</p></blockquote><blockquote><ul><li>小程序没有重启的概念</li><li>当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁</li><li>当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁</li></ul></blockquote><p><img src="/images/w5.png" alt="微信小程序"></p><h2 id="7-更新机制"><a href="#7-更新机制" class="headerlink" title="7.更新机制"></a><strong>7.更新机制</strong></h2><p>小程序冷启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。 </p><p>如果需要马上应用最新版本，可以使用 wx.getUpdateManager API 进行处理。</p><h2 id="8-性能优化"><a href="#8-性能优化" class="headerlink" title="8.性能优化"></a><strong>8.性能优化</strong></h2><p>主要的优化策略可以归纳为三点：</p><blockquote><ul><li>精简代码，降低WXML结构和JS代码的复杂性；</li><li>合理使用setData调用，减少setData次数和数据量；</li><li>必要时使用分包优化。</li></ul></blockquote><h3 id="1-setData-工作原理"><a href="#1-setData-工作原理" class="headerlink" title="1.setData 工作原理"></a><strong>1.setData 工作原理</strong></h3><p>小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。</p><p>在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。</p><p>当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。</p><p>而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。</p><h3 id="2-常见的-setData-操作错误"><a href="#2-常见的-setData-操作错误" class="headerlink" title="2.常见的 setData 操作错误"></a><strong>2.常见的 setData 操作错误</strong></h3><p>1.频繁的去 setData在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果：</p><p>Android下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；</p><p>渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；</p><p>2.每次 setData 都传递大量新数据由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript</p><p>3.脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程， 后台态页面进行<br>setData当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;小程序与普通网页开发的区别&lt;/p&gt;
&lt;p&gt;小程序的开发同普通的网页开发相比有很大的相似性，小程序的主要开发语言也是 JavaScript，但是二者还是有些差别的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;普通网页开发可以使用各种浏览器提供的 DOM API，进行</summary>
      
    
    
    
    <category term="微信小程序" scheme="http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>http各版本及https简要介绍</title>
    <link href="http://example.com/2021/03/01/http%E5%90%84%E7%89%88%E6%9C%AC%E5%8F%8Ahttps%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D-0/"/>
    <id>http://example.com/2021/03/01/http%E5%90%84%E7%89%88%E6%9C%AC%E5%8F%8Ahttps%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D-0/</id>
    <published>2021-03-01T09:53:40.000Z</published>
    <updated>2021-04-25T03:06:39.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP优化："><a href="#HTTP优化：" class="headerlink" title="HTTP优化："></a><strong>HTTP优化：</strong></h2><p>影响一个 HTTP 网络请求的因素主要有两个方面：带宽和延迟。</p><p>随着网络基础建设的完善，带宽因素已经不需要再考虑，仅需要考虑的就是延迟。延迟主要受三个方面影响：浏览器阻塞（HOL blocking）, DNS查询（DNS Lookup）,建立连接（Initial connection）.</p><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a><strong>HTTP1.1</strong></h2><blockquote><ul><li>支持长连接。</li><li>在HTTP1.0的基础上引入了更多的缓存控制策略。</li><li>引入了请求范围设置，优化了带宽。</li><li>在错误通知管理中新增了错误状态响应码。</li><li>增加了Host头处理，可以传递主机名（hostname）。</li></ul></blockquote><p>缺点: 传输内容是明文，不够安全</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a><strong>HTTPS</strong></h2><blockquote><ul><li>HTTPS运行在安全套接字协议(Secure Sockets Layer，SSL )或传输层安全协议（Transport Layer Security，TLS）之上，所有在TCP中传输的内容都需要经过加密。</li><li>连接方式不同，HTTP的端口是80，HTTPS的端口是443.</li><li>HTTPS可以有效防止运营商劫持。</li></ul></blockquote><p>注: SSL运行在TCP之上</p><h2 id="HTTP2-0（SPDY的升级版）"><a href="#HTTP2-0（SPDY的升级版）" class="headerlink" title="HTTP2.0（SPDY的升级版）"></a><strong>HTTP2.0（SPDY的升级版）</strong></h2><blockquote><ul><li>HTTP2.0支持明文传输，而HTTP 1.X强制使用SSL/TLS加密传输。</li><li>和HTTP 1.x使用的header压缩方法不同。</li><li>HTTP2.0 基于二进制格式进行解析，而HTTP 1.x基于文本格式进行解析。</li><li>多路复用，HTTP1.1是多个请求串行化单线程处理，HTTP 2.0是并行执行，一个请求超时并不会影响其他请求。</li></ul></blockquote><h3 id="HTTP2-0的多路复用提升了网页性能："><a href="#HTTP2-0的多路复用提升了网页性能：" class="headerlink" title="HTTP2.0的多路复用提升了网页性能："></a><strong>HTTP2.0的多路复用提升了网页性能：</strong></h3><blockquote><ul><li>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome下一般是六个），当在请求很多资源的时候，由于队头阻塞，当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。</li><li>HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。</li></ul></blockquote><p>注意: </p><blockquote><ul><li>主流浏览器只支持基于TLS部署的HTTP2.0协议，所以要将网站升级为HTTP 2.0，就需要先升级为HTTPS。</li><li>HTTP 2.0完全兼容HTTP 1.x,所以对于部署了HTTP 2.0的网站可以自动向下兼容HTTP 1.X.</li></ul></blockquote><h2 id="HTTP-3-0-QUIC"><a href="#HTTP-3-0-QUIC" class="headerlink" title="HTTP 3.0 (QUIC)"></a><strong>HTTP 3.0 (QUIC)</strong></h2><p>QUIC (Quick UDP Internet Connections), 快速 UDP 互联网连接。</p><p>QUIC是基于UDP协议的。</p><p>两个主要特性：</p><h3 id="1-线头阻塞-HOL-问题的解决更为彻底"><a href="#1-线头阻塞-HOL-问题的解决更为彻底" class="headerlink" title="1.线头阻塞(HOL)问题的解决更为彻底"></a><strong>1.线头阻塞(HOL)问题的解决更为彻底</strong></h3><blockquote><p>基于TCP的HTTP/2，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的流数据传输。而基于UDP的QUIC协议则可以更为彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。</p></blockquote><h3 id="2-切换网络时的连接保持"><a href="#2-切换网络时的连接保持" class="headerlink" title="2.切换网络时的连接保持"></a><strong>2.切换网络时的连接保持</strong></h3><blockquote><p>当前移动端的应用环境，用户的网络可能会经常切换，比如从办公室或家里出门，WiFi断开，网络切换为3G或4G。基于TCP的协议，由于切换网络之后，IP会改变，因而之前的连接不可能继续保持。而基于UDP的QUIC协议，则可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP优化：&quot;&gt;&lt;a href=&quot;#HTTP优化：&quot; class=&quot;headerlink&quot; title=&quot;HTTP优化：&quot;&gt;&lt;/a&gt;&lt;strong&gt;HTTP优化：&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;影响一个 HTTP 网络请求的因素主要有两个方面：带宽和延迟。&lt;/</summary>
      
    
    
    
    <category term="http" scheme="http://example.com/categories/http/"/>
    
    
    <category term="http协议" scheme="http://example.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>express和koa的区别</title>
    <link href="http://example.com/2021/02/26/express%E5%92%8Ckoa%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/02/26/express%E5%92%8Ckoa%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-02-26T07:10:07.000Z</published>
    <updated>2021-04-25T03:06:39.863Z</updated>
    
    <content type="html"><![CDATA[<p>虽然express.js有着精妙的中间件设计，但是以当前js标准来说，这种精妙的设计在现在可以说是太复杂。里面的层层回调和递归，不花一定的时间还真的很难读懂。</p><p>而koa2的代码呢？简直可以用四个字评论：精简彪悍！仅仅几个文件，用上最新的js标准，就很好实现了中间件，代码读起来一目了然。</p><h2 id="1-express用法和koa用法简单展示"><a href="#1-express用法和koa用法简单展示" class="headerlink" title="1.express用法和koa用法简单展示"></a><strong>1.express用法和koa用法简单展示</strong></h2><p>如果你使用express.js启动一个简单的服务器，那么基本写法应该是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am the first middleware&#x27;</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;first middleware end calling&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am the second middleware&#x27;</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;second middleware end calling&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/api/test1&#x27;</span>, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am the router middleware =&gt; /api/test1&#x27;</span>);</span><br><span class="line">  res.status(<span class="number">200</span>).send(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/&#x27;</span>, router);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;server listening at port 3000&#x27;</span>)</span><br></pre></td></tr></table></figure><p>换算成等价的koa2，那么用法是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa();</span><br><span class="line"><span class="keyword">const</span> router = Router();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am the first middleware&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;first middleware end calling&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am the second middleware&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;second middleware end calling&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/api/test1&#x27;</span>, <span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am the router middleware =&gt; /api/test1&#x27;</span>)</span><br><span class="line">  ctx.body = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;server listening at port 3000&#x27;</span>)</span><br></pre></td></tr></table></figure><p>二者的使用区别通过表格展示如下: </p><p><img src="/images/nnnkkk.png" alt="use"></p><p>上表展示了二者的使用区别，从初始化就看出koa语法都是用的新标准。在挂载路由中间件上也有一定的差异性，这是因为二者内部实现机制的不同。其他都是大同小异的了。</p><p>在理念上，Koa 旨在 “修复和替换节点”，而 Express 旨在 “增加节点”。 Koa 使用Promise(JavaScript一种异步手段)和异步功能来摆脱回调地狱的应用程序，并简化错误处理。 它暴露了自己的 ctx.request 和 ctx.response 对象，而不是 node 的 req 和 res 对象。</p><p>另一方面，Express 通过附加的属性和方法增加了 node 的 req 和 res 对象，并且包含许多其他 “框架” 功能，如路由和模板，而 Koa 则没有。</p><p>因此，Koa 可被视为 node.js 的 http 模块的抽象，其中 Express 是 node.js 的应用程序框架。</p><p>因此，如果您想要更接近 node.js 和传统的 node.js 样式编码，那么您可能希望坚持使用Connect/Express 或类似的框架。 如果你想摆脱回调，请使用 Koa。</p><p>由于这种不同的理念，其结果是传统的 node.js “中间件”（即“（req，res，next）”的函数）与Koa不兼容。 你的应用基本上要重新改写了。</p><p>Koa 与 Connect/Express 有哪些不同?</p><h3 id="基于-Promises-的控制流程"><a href="#基于-Promises-的控制流程" class="headerlink" title="基于 Promises 的控制流程"></a><strong>基于 Promises 的控制流程</strong></h3><p>没有回调地狱。</p><p>通过 try/catch 更好的处理错误。</p><p>无需域。</p><h3 id="Koa-非常精简"><a href="#Koa-非常精简" class="headerlink" title="Koa 非常精简"></a><strong>Koa 非常精简</strong></h3><p>不同于 Connect 和 Express, Koa 不含任何中间件.</p><p>不同于 Express, 不提供路由.</p><p>不同于 Express, 不提供许多便捷设施。 例如，发送文件.</p><p>Koa 更加模块化.</p><h3 id="Koa-对中间件的依赖较少"><a href="#Koa-对中间件的依赖较少" class="headerlink" title="Koa 对中间件的依赖较少"></a><strong>Koa 对中间件的依赖较少</strong></h3><p>例如, 不使用 “body parsing” 中间件，而是使用 body 解析函数。</p><h3 id="Koa-抽象-node-的-request-response"><a href="#Koa-抽象-node-的-request-response" class="headerlink" title="Koa 抽象 node 的 request/response"></a><strong>Koa 抽象 node 的 request/response</strong></h3><p>减少攻击。</p><p>更好的用户体验。</p><p>恰当的流处理。</p><h3 id="Koa-路由（第三方库支持）"><a href="#Koa-路由（第三方库支持）" class="headerlink" title="Koa 路由（第三方库支持）"></a><strong>Koa 路由（第三方库支持）</strong></h3><p>由于 Express 带有自己的路由，而 Koa 没有任何内置路由，但是有 koa-router 和 koa-route 第三方库可用。同样的, 就像我们在 Express 中有 helmet 保证安全, 对于 koa 我们有 koa-helmet 和一些列的第三方库可用</p><h2 id="2-koa2中间件"><a href="#2-koa2中间件" class="headerlink" title="2.koa2中间件"></a><strong>2.koa2中间件</strong></h2><p><img src="/images/k1.gif" alt="use"></p><p>看完这个gif图，也可以思考下如何实现的。根据表现，可以猜测是next是一个函数，而且返回的可能是一个promise，被await调用。</p><h3 id="2-1阅读koa-compose源码"><a href="#2-1阅读koa-compose源码" class="headerlink" title="2.1阅读koa-compose源码"></a><strong>2.1阅读koa-compose源码</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Middleware stack must be an array!&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Middleware must be composed of functions!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@api <span class="variable">public</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 取出第一个中间件函数执行</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;next() called multiple times&#x27;</span>));</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// next的值为undefined,当没有中间件的时候直接结束</span></span><br><span class="line">      <span class="comment">// 其实这里可以去掉next参数，直接在下面fn = void 0,和之前的代码效果一样</span></span><br><span class="line">      <span class="comment">// if (i === middleware.length) fn = void 0;</span></span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// fn为当前执行的中间件函数</span></span><br><span class="line">        <span class="comment">// 当前中间件函数执行时传入的next参数为下一个中间件</span></span><br><span class="line">        <span class="comment">// 当所有的中间件都执行完毕时, 当前中间件传入的next参数是请求处理的回调</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码等价于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样就可能更好理解了。</span></span><br><span class="line"><span class="comment">// simpleKoaCompose</span></span><br><span class="line"><span class="keyword">const</span> [fn1, fn2, fn3] = <span class="built_in">this</span>.middleware;</span><br><span class="line"><span class="keyword">const</span> fnMiddleware = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">      fn1(context, <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">          fn2(context, <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">                  fn3(context, <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">                  &#125;)</span><br><span class="line">              )</span><br><span class="line">          &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br></pre></td></tr></table></figure><p>也就是说koa-compose返回的是一个Promise，Promise中取出第一个函数（app.use添加的中间件），传入context和第一个next函数来执行。</p><p>第一个next函数里也是返回的是一个Promise，Promise中取出第二个函数（app.use添加的中间件），传入context和第二个next函数来执行。</p><p>第二个next函数里也是返回的是一个Promise，Promise中取出第三个函数（app.use添加的中间件），传入context和第三个next函数来执行。</p><p>第三个…</p><p>以此类推。最后一个中间件中有调用next函数，则返回Promise.resolve。如果没有，则不执行next函数。<br>这样就把所有中间件串联起来了。这也就是我们常说的洋葱模型。</p><h2 id="3-koa2-和-koa1-的简单对比"><a href="#3-koa2-和-koa1-的简单对比" class="headerlink" title="3.koa2 和 koa1 的简单对比"></a><strong>3.koa2 和 koa1 的简单对比</strong></h2><p>koa1中主要是generator函数。koa2中会自动转换generator函数。</p><p>app.use时有一层判断，是否是generator函数，如果是则用koa-convert暴露的方法convert来转换重新赋值，再存入middleware，后续再使用。</p><p>koa-convert源码挺多，核心代码其实是这样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> co.call(ctx, mw.call(ctx, createGenerator(next)))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> * <span class="title">createGenerator</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后还是通过co来转换的。所以接下来看co的源码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写一个请求简版请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">ms= <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">name</span>: <span class="string">&#x27;若川&#x27;</span>&#125;);</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取generator的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span> request();</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="string">&#x27;generatorFunc-res&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">generatorFunc(); <span class="comment">// 报告，我不会输出你想要的结果的</span></span><br></pre></td></tr></table></figure><p>简单来说co，就是把generator自动执行，再返回一个promise。<br>generator函数这玩意它不自动执行呀，还要一步步调用next()，也就是叫它走一步才走一步。</p><p>所以有了async、await函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// await 函数 自动执行</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> request();</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;asyncFunc-res await 函数 自动执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc(); <span class="comment">// 输出结果</span></span><br></pre></td></tr></table></figure><p>也就是说co需要做的事情，是让generator向async、await函数一样自动执行。</p><p>最终来看下co源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></span><br><span class="line">  <span class="comment">// which leads to memory leak errors.</span></span><br><span class="line">  <span class="comment">// see https://github.com/tj/co/issues/180</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把参数传递给gen函数并执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.apply(ctx, args);</span><br><span class="line">    <span class="comment">// 如果不是函数 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line"></span><br><span class="line">    onFulfilled();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Mixed&#125;</span> <span class="variable">res</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@api <span class="variable">private</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.next(res);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Error&#125;</span> <span class="variable">err</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@api <span class="variable">private</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.throw(err);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the next value in the generator,</span></span><br><span class="line"><span class="comment">     * return a promise.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">ret</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@api <span class="variable">private</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反复执行调用自己</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 检查当前是否为 Generator 函数的最后一步，如果是就返回</span></span><br><span class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">      <span class="comment">// 确保返回值是promise对象。</span></span><br><span class="line">      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br><span class="line">      <span class="comment">// 使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。</span></span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">      <span class="comment">// 在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。</span></span><br><span class="line">      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span></span><br><span class="line">        + <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span> + <span class="built_in">String</span>(ret.value) + <span class="string">&#x27;&quot;&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>koa-compose是将app.use添加到middleware数组中的中间件（函数），通过使用Promise串联起来，next()返回的是一个promise。</p></blockquote><blockquote><p>koa-convert 判断app.use传入的函数是否是generator函数，如果是则用koa-convert来转换，最终还是调用的co来转换。</p></blockquote><blockquote><p>co源码实现原理：其实就是通过不断的调用generator函数的next()函数，来达到自动执行generator函数的效果（类似async、await函数的自动自行）。</p></blockquote><blockquote><p>koa框架总结：主要就是四个核心概念，洋葱模型（把中间件串联起来），http请求上下文（context）、http请求对象、http响应对象。</p></blockquote><h3 id="koa洋葱模型怎么实现的。"><a href="#koa洋葱模型怎么实现的。" class="headerlink" title="koa洋葱模型怎么实现的。"></a><strong>koa洋葱模型怎么实现的。</strong></h3><blockquote><p>app.use() 把中间件函数存储在middleware数组中，最终会调用koa-compose导出的函数compose返回一个promise，中间函数的第一个参数ctx是包含响应和请求的一个对象，会不断传递给下一个中间件。next是一个函数，返回的是一个promise。</p></blockquote><h3 id="如果中间件中的next-方法报错了怎么办。"><a href="#如果中间件中的next-方法报错了怎么办。" class="headerlink" title="如果中间件中的next()方法报错了怎么办。"></a><strong>如果中间件中的next()方法报错了怎么办。</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ctx.onerror = <span class="function"><span class="keyword">function</span> </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.app.emit(<span class="string">&#x27;error&#x27;</span>, err, <span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">listen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span>  fnMiddleware = compose(<span class="built_in">this</span>.middleware);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.listenerCount(<span class="string">&#x27;error&#x27;</span>)) <span class="built_in">this</span>.on(<span class="string">&#x27;error&#x27;</span>, <span class="built_in">this</span>.onerror);</span><br><span class="line">  <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">  fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">onerror</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 代码省略</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>中间件链错误会由ctx.onerror捕获，该函数中会调用this.app.emit(‘error’, err, this)（因为koa继承自events模块，所以有’emit’和on等方法），可以使用app.on(‘error’, (err) =&gt; {})，或者app.onerror = (err) =&gt; {}进行捕获。</p></blockquote><h3 id="co的原理是怎样的。"><a href="#co的原理是怎样的。" class="headerlink" title="co的原理是怎样的。"></a><strong>co的原理是怎样的。</strong></h3><blockquote><p>co的原理是通过不断调用generator函数的next方法来达到自动执行generator函数的，类似async、await函数自动执行。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然express.js有着精妙的中间件设计，但是以当前js标准来说，这种精妙的设计在现在可以说是太复杂。里面的层层回调和递归，不花一定的时间还真的很难读懂。&lt;/p&gt;
&lt;p&gt;而koa2的代码呢？简直可以用四个字评论：精简彪悍！仅仅几个文件，用上最新的js标准，就很好实现了中</summary>
      
    
    
    
    <category term="node.js" scheme="http://example.com/categories/node-js/"/>
    
    
    <category term="express/koa" scheme="http://example.com/tags/express-koa/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://example.com/2021/02/24/%E9%97%AD%E5%8C%85/"/>
    <id>http://example.com/2021/02/24/%E9%97%AD%E5%8C%85/</id>
    <published>2021-02-24T07:13:15.000Z</published>
    <updated>2021-04-25T03:06:39.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h2><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包有两个常用的用途。</p><blockquote><ul><li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li></ul></blockquote><blockquote><ul><li>函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li></ul></blockquote><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a><strong>函数作为返回值</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = fn()</span><br><span class="line">f1(<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。</p><h3 id="函数作为参数被传递"><a href="#函数作为参数被传递" class="headerlink" title="函数作为参数被传递"></a><strong>函数作为参数被传递</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; max) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> max = <span class="number">100</span>;</span><br><span class="line">  f(<span class="number">15</span>)</span><br><span class="line">&#125;)(fn)</span><br></pre></td></tr></table></figure><p>如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。</p><p><b class="c42b983">自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。</b></p><p>另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。</p><p>当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。</p><p>但是有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。</p><p><img src="/images/bb1.png" alt="闭包"></p><p>第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。</p><p><img src="/images/bb2.png" alt="闭包"></p><p>第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。</p><p><img src="/images/bb3.png" alt="闭包"></p><p>第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。</p><p><b class="c42b983">注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。</b></p><p>而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。</p><p>因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。</p><p>——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：</p><p><img src="/images/bb4.png" alt="闭包"></p><p>第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。</p><p><img src="/images/bb5.png" alt="闭包"></p><p>执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。</p><p>这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。</p><p>使用闭包会增加内容开销，现在很明显了吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;&lt;strong&gt;闭包&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的</summary>
      
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="闭包" scheme="http://example.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Map结构</title>
    <link href="http://example.com/2021/02/23/Map%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2021/02/23/Map%E7%BB%93%E6%9E%84/</id>
    <published>2021-02-23T03:39:46.000Z</published>
    <updated>2021-04-25T03:06:39.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="map相关方法"><a href="#map相关方法" class="headerlink" title="map相关方法"></a><strong>map相关方法</strong></h2><p><b class="c42b983">map.set(key, val) </b></p><blockquote><p>1.如果对同一个键多次赋值，后面的值将覆盖前面的值。<br>2.注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。<br>3.Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。<br>4.如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。</p></blockquote><p><b class="c42b983">map.get(key)</b><br><b class="c42b983">map.size</b>, size属性返回 Map 结构的成员总数。<br><b class="c42b983">map.has(key)</b>, has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。<br><b class="c42b983">map.delete(key)</b>, delete方法删除某个键，返回true。如果删除失败，返回false。<br><b class="c42b983">map.clear()</b>, clear方法清除所有成员，没有返回值。</p><p>遍历方法</p><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><blockquote><p>Map.prototype.keys()：返回键名的遍历器。<br>Map.prototype.values()：返回键值的遍历器。<br>Map.prototype.entries()：返回所有成员的遍历器。<br>Map.prototype.forEach()：遍历 Map 的所有成员。</p></blockquote><h2 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a><strong>与其他数据结构的互相转换</strong></h2><h3 id="1-Map-转为数组"><a href="#1-Map-转为数组" class="headerlink" title="1.Map 转为数组"></a><strong>1.Map 转为数组</strong></h3><p>Map 转为数组最方便的方法，就是使用扩展运算符（…）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">.set(<span class="literal">true</span>, <span class="number">7</span>)</span><br><span class="line">.set(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">[...myMap]</span><br><span class="line"><span class="comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ]</span></span><br></pre></td></tr></table></figure><h3 id="2-数组-转为-Map"><a href="#2-数组-转为-Map" class="headerlink" title="2.数组 转为 Map"></a><strong>2.数组 转为 Map</strong></h3><p>将数组传入 Map 构造函数，就可以转为 Map。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-Map-转为对象"><a href="#3-Map-转为对象" class="headerlink" title="3.Map 转为对象"></a><strong>3.Map 转为对象</strong></h3><p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  .set(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure><p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p><h3 id="4-对象转为-Map"><a href="#4-对象转为-Map" class="headerlink" title="4.对象转为 Map"></a><strong>4.对象转为 Map</strong></h3><p>对象转为 Map 可以通过Object.entries()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外，也可以自己实现一个转换函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;<span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-Map-转为-JSON"><a href="#5-Map-转为-JSON" class="headerlink" title="5.Map 转为 JSON"></a><strong>5.Map 转为 JSON</strong></h3><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>).set(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToJson(myMap)</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJson</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="literal">true</span>, <span class="number">7</span>).set(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]);</span><br><span class="line">mapToArrayJson(myMap)</span><br><span class="line"><span class="comment">// &#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="6-JSON-转为-Map"><a href="#6-JSON-转为-Map" class="headerlink" title="6.JSON 转为 Map"></a><strong>6.JSON 转为 Map</strong></h3><p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> objToStrMap(<span class="built_in">JSON</span>.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(<span class="string">&#x27;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">// Map &#123;&#x27;yes&#x27; =&gt; true, &#x27;no&#x27; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">JSON</span>.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToMap(<span class="string">&#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span>)</span><br><span class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;map相关方法&quot;&gt;&lt;a href=&quot;#map相关方法&quot; class=&quot;headerlink&quot; title=&quot;map相关方法&quot;&gt;&lt;/a&gt;&lt;strong&gt;map相关方法&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;b class=&quot;c42b983&quot;&gt;map.set(key, v</summary>
      
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="map" scheme="http://example.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>vue双向数据绑定原理</title>
    <link href="http://example.com/2021/02/22/vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2021/02/22/vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</id>
    <published>2021-02-22T10:26:36.000Z</published>
    <updated>2021-04-25T03:06:39.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a><strong>思路整理</strong></h2><p>已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳这里 整理了一下，要实现mvvm的双向绑定，就必须要实现以下几点： 1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 4、mvvm入口函数，整合以上三者</p><p>上述流程如图所示：</p><p><img src="/images/vuejs.png" alt="双向数据绑定"></p><h2 id="实现Observer"><a href="#实现Observer" class="headerlink" title="实现Observer"></a><strong>实现Observer</strong></h2><p>我们知道可以利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.data = data;</span><br><span class="line">  <span class="built_in">this</span>.walk(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Observer</span>,</span><br><span class="line">  <span class="title">walk</span>: <span class="title">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> me = <span class="built_in">this</span>;</span><br><span class="line">      <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">          me.convert(key, data[key]);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  convert: <span class="function"><span class="keyword">function</span>(<span class="params">key, val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.defineReactive(<span class="built_in">this</span>.data, key, val);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  defineReactive: <span class="function"><span class="keyword">function</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">      <span class="keyword">var</span> childObj = observe(val);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">          enumerable: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">          configurable: <span class="literal">false</span>, <span class="comment">// 不能再define</span></span><br><span class="line">          get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                  dep.depend();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> val;</span><br><span class="line">          &#125;,</span><br><span class="line">          set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              val = newVal;</span><br><span class="line">              <span class="comment">// 新的值是object的话，进行监听</span></span><br><span class="line">              childObj = observe(newVal);</span><br><span class="line">              <span class="comment">// 通知订阅者</span></span><br><span class="line">              dep.notify();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.id = uid++;</span><br><span class="line">  <span class="built_in">this</span>.subs = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub: <span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  depend: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  removeSub: <span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> index = <span class="built_in">this</span>.subs.indexOf(sub);</span><br><span class="line">      <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.subs.splice(index, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  notify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">          sub.update();</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现Compile"><a href="#实现Compile" class="headerlink" title="实现Compile"></a><strong>实现Compile</strong></h2><p>compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示：</p><p><img src="/images/compile.png" alt="编译"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$vm = vm;</span><br><span class="line">  <span class="built_in">this</span>.$el = <span class="built_in">this</span>.isElementNode(el) ? el : <span class="built_in">document</span>.querySelector(el);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.$el) &#123;</span><br><span class="line">      <span class="built_in">this</span>.$fragment = <span class="built_in">this</span>.node2Fragment(<span class="built_in">this</span>.$el);</span><br><span class="line">      <span class="built_in">this</span>.init();</span><br><span class="line">      <span class="built_in">this</span>.$el.appendChild(<span class="built_in">this</span>.$fragment);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compile.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Compile</span>,</span><br><span class="line">  <span class="title">node2Fragment</span>: <span class="title">function</span>(<span class="params">el</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment(),</span><br><span class="line">          child;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将原生节点拷贝到fragment</span></span><br><span class="line">      <span class="keyword">while</span> (child = el.firstChild) &#123;</span><br><span class="line">          fragment.appendChild(child);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> fragment;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.compileElement(<span class="built_in">this</span>.$fragment);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  compileElement: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> childNodes = el.childNodes,</span><br><span class="line">          me = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">      [].slice.call(childNodes).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> text = node.textContent;</span><br><span class="line">          <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (me.isElementNode(node)) &#123;</span><br><span class="line">              me.compile(node);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</span><br><span class="line">              me.compileText(node, <span class="built_in">RegExp</span>.$1.trim());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">              me.compileElement(node);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  compile: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> nodeAttrs = node.attributes,</span><br><span class="line">          me = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">      [].slice.call(nodeAttrs).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> attrName = attr.name;</span><br><span class="line">          <span class="keyword">if</span> (me.isDirective(attrName)) &#123;</span><br><span class="line">              <span class="keyword">var</span> exp = attr.value;</span><br><span class="line">              <span class="keyword">var</span> dir = attrName.substring(<span class="number">2</span>);</span><br><span class="line">              <span class="comment">// 事件指令</span></span><br><span class="line">              <span class="keyword">if</span> (me.isEventDirective(dir)) &#123;</span><br><span class="line">                  compileUtil.eventHandler(node, me.$vm, exp, dir);</span><br><span class="line">                  <span class="comment">// 普通指令</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              node.removeAttribute(attrName);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  compileText: <span class="function"><span class="keyword">function</span>(<span class="params">node, exp</span>) </span>&#123;</span><br><span class="line">      compileUtil.text(node, <span class="built_in">this</span>.$vm, exp);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  isDirective: <span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> attr.indexOf(<span class="string">&#x27;v-&#x27;</span>) == <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  isEventDirective: <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dir.indexOf(<span class="string">&#x27;on&#x27;</span>) === <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  isElementNode: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> node.nodeType == <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  isTextNode: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> node.nodeType == <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令处理集合</span></span><br><span class="line"><span class="keyword">var</span> compileUtil = &#123;</span><br><span class="line">  text: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.bind(node, vm, exp, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  html: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.bind(node, vm, exp, <span class="string">&#x27;html&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  model: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.bind(node, vm, exp, <span class="string">&#x27;model&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> me = <span class="built_in">this</span>,</span><br><span class="line">          val = <span class="built_in">this</span>._getVMVal(vm, exp);</span><br><span class="line">      node.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> newValue = e.target.value;</span><br><span class="line">          <span class="keyword">if</span> (val === newValue) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          me._setVMVal(vm, exp, newValue);</span><br><span class="line">          val = newValue;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  class: function(node, vm, exp) &#123;</span><br><span class="line">      <span class="built_in">this</span>.bind(node, vm, exp, <span class="string">&#x27;class&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp, dir</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> updaterFn = updater[dir + <span class="string">&#x27;Updater&#x27;</span>];</span><br><span class="line"></span><br><span class="line">      updaterFn &amp;&amp; updaterFn(node, <span class="built_in">this</span>._getVMVal(vm, exp));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">value, oldValue</span>) </span>&#123;</span><br><span class="line">          updaterFn &amp;&amp; updaterFn(node, value, oldValue);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件处理</span></span><br><span class="line">  eventHandler: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp, dir</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> eventType = dir.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>],</span><br><span class="line">          fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (eventType &amp;&amp; fn) &#123;</span><br><span class="line">          node.addEventListener(eventType, fn.bind(vm), <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  _getVMVal: <span class="function"><span class="keyword">function</span>(<span class="params">vm, exp</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> val = vm;</span><br><span class="line">      exp = exp.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">      exp.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">          val = val[k];</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  _setVMVal: <span class="function"><span class="keyword">function</span>(<span class="params">vm, exp, value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> val = vm;</span><br><span class="line">      exp = exp.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">      exp.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">k, i</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 非最后一个key，更新val的值</span></span><br><span class="line">          <span class="keyword">if</span> (i &lt; exp.length - <span class="number">1</span>) &#123;</span><br><span class="line">              val = val[k];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              val[k] = value;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> updater = &#123;</span><br><span class="line">  textUpdater: <span class="function"><span class="keyword">function</span>(<span class="params">node, value</span>) </span>&#123;</span><br><span class="line">      node.textContent = <span class="keyword">typeof</span> value == <span class="string">&#x27;undefined&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : value;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  htmlUpdater: <span class="function"><span class="keyword">function</span>(<span class="params">node, value</span>) </span>&#123;</span><br><span class="line">      node.innerHTML = <span class="keyword">typeof</span> value == <span class="string">&#x27;undefined&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : value;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  classUpdater: <span class="function"><span class="keyword">function</span>(<span class="params">node, value, oldValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> className = node.className;</span><br><span class="line">      className = className.replace(oldValue, <span class="string">&#x27;&#x27;</span>).replace(<span class="regexp">/\s$/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> space = className &amp;&amp; <span class="built_in">String</span>(value) ? <span class="string">&#x27; &#x27;</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      node.className = className + space + value;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  modelUpdater: <span class="function"><span class="keyword">function</span>(<span class="params">node, value, oldValue</span>) </span>&#123;</span><br><span class="line">      node.value = <span class="keyword">typeof</span> value == <span class="string">&#x27;undefined&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现Watcher"><a href="#实现Watcher" class="headerlink" title="实现Watcher"></a><strong>实现Watcher</strong></h2><p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, expOrFn, cb</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.cb = cb;</span><br><span class="line">  <span class="built_in">this</span>.vm = vm;</span><br><span class="line">  <span class="built_in">this</span>.expOrFn = expOrFn;</span><br><span class="line">  <span class="built_in">this</span>.depIds = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = <span class="built_in">this</span>.parseGetter(expOrFn.trim());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;qqqq&#x27;</span>, <span class="keyword">typeof</span> <span class="built_in">this</span>.getter, expOrFn);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Watcher</span>,</span><br><span class="line">  <span class="title">update</span>: <span class="title">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.run();</span><br><span class="line">  &#125;,</span><br><span class="line">  run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> value = <span class="built_in">this</span>.get();</span><br><span class="line">      <span class="keyword">var</span> oldVal = <span class="built_in">this</span>.value;</span><br><span class="line">      <span class="keyword">if</span> (value !== oldVal) &#123;</span><br><span class="line">          <span class="built_in">this</span>.value = value;</span><br><span class="line">          <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldVal);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  addDep: <span class="function"><span class="keyword">function</span>(<span class="params">dep</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 1. 每次调用run()的时候会触发相应属性的getter</span></span><br><span class="line">      <span class="comment">// getter里面会触发dep.depend()，继而触发这里的addDep</span></span><br><span class="line">      <span class="comment">// 2. 假如相应属性的dep.id已经在当前watcher的depIds里，说明不是一个新的属性，仅仅是改变了其值而已</span></span><br><span class="line">      <span class="comment">// 则不需要将当前watcher添加到该属性的dep里</span></span><br><span class="line">      <span class="comment">// 3. 假如相应属性是新的属性，则将当前watcher添加到新属性的dep里</span></span><br><span class="line">      <span class="comment">// 如通过 vm.child = &#123;name: &#x27;a&#x27;&#125; 改变了 child.name 的值，child.name 就是个新属性</span></span><br><span class="line">      <span class="comment">// 则需要将当前watcher(child.name)加入到新的 child.name 的dep里</span></span><br><span class="line">      <span class="comment">// 因为此时 child.name 是个新值，之前的 setter、dep 都已经失效，如果不把 watcher 加入到新的 child.name 的dep中</span></span><br><span class="line">      <span class="comment">// 通过 child.name = xxx 赋值的时候，对应的 watcher 就收不到通知，等于失效了</span></span><br><span class="line">      <span class="comment">// 4. 每个子属性的watcher在添加到子属性的dep的同时，也会添加到父属性的dep</span></span><br><span class="line">      <span class="comment">// 监听子属性的同时监听父属性的变更，这样，父属性改变时，子属性的watcher也能收到通知进行update</span></span><br><span class="line">      <span class="comment">// 这一步是在 this.get() --&gt; this.getVMVal() 里面完成，forEach时会从父级开始取值，间接调用了它的getter</span></span><br><span class="line">      <span class="comment">// 触发了addDep(), 在整个forEach过程，当前wacher都会加入到每个父级过程属性的dep</span></span><br><span class="line">      <span class="comment">// 例如：当前watcher的是&#x27;child.child.name&#x27;, 那么child, child.child, child.child.name这三个属性的dep都会加入当前watcher</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.depIds.hasOwnProperty(dep.id)) &#123;</span><br><span class="line">          dep.addSub(<span class="built_in">this</span>);</span><br><span class="line">          <span class="built_in">this</span>.depIds[dep.id] = dep;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      Dep.target = <span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">var</span> value = <span class="built_in">this</span>.getter.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.vm);</span><br><span class="line">      Dep.target = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  parseGetter: <span class="function"><span class="keyword">function</span>(<span class="params">exp</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/[^\w.$]/</span>.test(exp)) <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> exps = exp.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;vvv&#x27;</span>, <span class="built_in">this</span>.vm);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = exps.length; i &lt; len; i++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">              obj = obj[exps[i]];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;ooo&#x27;</span>, obj);</span><br><span class="line">          <span class="keyword">return</span> obj;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。</p><h2 id="实现MVVM"><a href="#实现MVVM" class="headerlink" title="实现MVVM"></a><strong>实现MVVM</strong></h2><p>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p><p>但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM({data:{name: ‘kindeng’}}); vm._data.name = ‘dmq’; 这样的方式来改变数据。</p><p>显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的： var vm = new MVVM({data: {name: ‘kindeng’}}); vm.name = ‘dmq’;</p><p>所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MVVM</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$options = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="built_in">this</span>._data = <span class="built_in">this</span>.$options.data;</span><br><span class="line">  <span class="keyword">var</span> me = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据代理</span></span><br><span class="line">  <span class="comment">// 实现 vm.xxx -&gt; vm._data.xxx</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">      me._proxyData(key);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>._initComputed();</span><br><span class="line"></span><br><span class="line">  observe(data, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.$compile = <span class="keyword">new</span> Compile(options.el || <span class="built_in">document</span>.body, <span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MVVM.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">MVVM</span>,</span><br><span class="line">  <span class="title">$watch</span>: <span class="title">function</span>(<span class="params">key, cb, options</span>) &#123;</span><br><span class="line">      <span class="keyword">new</span> Watcher(<span class="built_in">this</span>, key, cb);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  _proxyData: <span class="function"><span class="keyword">function</span>(<span class="params">key, setter, getter</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> me = <span class="built_in">this</span>;</span><br><span class="line">      setter = setter || </span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(me, key, &#123;</span><br><span class="line">          configurable: <span class="literal">false</span>,</span><br><span class="line">          enumerable: <span class="literal">true</span>,</span><br><span class="line">          get: <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> me._data[key];</span><br><span class="line">          &#125;,</span><br><span class="line">          set: <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">              me._data[key] = newVal;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  _initComputed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> me = <span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">var</span> computed = <span class="built_in">this</span>.$options.computed;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> computed === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">Object</span>.keys(computed).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">              <span class="built_in">Object</span>.defineProperty(me, key, &#123;</span><br><span class="line">                  get: <span class="keyword">typeof</span> computed[key] === <span class="string">&#x27;function&#x27;</span> </span><br><span class="line">                          ? computed[key] </span><br><span class="line">                          : computed[key].get,</span><br><span class="line">                  set: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实例化代码"><a href="#实例化代码" class="headerlink" title="实例化代码"></a><strong>实例化代码</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> MVVM(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#mvvm-app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    someStr: <span class="string">&#x27;hello &#x27;</span>,</span><br><span class="line">    className: <span class="string">&#x27;btn&#x27;</span>,</span><br><span class="line">    htmlStr: <span class="string">&#x27;&lt;span style=&quot;color: #f00;&quot;&gt;red&lt;/span&gt;&#x27;</span>,</span><br><span class="line">    child: &#123;</span><br><span class="line">        someStr: <span class="string">&#x27;World !&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    getHelloWord: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.someStr + <span class="built_in">this</span>.child.someStr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    clickBtn: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> randomStrArr = [<span class="string">&#x27;childOne&#x27;</span>, <span class="string">&#x27;childTwo&#x27;</span>, <span class="string">&#x27;childThree&#x27;</span>];</span><br><span class="line">      <span class="built_in">this</span>.child.someStr = randomStrArr[<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">vm.$watch(<span class="string">&#x27;child.someStr&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;思路整理&quot;&gt;&lt;a href=&quot;#思路整理&quot; class=&quot;headerlink&quot; title=&quot;思路整理&quot;&gt;&lt;/a&gt;&lt;strong&gt;思路整理&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.</summary>
      
    
    
    
    <category term="vue.js" scheme="http://example.com/categories/vue-js/"/>
    
    
    <category term="vue.js" scheme="http://example.com/tags/vue-js/"/>
    
  </entry>
  
  <entry>
    <title>函数防抖与函数节流</title>
    <link href="http://example.com/2021/02/22/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"/>
    <id>http://example.com/2021/02/22/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</id>
    <published>2021-02-22T02:05:18.000Z</published>
    <updated>2021-04-25T03:06:39.868Z</updated>
    
    <content type="html"><![CDATA[<p>debounce-函数防抖：将一个弹簧按下，继续加压，继续按下，只会在最后放手的一瞬反弹。即我们希望函数只会调用一次，即使在这之前反复调用它，最终也只会调用一次而已。</p><p>throttle-函数节流：一个水龙头在滴水，可能一次性会滴很多滴，但是我们只希望它每隔 500ms 滴一滴水，保持这个频率。即我们希望函数在以一个可以接受的频率重复调用。</p><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a><strong>函数防抖</strong></h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a><strong>基本思想</strong></h3><blockquote><p>某些代码不可以在没有间断的情况下连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作(清除定时器)就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。</p></blockquote><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a><strong>基本实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a><strong>函数节流</strong></h2><p>throttle-函数节流：一个水龙头在滴水，可能一次性会滴很多滴，但是我们只希望它每隔 500ms 滴一滴水，保持这个频率。即我们希望函数在以一个可以接受的频率重复调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>; <span class="comment">// 用于记录上一次执行的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">let</span> remain = wait - (now - previous);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remain &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      previous = now;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件第一次触发的时候我要执行该函数，事件停止后，也要再触发一次函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>; <span class="comment">// 用于记录上一次执行的时间</span></span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">let</span> remain = wait - (now - previous);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remain &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (previous === <span class="number">0</span> &amp;&amp; !options.begin) &#123;</span><br><span class="line">        previous = now;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      previous = now;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.end) &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了强大的节流函数了， 第一次来的时候，可以执行一次回调函数，结束的时候也会执行一次回调函数。并且可以通过options来配置。</p><p>如果设置了options.begin === true就第一触发事件就立刻会执行回调函数。因为我们设置previous的的初始值为0，所以如果previous === 0就表示是第一次触发该事件，与上options.begin就可以得出第一次是否执行该回调函数。</p><p>如果设置了options.end === true事件停止触发后也会执行一次该回调函数。其实在事件触发的整个时间内，定时器中的回调函数从来都没有被执行过，只有在事件停止出发后，定时器内的回调函数才被执行。只要设置了options.end就相当于只是用计算时间的方式来实现节流。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;debounce-函数防抖：将一个弹簧按下，继续加压，继续按下，只会在最后放手的一瞬反弹。即我们希望函数只会调用一次，即使在这之前反复调用它，最终也只会调用一次而已。&lt;/p&gt;
&lt;p&gt;throttle-函数节流：一个水龙头在滴水，可能一次性会滴很多滴，但是我们只希望它每隔 5</summary>
      
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="工具函数" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>三次握手与四次挥手理解</title>
    <link href="http://example.com/2021/02/20/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/02/20/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%90%86%E8%A7%A3/</id>
    <published>2021-02-20T10:13:48.000Z</published>
    <updated>2021-04-25T03:06:39.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-三次握手过程理解"><a href="#1-三次握手过程理解" class="headerlink" title="1.三次握手过程理解"></a><strong>1.三次握手过程理解</strong></h2><p><img src="/images/sanciwoshou.png" alt="三次握手"></p><blockquote><ul><li>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li></ul></blockquote><blockquote><ul><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li></ul></blockquote><blockquote><ul><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ul></blockquote><h2 id="2-四次挥手过程理解"><a href="#2-四次挥手过程理解" class="headerlink" title="2.四次挥手过程理解"></a><strong>2.四次挥手过程理解</strong></h2><p><img src="/images/sicihuishou.png" alt="四次挥手"></p><blockquote><ul><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li></ul></blockquote><blockquote><ul><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li></ul></blockquote><blockquote><ul><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li></ul></blockquote><blockquote><ul><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li></ul></blockquote><blockquote><ul><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li></ul></blockquote><blockquote><ul><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ul></blockquote><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h2><h3 id="1-为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#1-为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="1.为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a><strong>1.为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></h3><blockquote><p>因为当Server端收到Client端的SYN连接请求报文后，<b class="c42b983">可以直接发送SYN+ACK报文</b>。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，<b class="c42b983">很可能并不会立即关闭SOCKET</b>，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到Server端所有的报文都发送完了，才能发送FIN报文，因此不能一起发送。故需要四步握手。</p></blockquote><h3 id="2-为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#2-为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="__2.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？__"></a>__2.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？__</h3><blockquote><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p></blockquote><h3 id="3-为什么不能用两次握手进行连接？"><a href="#3-为什么不能用两次握手进行连接？" class="headerlink" title="3.为什么不能用两次握手进行连接？"></a><strong>3.为什么不能用两次握手进行连接？</strong></h3><blockquote><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机Server和Client之间的通信，假定Client给Server发送一个连接请求分组，Server收到了这个分组，并发送了确认应答分组。按照两次握手的协定，Server认为连接已经成功地建立了，可以开始发送数据分组。可是，Client在<b class="c42b983">Server的应答分组在传输中被丢失</b>的情况下，将不知道Server是否已准备好，不知道Server建立什么样的序列号，Client甚至怀疑Server是否收到自己的连接请求分组。在这种情况下，Client认为连接还未建立成功，将忽略Server发来的任何数据分组，只等待连接确认应答分组。而Server在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p></blockquote><h3 id="4-如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#4-如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="4.如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a><strong>4.如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></h3><blockquote><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-三次握手过程理解&quot;&gt;&lt;a href=&quot;#1-三次握手过程理解&quot; class=&quot;headerlink&quot; title=&quot;1.三次握手过程理解&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.三次握手过程理解&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/san</summary>
      
    
    
    
    <category term="http" scheme="http://example.com/categories/http/"/>
    
    
    <category term="http协议" scheme="http://example.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>前端经典算法题</title>
    <link href="http://example.com/2021/02/19/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://example.com/2021/02/19/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98/</id>
    <published>2021-02-19T08:02:26.000Z</published>
    <updated>2021-04-25T03:06:39.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-判断一个字符串是否回文"><a href="#1-判断一个字符串是否回文" class="headerlink" title="1.判断一个字符串是否回文"></a><strong>1.判断一个字符串是否回文</strong></h2><p>回文是指类似于“上海自来水来自海上”或者“madam”，从前往后和从后往前读，字符串的内容是一样的，称为回文。判断一个字符串是否是回文有很多种思路：</p><blockquote><p>1.创建一个与原字符串前后倒过来的新字符串，比较二者是否相等，如果相等则是回文</p></blockquote><h3 id="1-1-利用中介Array-reverse-的反转数组的特性"><a href="#1-1-利用中介Array-reverse-的反转数组的特性" class="headerlink" title="1.1 利用中介Array.reverse()的反转数组的特性"></a><strong>1.1 利用中介Array.reverse()的反转数组的特性</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindRome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>) === str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isPalindRome(<span class="string">&#x27;madam&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(isPalindRome(<span class="string">&#x27;mada&#x27;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="1-2-不利用任何方法，手动创建新字符串"><a href="#1-2-不利用任何方法，手动创建新字符串" class="headerlink" title="1.2 不利用任何方法，手动创建新字符串"></a><strong>1.2 不利用任何方法，手动创建新字符串</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindRome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = str.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">    newStr = newStr + str[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newStr === str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.从字符串的头和尾开始，依次比较字符串组是否相等，逐渐往中间收，如果全部相等，则是回文</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindRome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = str.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">Math</span>.floor(str.length / <span class="number">2</span>); i ++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(str[i] !== str[length - <span class="number">1</span> - i])&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-数组去重"><a href="#2-数组去重" class="headerlink" title="2.数组去重"></a><strong>2.数组去重</strong></h2><blockquote><p>2.1 利用ES6新增的Set，因为Set的元素是非重复的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deduplicate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return Array.from(new Set(arr))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.2 创建一个新数组，只包含源数组非重复的元素</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deduplicate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newArray = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newArray.indexOf(i) === -<span class="number">1</span>) &#123;</span><br><span class="line">      newArray.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-统计字符串中出现最多次数的字符及其次数"><a href="#3-统计字符串中出现最多次数的字符及其次数" class="headerlink" title="3: 统计字符串中出现最多次数的字符及其次数"></a><strong>3: 统计字符串中出现最多次数的字符及其次数</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxCount</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> resultMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> letter <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (resultMap.has(letter)) &#123;</span><br><span class="line">      resultMap.set(letter, resultMap.get(letter) + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resultMap.set(letter, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> maxCount = <span class="built_in">Math</span>.max(...resultMap.values())</span><br><span class="line">  <span class="keyword">let</span> maxCountLetters = []; <span class="comment">//可能几个字符同时都是出现次数最多的，所以用一个Array去装这些字符</span></span><br><span class="line">  resultMap.forEach(<span class="function">(<span class="params">value, key, mapSelf</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value === maxCount) &#123;</span><br><span class="line">      maxCountLetters.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;maxCountLetters, maxCount&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-滑动窗口算法"><a href="#4-滑动窗口算法" class="headerlink" title="4.滑动窗口算法"></a><strong>4.滑动窗口算法</strong></h2><h3 id="什么是滑动窗口？"><a href="#什么是滑动窗口？" class="headerlink" title="什么是滑动窗口？"></a><strong>什么是滑动窗口？</strong></h3><p>滑动窗口算法是在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这就降低了问题的复杂度，从而也降低了循环的嵌套深度。滑动窗口主要应用在数组和字符串的场景。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a><strong>简单示例</strong></h3><p>先通过一个简单的示例来看一下滑动窗口的运作，比如有一个数组[1,3,5,6,2,2]，设定滑动窗口（window）大小为3，那么当窗口从数组开始位置滑动到最终位置时依次计算每个窗口内3个元素的和，表示为sum。</p><p><img src="/images/huadongkuangkou.png" alt="滑动窗口"></p><p>上图我们可以看出，随着窗口在数组上向右移动，窗口内的数据也在不断变化，我们只用对窗口内连续区间内的数据进行处理即可。由于区间是连续的，因此当窗口移动时只用对旧窗口的数据进行裁剪处理，这样便减少了重复计算，降低了时间复杂度。</p><p>以上图为例，当窗口位于[1,3,5]时，处理完该窗口的数据之后，将窗口向右移动一格，等于是将原有窗口左边的1裁剪掉，然后将窗口右边的6添加上，而整个过程看起来就像窗口在向右移动一样。</p><p>对于类似“请找到满足 xx 的最 x 的区间（子串、子数组）的 xx ”这类问题都可以使用该方法进行解决。</p><h3 id="滑动窗口的基本步骤"><a href="#滑动窗口的基本步骤" class="headerlink" title="滑动窗口的基本步骤"></a><strong>滑动窗口的基本步骤</strong></h3><p>需要注意的是：窗口的移动是按照移动的顺序来进行的；窗口的大小不一定是固定的，可以不断缩小或变大的。</p><p>对于滑动窗口算法的基本解题思路，以字符串S示例如下：</p><p>（1）采用双指针来指定窗口的范围，初始化left=right=0，而索引闭区间[left,right]便是一个窗口。<br>（2）不断增大窗口的right指针，直到窗口中的字符串满足条件。<br>（3）此时，停止right的增加，转而不断增加left指针，用于缩小窗口[left,right]，直到窗口中的字符串不再符合要求。每增加一次left，需要更新一轮结果。<br>（4）重复第2和第3步，直到right到达字符串的尽头。<br>其中，第2步相当于在寻找一个「可行解」，然后第3步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h3><p>题目: 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例:</p><blockquote><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calLength</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> l = str.length;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i !== <span class="number">0</span>) &#123;</span><br><span class="line">      map.delete(str.charAt(i - <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt; l &amp;&amp; !map.has(str.charAt(right))) &#123;</span><br><span class="line">      map.set(str.charAt(right), str.charAt(right))</span><br><span class="line">      right++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max = <span class="built_in">Math</span>.max(max, map.size)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历二叉树所有节点"><a href="#遍历二叉树所有节点" class="headerlink" title="遍历二叉树所有节点"></a><strong>遍历二叉树所有节点</strong></h2><h3 id="1-构造节点"><a href="#1-构造节点" class="headerlink" title="1.构造节点"></a><strong>1.构造节点</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.value = value</span><br><span class="line">  <span class="built_in">this</span>.left = left</span><br><span class="line">  <span class="built_in">this</span>.right = right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-构造二叉树"><a href="#2-构造二叉树" class="headerlink" title="2.构造二叉树"></a><strong>2.构造二叉树</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> root = <span class="keyword">new</span> Node(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">  root.left = <span class="keyword">new</span> Node(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">  root.left.left = <span class="keyword">new</span> Node(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">  root.left.right = <span class="keyword">new</span> Node(<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">  root.left.left.left = <span class="keyword">new</span> Node(<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">  root.right = <span class="keyword">new</span> Node(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">  root.right.left = <span class="keyword">new</span> Node(<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">  root.right.right = <span class="keyword">new</span> Node(<span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">  root.right.right.right = <span class="keyword">new</span> Node(<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-遍历二叉树"><a href="#3-遍历二叉树" class="headerlink" title="3.遍历二叉树"></a><strong>3.遍历二叉树</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllNode</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodeList = []</span><br><span class="line"></span><br><span class="line">  nodeList.push(node.value)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">    nodeList.push(...getAllNode(node.left))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">    nodeList.push(...getAllNode(node.right))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nodeList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-判断一个字符串是否回文&quot;&gt;&lt;a href=&quot;#1-判断一个字符串是否回文&quot; class=&quot;headerlink&quot; title=&quot;1.判断一个字符串是否回文&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.判断一个字符串是否回文&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;回文是指类似于“上</summary>
      
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
