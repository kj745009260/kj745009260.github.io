<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> javascript中的call和apply和bind · 前端Store</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="javascript中的call和apply和bind - J.K"><meta name="keywords"><meta name="author" content="J.K"><link rel="short icon" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/favicon.ico"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="前端Store"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="前端Store" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/live/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/categories/read/" target="_self" data-hover="读书" class="nav-list-link">读书</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">javascript中的call和apply和bind</h1><div class="post-info">2021-03-12<p class="visit"><i data-identity="2021/03/12/javascript中的call和apply和bind/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><h2 id="call-apply-bind的基本介绍"><a href="#call-apply-bind的基本介绍" class="headerlink" title="call,apply,bind的基本介绍"></a><strong>call,apply,bind的基本介绍</strong></h2><p>语法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, param1, param2, ...)</span><br><span class="line">fun.apply(thisArg, [param1,param2,...])</span><br><span class="line">fun.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></table></figure>

<p>返回值:</p>
<blockquote>
<p>call/apply：fun执行的结果<br>bind：返回fun的拷贝，并拥有指定的this值和初始参数</p>
</blockquote>
<p>参数: thisArg(可选)</p>
<blockquote>
<ul>
<li>fun的this指向thisArg对象</li>
<li>非严格模式下：thisArg指定为null，undefined，fun中的this指向window对象.</li>
<li>严格模式下：fun的this为undefined</li>
<li>值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象，如 String、Number、Boolean</li>
</ul>
</blockquote>
<p>param1,param2(可选): 传给fun的参数。</p>
<blockquote>
<ul>
<li>如果param不传或为 null/undefined，则表示不需要传入任何参数.</li>
<li>apply第二个参数为数组，数组内的值为传给fun的参数。</li>
</ul>
</blockquote>
<p>调用call/apply/bind的必须是个函数</p>
<p>call、apply和bind是挂在Function对象上的三个方法,只有函数才有这些方法。</p>
<p>只要是函数就可以，比如: Object.prototype.toString就是个函数，我们经常看到这样的用法：Object.prototype.toString.call(data)</p>
<p>区别：</p>
<p>call与apply的唯一区别</p>
<p>传给fun的参数写法不同：</p>
<p>apply是第2个参数，这个参数是一个数组：传给fun参数都写在数组中。</p>
<p>call从第2~n的参数都是传给fun的。</p>
<p>call/apply与bind的区别</p>
<p>执行：</p>
<p>call/apply改变了函数的this上下文后马上执行该函数</p>
<p>bind则是返回改变了上下文后的函数,不执行该函数</p>
<p>返回值:</p>
<p>call/apply 返回fun的执行结果</p>
<p>bind返回fun的拷贝，并指定了fun的this指向，保存了fun的参数。</p>
<p><span class="c42b983">bind</span> 是返回对应函数，便于稍后调用；<span class="c42b983">apply 、call</span> 则是立即调用 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)</span></span><br><span class="line">  <span class="comment">// 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象</span></span><br><span class="line">  context = (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) ? <span class="built_in">window</span> : <span class="built_in">Object</span>(context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于临时储存函数</span></span><br><span class="line">  <span class="keyword">const</span> specialPrototype = <span class="built_in">Symbol</span>(<span class="string">&#x27;唯一性&#x27;</span>);</span><br><span class="line">  <span class="comment">// 函数的this指向隐式绑定到context上</span></span><br><span class="line">  context[specialPrototype] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 通过隐式绑定执行函数并传递参数</span></span><br><span class="line">  <span class="keyword">let</span> res = context[specialPrototype](...args);</span><br><span class="line">  <span class="comment">// 删除上下文对象的属性</span></span><br><span class="line">  <span class="keyword">delete</span> context[specialPrototype];</span><br><span class="line">  <span class="comment">// 返回函数执行结果</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) ? <span class="built_in">window</span> : <span class="built_in">Object</span>(context)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp;  <span class="comment">// o不是null、undefined等</span></span><br><span class="line">        <span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> &amp;&amp;  <span class="comment">// o是对象</span></span><br><span class="line">        <span class="built_in">isFinite</span>(o.length) &amp;&amp; <span class="comment">// o.length是有限数值</span></span><br><span class="line">        o.length &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">// o.length为非负值</span></span><br><span class="line">        o.length === <span class="built_in">Math</span>.floor(o.length) &amp;&amp;    <span class="comment">// o.length是整数</span></span><br><span class="line">        o.length &lt; <span class="number">4294967296</span> <span class="comment">// o.length &lt; 2^32</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> specialPrototype = <span class="built_in">Symbol</span>(<span class="string">&#x27;唯一性&#x27;</span>);</span><br><span class="line">  context[specialPrototype] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(args) &amp;&amp; !isArrayLike(args)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;myApply 第二个参数不为数组并且不为类数组对象抛出错误&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 执行函数并展开数组，传递函数参数</span></span><br><span class="line">      res = context[specialPrototype](...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res = context[specialPrototype]();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context[specialPrototype];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> thisfn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> context = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    [].push.call(args, ..._args);</span><br><span class="line">    thisfn.call(context, ...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="apply、call"><a href="#apply、call" class="headerlink" title="apply、call"></a><strong>apply、call</strong></h2><p>在 javascript 中，<span class="c42b983">call</span> 和 <span class="c42b983">apply</span> 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 <span class="c42b983">this</span> 的指向。<br>JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fruits</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fruits.prototype = &#123;</span><br><span class="line">    color: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;My color is &quot;</span> + <span class="built_in">this</span>.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> fruits;</span><br><span class="line">apple.say();    <span class="comment">//My color is red</span></span><br></pre></td></tr></table></figure>

<p>但是如果我们有一个对象 banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 <span class="c42b983">call</span> 或 <span class="c42b983">apply</span> 用 apple 的 say 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">banana = &#123;</span><br><span class="line">    color: <span class="string">&quot;yellow&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">apple.say.call(banana);     <span class="comment">//My color is yellow</span></span><br><span class="line">apple.say.apply(banana);    <span class="comment">//My color is yellow</span></span><br></pre></td></tr></table></figure>

<p>所以，可以看出 <span class="c42b983">call</span> 和 <span class="c42b983">apply</span> 是为了动态改变 <span class="c42b983">this</span> 而出现的，当一个 object 没有某个方法（本栗子中banana没有say方法），但是其他的有（本栗子中apple有say方法），我们可以借助<span class="c42b983">call</span> 或 <span class="c42b983">apply</span>用其它对象的方法来操作。</p>
<h2 id="apply、call-区别"><a href="#apply、call-区别" class="headerlink" title="apply、call 区别"></a><strong>apply、call 区别</strong></h2><p>对于 <span class="c42b983">apply</span>、<span class="c42b983">call</span> 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就可以通过如下方式来调用:</span></span><br><span class="line"></span><br><span class="line">func.call(<span class="built_in">this</span>, arg1, arg2);</span><br><span class="line">func.apply(<span class="built_in">this</span>, [arg1, arg2])</span><br></pre></td></tr></table></figure>

<p>其中 <span class="c42b983">this</span> 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，<span class="c42b983">call</span> 需要把参数按顺序传递进去，而 <span class="c42b983">apply</span> 则是把参数放在数组里。　　<br>为了巩固加深记忆，下面列举一些常用用法：</p>
<h2 id="apply、call实例"><a href="#apply、call实例" class="headerlink" title="apply、call实例"></a><strong>apply、call实例</strong></h2><h3 id="数组之间追加"><a href="#数组之间追加" class="headerlink" title="数组之间追加"></a><strong>数组之间追加</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">12</span> , <span class="string">&quot;foo&quot;</span> , &#123;<span class="attr">name</span>:<span class="string">&quot;Joe&quot;</span>&#125; , -<span class="number">2458</span>]; </span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">&quot;Doe&quot;</span> , <span class="number">555</span> , <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(array1, array2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// array1 值为  [12 , &quot;foo&quot; , &#123;name:&quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100] </span></span><br></pre></td></tr></table></figure>

<h3 id="获取数组中的最大值和最小值"><a href="#获取数组中的最大值和最小值" class="headerlink" title="获取数组中的最大值和最小值"></a><strong>获取数组中的最大值和最小值</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  numbers = [<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , -<span class="number">215</span> ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, numbers);   <span class="comment">//458</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>,<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , -<span class="number">215</span>); <span class="comment">//458</span></span><br></pre></td></tr></table></figure>

<p>number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。</p>
<h3 id="验证是否是数组（前提是toString-方法没有被重写过）"><a href="#验证是否是数组（前提是toString-方法没有被重写过）" class="headerlink" title="验证是否是数组（前提是toString()方法没有被重写过）"></a><strong>验证是否是数组（前提是toString()方法没有被重写过）</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">functionisArray</span>(<span class="params">obj</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&#x27;[object Array]&#x27;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类（伪）数组使用数组方法"><a href="#类（伪）数组使用数组方法" class="headerlink" title="类（伪）数组使用数组方法"></a><strong>类（伪）数组使用数组方法</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domNodes = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;*&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>Javascript中存在一种名为伪数组的对象结构。比较特别的是 <span class="c42b983">arguments</span> 对象，还有像调用 <span class="c42b983">getElementsByTagName</span> , <span class="c42b983">document.childNodes</span> 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。<br>但是我们能通过 <span class="c42b983">Array.prototype.slice.call</span> 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a><strong>bind</strong></h2><p>在讨论<span class="c42b983">bind()</span>方法之前我们先来看一道题目：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> altwrite = <span class="built_in">document</span>.write;</span><br><span class="line">altwrite(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>结果：Uncaught TypeError: Illegal invocation<br>altwrite()函数改变<span class="c42b983">this的指向global或window对象</span>，导致执行时提示非法调用异常，正确的方案就是使用bind()方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">altwrite.bind(<span class="built_in">document</span>)(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当然也可以使用<span class="c42b983">call()</span>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">altwrite.call(<span class="built_in">document</span>, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="绑定函数"><a href="#绑定函数" class="headerlink" title="绑定函数"></a><strong>绑定函数</strong></h3><p><span class="c42b983">bind()</span>最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。常见的错误就像上面的例子一样，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。如果不做特殊处理，一般会丢失原来的对象。使用bind()方法能够很漂亮的解决这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.num = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">var</span> mymodule = &#123;</span><br><span class="line">  num: <span class="number">81</span>,</span><br><span class="line">  getNum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mymodule.getNum(); <span class="comment">// 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNum = mymodule.getNum;</span><br><span class="line">getNum(); <span class="comment">// 9, 因为在这个例子中，&quot;this&quot;指向全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundGetNum = getNum.bind(mymodule);</span><br><span class="line">boundGetNum(); <span class="comment">// 81</span></span><br></pre></td></tr></table></figure>

<p><span class="c42b983">bind()</span> 方法与 <span class="c42b983">apply</span> 和 <span class="c42b983">call</span> 很相似，也是可以改变函数体内 <span class="c42b983">this</span> 的指向。</p>
<p>MDN的解释是：<span class="c42b983">bind()</span>方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 <span class="c42b983">bind()</span>方法的第一个参数作为 <span class="c42b983">this</span>，传入 <span class="c42b983">bind()</span> 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p>直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 <span class="c42b983">_this</span> , <span class="c42b983">that</span> , <span class="c42b983">self</span> 等保存 <span class="c42b983">this</span> ，这样我们可以在改变了上下文之后继续引用到它。 像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar : <span class="number">1</span>,</span><br><span class="line">  eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    $(<span class="string">&#x27;.someClass&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/* Act on the event */</span></span><br><span class="line">      <span class="built_in">console</span>.log(_this.bar);     <span class="comment">//1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar : <span class="number">1</span>,</span><br><span class="line">  eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;.someClass&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* Act on the event */</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.bar);      <span class="comment">//1</span></span><br><span class="line">    &#125;.bind(<span class="built_in">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码里，<span class="c42b983">bind()</span> 创建了一个函数，当这个click事件绑定在被调用的时候，它的 <span class="c42b983">this</span> 关键词会被设置成被传入的值（这里指调用<span class="c42b983">bind()</span>时传入的参数）。因此，这里我们传入想要的上下文 <span class="c42b983">this</span>(其实就是 foo )，到 <span class="c42b983">bind()</span> 函数中。然后，当回调函数被执行的时候， <span class="c42b983">this</span> 便指向 foo 对象。再来一个简单的栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  x:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo);</span><br><span class="line">func(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>这里我们创建了一个新的函数 func，当使用 <span class="c42b983">bind()</span> 创建一个绑定函数之后，它被执行的时候，它的 <span class="c42b983">this</span> 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。</p>
<h3 id="偏函数（Partial-Functions）"><a href="#偏函数（Partial-Functions）" class="headerlink" title="偏函数（Partial Functions）"></a><strong>偏函数（Partial Functions）</strong></h3><p>这是一个很好的特性，使用<span class="c42b983">bind()</span>我们设定函数的预定义参数，然后调用的时候传入其他参数即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预定义参数37</span></span><br><span class="line"><span class="keyword">var</span> leadingThirtysevenList = list.bind(<span class="literal">undefined</span>, <span class="number">37</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list2 = leadingThirtysevenList(); <span class="comment">// [37]</span></span><br><span class="line"><span class="keyword">var</span> list3 = leadingThirtysevenList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [37, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="和setTimeout一起使用"><a href="#和setTimeout一起使用" class="headerlink" title="和setTimeout一起使用"></a><strong>和setTimeout一起使用</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bloomer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.petalCount = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">12</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1秒后调用declare函数</span></span><br><span class="line">Bloomer.prototype.bloom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="built_in">this</span>.declare.bind(<span class="built_in">this</span>), <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bloomer.prototype.declare = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我有 &#x27;</span> + <span class="built_in">this</span>.petalCount + <span class="string">&#x27; 朵花瓣!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bloo = <span class="keyword">new</span> Bloomer();</span><br><span class="line">bloo.bloom(); <span class="comment">//我有 5 朵花瓣!</span></span><br></pre></td></tr></table></figure>

<p>注意：对于事件处理函数和setInterval方法也可以使用上面的方法</p>
<h3 id="绑定函数作为构造函数"><a href="#绑定函数作为构造函数" class="headerlink" title="绑定函数作为构造函数"></a><strong>绑定函数作为构造函数</strong></h3><p>绑定函数也适用于使用<span class="c42b983">new操作符</span>来构造目标函数的实例。当使用绑定函数来构造实例，注意：<span class="c42b983">this</span>会被忽略，但是传入的参数仍然可用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.x + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">this</span>.y);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">p.toString(); <span class="comment">// &#x27;1,2&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emptyObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> YAxisPoint = Point.bind(emptyObj, <span class="number">0</span><span class="comment">/*x*/</span>);</span><br><span class="line"><span class="comment">// 实现中的例子不支持,</span></span><br><span class="line"><span class="comment">// 原生bind支持:</span></span><br><span class="line"><span class="keyword">var</span> YAxisPoint = Point.bind(<span class="literal">null</span>, <span class="number">0</span><span class="comment">/*x*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> axisPoint = <span class="keyword">new</span> YAxisPoint(<span class="number">5</span>);</span><br><span class="line">axisPoint.toString(); <span class="comment">// &#x27;0,5&#x27;</span></span><br><span class="line"></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> Point; <span class="comment">// true</span></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> YAxisPoint; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Point(<span class="number">17</span>, <span class="number">42</span>) <span class="keyword">instanceof</span> YAxisPoint; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h3><p>上面的几个小节可以看出<span class="c42b983">bind()</span>有很多的使用场景，但是<span class="c42b983">bind()</span>函数是在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。这就需要我们自己实现<span class="c42b983">bind()</span>函数了。</p>
<p>首先我们可以通过给目标函数指定作用域来简单实现<span class="c42b983">bind()</span>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  self = <span class="built_in">this</span>;  <span class="comment">//保存this，即调用bind方法的目标函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.apply(context,<span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>考虑到函数柯里化的情况，我们可以构建一个更加健壮的<span class="c42b983">bind()</span>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">  self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">    <span class="keyword">return</span> self.apply(context,finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这次的<span class="c42b983">bind()</span>方法可以绑定对象，也支持在绑定的时候传参。</p>
<p>继续，Javascript的函数还可以作为构造函数，那么绑定后的函数用这种方式调用时，情况就比较微妙了，需要涉及到原型链的传递：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">  F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  self = <span class="built_in">this</span>,</span><br><span class="line">  bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">    <span class="keyword">return</span> self.apply((<span class="built_in">this</span> <span class="keyword">instanceof</span> F ? <span class="built_in">this</span> : context), finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  F.prototype = self.prototype;</span><br><span class="line">  bound.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是《JavaScript Web Application》一书中对<span class="c42b983">bind()</span>的实现：通过设置一个中转构造函数F，使绑定后的函数与调用<span class="c42b983">bind()</span>的函数处于同一原型链上，用new操作符调用绑定后的函数，返回的对象也能正常使用instanceof，因此这是最严谨的<span class="c42b983">bind()</span>实现。</p>
<p>对于为了在浏览器中能支持<span class="c42b983">bind()</span>函数，只需要对上述函数稍微修改即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), </span><br><span class="line">    fToBind = <span class="built_in">this</span>, </span><br><span class="line">    fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fToBind.apply(</span><br><span class="line">          <span class="built_in">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis ? <span class="built_in">this</span> : oThis || <span class="built_in">window</span>,</span><br><span class="line">          aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有个有趣的问题，如果连续 <span class="c42b983">bind()</span> 两次，亦或者是连续 <span class="c42b983">bind()</span> 三次那么输出的值是什么呢？像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    x:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sed = &#123;</span><br><span class="line">    x:<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo).bind(sed);</span><br><span class="line">func(); <span class="comment">//?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fiv = &#123;</span><br><span class="line">    x:<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo).bind(sed).bind(fiv);</span><br><span class="line">func(); <span class="comment">//?</span></span><br></pre></td></tr></table></figure>

<p>答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在Javascript中，多次 <span class="c42b983">bind()</span> 是无效的。更深层次的原因， <span class="c42b983">bind()</span> 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 <span class="c42b983">bind()</span> 相当于再包住第一次 <span class="c42b983">bind()</span> ,故第二次以后的 bind 是无法生效的。</p>
<h2 id="apply、call、bind比较"><a href="#apply、call、bind比较" class="headerlink" title="apply、call、bind比较"></a><strong>apply、call、bind比较</strong></h2><p>那么 <span class="c42b983">apply、call、bind</span> 三者相比较，之间又有什么异同呢？何时使用 <span class="c42b983">apply、call</span>，何时使用 <span class="c42b983">bind</span> 呢。简单的一个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">81</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.bind(obj)());  <span class="comment">//81</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.call(obj));    <span class="comment">//81</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.apply(obj));   <span class="comment">//81</span></span><br></pre></td></tr></table></figure>

<p>三个输出的都是81，但是注意看使用 <span class="c42b983">bind()</span> 方法的，他后面多了对括号。</p>
<p>也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 <span class="c42b983">bind()</span> 方法。而 <span class="c42b983">apply</span>/<span class="c42b983">call</span> 则会立即执行函数。</p>
<p>再总结一下：</p>
<p><span class="c42b983">apply 、 call 、bind</span> 三者都是用来改变函数的this对象的指向的；<br><span class="c42b983">apply 、 call 、bind</span> 三者第一个参数都是this要指向的对象，也就是想指定的上下文；<br><span class="c42b983">apply 、 call 、bind</span> 三者都可以利用后续参数传参；<br><span class="c42b983">bind</span> 是返回对应函数，便于稍后调用；<span class="c42b983">apply 、call</span> 则是立即调用 。</p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2021/03/17/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="前端常见跨域解决方案" class="prev">PREV</a><a href="/2021/03/11/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/" title="前端模块化的理解" class="next">NEXT</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2021 <a target="_blank">J.K</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz", "FdzS5SOPHdhYQoEUngQ8K2QW");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>