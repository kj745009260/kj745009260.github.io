<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> javascript十大排序算法 · 前端Store</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="javascript十大排序算法 - J.K"><meta name="keywords"><meta name="author" content="J.K"><link rel="short icon" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/favicon.ico"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="前端Store"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="前端Store" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/live/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/categories/read/" target="_self" data-hover="读书" class="nav-list-link">读书</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">javascript十大排序算法</h1><div class="post-info">2020-10-15<p class="visit"><i data-identity="2020/10/15/javascript十大排序算法/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><h2 id="排序算法说明"><a href="#排序算法说明" class="headerlink" title="排序算法说明"></a><strong>排序算法说明</strong></h2><h3 id="1-排序的定义"><a href="#1-排序的定义" class="headerlink" title="1.排序的定义"></a><strong>1.排序的定义</strong></h3><p>对一序列对象根据某个关键字进行排序</p>
<p>输入：n个数：a1,a2,a3,…,an 输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。</p>
<p>再讲的形象点就是排排坐，调座位，高的站后面，矮的站前面。</p>
<h3 id="2-对于评述算法优劣术语的说明"><a href="#2-对于评述算法优劣术语的说明" class="headerlink" title="2.对于评述算法优劣术语的说明"></a><strong>2.对于评述算法优劣术语的说明</strong></h3><p>稳定：如果a原本在b前面，而a=b,排序之后a仍然在b的前面；不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
<p>内排序：所有排序操作都在内存中完成；外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p>时间复杂度：一个算法执行所耗费的时间。空间复杂度：运行完一个程序所需内存的大小。</p>
<h3 id="3-排序算法图片总结"><a href="#3-排序算法图片总结" class="headerlink" title="3.排序算法图片总结"></a><strong>3.排序算法图片总结</strong></h3><p><img src="/images/sort.png" alt="排序"></p>
<h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a><strong>冒泡排序(Bubble Sort)</strong></h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a><strong>1.算法描述</strong></h3><p>冒泡排序是一种简单的排序算法。它重复的走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复的进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮“到数列的顶端。</p>
<h3 id="2-算法描述和实现"><a href="#2-算法描述和实现" class="headerlink" title="2.算法描述和实现"></a><strong>2.算法描述和实现</strong></h3><blockquote>
<p>1.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p>
</blockquote>
<blockquote>
<p>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数。</p>
</blockquote>
<blockquote>
<p>3.针对所有的元素重复以上的操作，除了最后一个；</p>
</blockquote>
<blockquote>
<p>4.重复步骤1~3，直到排序完成。</p>
</blockquote>
<h3 id="3-JavaScript代码实现"><a href="#3-JavaScript代码实现" class="headerlink" title="3.JavaScript代码实现"></a><strong>3.JavaScript代码实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;  <span class="comment">// 相邻元素两两对比</span></span><br><span class="line">        <span class="keyword">let</span> tmp = arr[j];         <span class="comment">// 元素交换</span></span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>

<p><span class="c42b983">改进冒泡排序</span>: 设置一标志性变量post，用于记录每趟排序中最后一次交换的位置。由于post位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到post位置即可。</p>
<p>改进后算法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        pos = j; <span class="comment">// 记录最后修改位置</span></span><br><span class="line">        <span class="keyword">let</span> tmp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = pos;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">​​</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// let arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 0, 1];</span></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort2(arr));</span><br></pre></td></tr></table></figure>

<p>传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用每趟排序中进行正向和反向两遍冒泡的方法可以得到两个最终值（最大者和最小者），从而使排序躺数几乎减少了一半。</p>
<p>改进后的排序算法实现为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort3</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp, j;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">&#x27;2.改进后的冒泡排序耗时&#x27;</span>);</span><br><span class="line">  <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = low; j &lt; high; j++) &#123;</span><br><span class="line">      <span class="comment">// 这里排序出最高的</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123; <span class="comment">// 正向冒泡，找出最大者</span></span><br><span class="line">        tmp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = high; j &gt; low; j--) &#123; <span class="comment">// 反向冒泡 找出最小者</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        tmp = arr[j];</span><br><span class="line">        arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        arr[j - <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    low++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;2.改进后的冒泡排序耗时&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort3(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/bubble.png" alt="bubble"></p>
<h3 id="4-冒泡排序动图演示"><a href="#4-冒泡排序动图演示" class="headerlink" title="4.冒泡排序动图演示"></a><strong>4.冒泡排序动图演示</strong></h3><p><img src="/images/bubbles.gif" alt="bubble"></p>
<h3 id="5-算法分析"><a href="#5-算法分析" class="headerlink" title="5.算法分析"></a><strong>5.算法分析</strong></h3><blockquote>
<ul>
<li>最佳情况：T(n) = O(n)  当输入值的数据已经是正序时（都已经是正序了，为毛何必还排序呢….）</li>
<li>最差情况：T(n) = O(n2)  当输入的数据是反序时(卧槽，我直接反序不就完了….)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
</blockquote>
<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a><strong>选择排序（Selection Sort）</strong></h2><p>表现最稳定的排序算法之一（这个稳定性不是指算法层面上的稳定哈），因为无论是什么数据进去都是O(n²)的时间复杂度……所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<h3 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="1.算法简介"></a><strong>1.算法简介</strong></h3><p>选择排序（Selection-sort）是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h3 id="2-算法描述和实现-1"><a href="#2-算法描述和实现-1" class="headerlink" title="2.算法描述和实现"></a><strong>2.算法描述和实现</strong></h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<blockquote>
<p>1.初始状态：无序区为R[1,…n]，有序区为空；</p>
</blockquote>
<blockquote>
<p>2.第i趟排序（i=1,2,3,4,…n-1）开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录R[k],将它与无序区的第1个记录R交换，使R[1,…i]和R[i+1…n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</p>
</blockquote>
<blockquote>
<p>3.n-1趟结束，数组有序化了。</p>
</blockquote>
<h3 id="3-JavaScript代码实现-1"><a href="#3-JavaScript代码实现-1" class="headerlink" title="3.JavaScript代码实现"></a><strong>3.JavaScript代码实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = arr.length;</span><br><span class="line">  <span class="keyword">var</span> minIndex, tmp;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">&quot;选择排序耗时&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = arr[minIndex];</span><br><span class="line">    arr[minIndex] = arr[i];</span><br><span class="line">    arr[i] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">&quot;选择排序耗时&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(selectionSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-选择排序动图演示"><a href="#4-选择排序动图演示" class="headerlink" title="4.选择排序动图演示"></a><strong>4.选择排序动图演示</strong></h3><p><img src="/images/selectsort.gif" alt="selectsort"></p>
<h3 id="5-算法分析-1"><a href="#5-算法分析-1" class="headerlink" title="5.算法分析"></a><strong>5.算法分析</strong></h3><blockquote>
<p>最佳情况：T(n) = O(n)</p>
</blockquote>
<blockquote>
<p>最差情况：T(n) = O(n2)</p>
</blockquote>
<blockquote>
<p>平均情况：T(n) = O(n2)</p>
</blockquote>
<h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a><strong>插入排序(Insertion Sort)</strong></h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸排的时候从来不按牌的大小调整牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了…</p>
<h3 id="1-算法简介-1"><a href="#1-算法简介-1" class="headerlink" title="1.算法简介"></a><strong>1.算法简介</strong></h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描找到对应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把一排序元素逐步向后挪威，为最新元素提供插入空间。</p>
<h3 id="2-算法的描述和实现"><a href="#2-算法的描述和实现" class="headerlink" title="2.算法的描述和实现"></a><strong>2.算法的描述和实现</strong></h3><p>一般来说，插入排序都采用in-place在数组上实现。具体的算法描述如下：</p>
<blockquote>
<p>1.从第一个元素开始，该元素可以认为已经被排序。</p>
</blockquote>
<blockquote>
<p>2.取出下一个元素，在已经排序的元素序列中从后向前扫描</p>
</blockquote>
<blockquote>
<p>3.如果该元素（已排序）大于新元素，将该元素移到下一位置</p>
</blockquote>
<blockquote>
<p>4.重复步骤3，直到找到已排序的元素小于或等于新元素的位置；</p>
</blockquote>
<blockquote>
<p>5.将新元素插入到该位置后；</p>
</blockquote>
<blockquote>
<p>6.重复步骤2~5</p>
</blockquote>
<h3 id="3-JavaScript代码实现-2"><a href="#3-JavaScript代码实现-2" class="headerlink" title="3.JavaScript代码实现"></a><strong>3.JavaScript代码实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] &lt; array[j]) &#123;</span><br><span class="line">        array.splice(j, <span class="number">0</span>, array[i]);</span><br><span class="line">        array.splice(i + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-插入排序动图演示"><a href="#4-插入排序动图演示" class="headerlink" title="4.插入排序动图演示"></a><strong>4.插入排序动图演示</strong></h3><p><img src="/images/insertsort.gif" alt="insertsort"></p>
<h3 id="5-算法分析-2"><a href="#5-算法分析-2" class="headerlink" title="5.算法分析"></a><strong>5.算法分析</strong></h3><blockquote>
<p>最佳情况：输入数组按升序排序。T(n) = O(n)</p>
</blockquote>
<blockquote>
<p>最坏情况：输入数组按降序排序。T(n) = O(n2)</p>
</blockquote>
<blockquote>
<p>平均情况：T(n) = O(n2)</p>
</blockquote>
<h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a><strong>希尔排序(Shell Sort)</strong></h2><p>1959年Sheel发明：第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>
<h3 id="1-算法简介-2"><a href="#1-算法简介-2" class="headerlink" title="1.算法简介"></a><strong>1.算法简介</strong></h3><p>希尔排序的核心在于间隔序列的设定。既可以提前设好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）的合著者Robert Sedgewick提出的》。</p>
<h3 id="2-算法描述和实现-2"><a href="#2-算法描述和实现-2" class="headerlink" title="2.算法描述和实现"></a><strong>2.算法描述和实现</strong></h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<blockquote>
<p>1.选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk = 1</p>
</blockquote>
<blockquote>
<p>2.按增量序列个数k，对序列进行k趟排序；</p>
</blockquote>
<blockquote>
<p>3.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</blockquote>
<h3 id="3-JavaScript代码实现-3"><a href="#3-JavaScript代码实现-3" class="headerlink" title="3.JavaScript代码实现"></a><strong>3.JavaScript代码实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sheelSort2</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> N = array.length;</span><br><span class="line">  <span class="keyword">let</span> h = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 计算出步长最大值</span></span><br><span class="line">  <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) &#123;</span><br><span class="line">    h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以步长进行循环</span></span><br><span class="line">  <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 以当前步长为起点循环数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="comment">// 找出距离当前元素为步长的元素，然后交换数值</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i - h; j &gt;= <span class="number">0</span>; j = j - h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + h]) &#123;</span><br><span class="line">          <span class="keyword">let</span> temp = array[j];</span><br><span class="line">          array[j] = array[j + h]; </span><br><span class="line">          array[j + h] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置步长，再次进行循环</span></span><br><span class="line">    h = (h - <span class="number">1</span>) / <span class="number">3</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-希尔排序图示"><a href="#4-希尔排序图示" class="headerlink" title="4.希尔排序图示"></a><strong>4.希尔排序图示</strong></h3><p><img src="/images/xierpaixu.png" alt="xierpaixu"></p>
<h3 id="5-算法分析-3"><a href="#5-算法分析-3" class="headerlink" title="5.算法分析"></a><strong>5.算法分析</strong></h3><blockquote>
<p>最佳情况：T(n) = O(nlog2 n)</p>
</blockquote>
<blockquote>
<p>最坏情况：T(n) = O(nlog2 n)</p>
</blockquote>
<blockquote>
<p>平均情况：T(n) =O(nlog n)</p>
</blockquote>
<h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a><strong>归并排序(Merge Sort)</strong></h2><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n)的时间复杂度。代价是需要额外的内存空间。</p>
<h3 id="1-算法简介-3"><a href="#1-算法简介-3" class="headerlink" title="1.算法简介"></a><strong>1.算法简介</strong></h3><p>归并排序时建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，成为2-路归并。</p>
<h3 id="2-算法描述和实现-3"><a href="#2-算法描述和实现-3" class="headerlink" title="2.算法描述和实现"></a><strong>2.算法描述和实现</strong></h3><p>具体算法描述如下：</p>
<blockquote>
<p>1.把长度为n的输入序列分成两个长度为n/2的子序列；</p>
</blockquote>
<blockquote>
<p>2.对这两个子序列分别采用归并排序。</p>
</blockquote>
<blockquote>
<p>3.将两个排序好的子序列合并成一个最终的排序序列。</p>
</blockquote>
<h3 id="3-JavaScript代码实现-4"><a href="#3-JavaScript代码实现-4" class="headerlink" title="3.JavaScript代码实现"></a><strong>3.JavaScript代码实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个思想有点难啊，看起来和之前的二叉树的中序遍历差不多</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123; <span class="comment">// 采用自上而下的递归方法</span></span><br><span class="line">  <span class="comment">// console.log(&#x27;mergeSort&#x27;, arr);</span></span><br><span class="line">  <span class="keyword">var</span> length = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> left = arr.slice(<span class="number">0</span>, middle);</span><br><span class="line">  <span class="keyword">var</span> right = arr.slice(middle);</span><br><span class="line">  <span class="comment">// console.log(&#x27;mergeSort&#x27;, &#x27;left&#x27;, left, &#x27;right&#x27;, right);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;left&#x27;</span>, left, <span class="string">&#x27;right&#x27;</span>, right);</span><br><span class="line">  <span class="comment">// console.time(&#x27;归并排序耗时&#x27;);</span></span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">    result.push(left.shift());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">    result.push(right.shift());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.timeEnd(&#x27;归并排序耗时&#x27;);</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(mergeSort(arr));</span><br></pre></td></tr></table></figure>

<h3 id="4-归并排序动图演示"><a href="#4-归并排序动图演示" class="headerlink" title="4.归并排序动图演示"></a><strong>4.归并排序动图演示</strong></h3><p><img src="/images/guibingpaixu.gif" alt="guibingpaixu"></p>
<h3 id="5-算法分析-4"><a href="#5-算法分析-4" class="headerlink" title="5.算法分析"></a><strong>5.算法分析</strong></h3><blockquote>
<p>最佳情况：T(n) = O(n)</p>
</blockquote>
<blockquote>
<p>最差情况：T(n) = O(nlogn)</p>
</blockquote>
<blockquote>
<p>平均情况：T(n) = O(nlogn)</p>
</blockquote>
<h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a><strong>快速排序(Quick Sort)</strong></h2><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的算法之一了。</p>
<h3 id="1-算法简介-4"><a href="#1-算法简介-4" class="headerlink" title="1.算法简介"></a><strong>1.算法简介</strong></h3><p>快速排序的基本思想：通过一趟排序将待记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h3 id="2-算法描述和实现-4"><a href="#2-算法描述和实现-4" class="headerlink" title="2.算法描述和实现"></a><strong>2.算法描述和实现</strong></h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-list）。具体算法描述如下：</p>
<blockquote>
<p>1.从数列中挑出一个元素，称为“基准”(pivot)</p>
</blockquote>
<blockquote>
<p>2.重新排序数列，所有元素比基准值小的摆放在最前面，所有元素比基准值大的摆在基准的后面（相同的可任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（Partition）操作；</p>
</blockquote>
<blockquote>
<p>3.递归的（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</blockquote>
<h3 id="3-JavaScript代码实现-5"><a href="#3-JavaScript代码实现-5" class="headerlink" title="3.JavaScript代码实现"></a><strong>3.JavaScript代码实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(arr).slice(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> length === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> right === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log(&#x27;进来的数组&#x27;, JSON.stringify(arr), &#x27;left ==&gt;&#x27;, left, &#x27;right===&gt;&#x27;, right);</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">var</span> key = arr[left]; <span class="comment">// 起始位置</span></span><br><span class="line">      <span class="keyword">var</span> setPos = left + <span class="number">1</span>; <span class="comment">// 设置的位置</span></span><br><span class="line">      <span class="keyword">var</span> tmp;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; key) &#123;</span><br><span class="line">          tmp = arr[i]; <span class="comment">// 交换位置，并将下次小于的位置+1</span></span><br><span class="line">          arr[i] = arr[setPos];</span><br><span class="line">          arr[setPos] = tmp;</span><br><span class="line">          setPos++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 循环完成之后将key与 pos-1的位置交换</span></span><br><span class="line">      arr[left] = arr[setPos - <span class="number">1</span>];</span><br><span class="line">      arr[setPos - <span class="number">1</span>] = key;</span><br><span class="line">      <span class="comment">// console.log(&#x27;每一次排序&#x27;, &#x27;当前key值===&gt;&#x27;, key, &#x27;排序完成当前数组===&gt;&#x27;, JSON.stringify(arr));</span></span><br><span class="line"></span><br><span class="line">      quickSort(arr, left, setPos - <span class="number">2</span>);</span><br><span class="line">      quickSort(arr, setPos, right);</span><br><span class="line">      <span class="comment">// console.log(&#x27;arr=======&gt;&#x27;, arr);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;array is not an Array or left or right is not a number!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="comment">// var arr = [7, 3, 2, 10, 13, 8, 5];</span></span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">&#x27;1.快速排序耗时&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> left === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> right === <span class="string">&#x27;number&#x27;</span>) &#123;      </span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">var</span> x = array[right], i = left - <span class="number">1</span>, temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = left; j &lt;= right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt;= x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                temp = array[i];</span><br><span class="line">                array[i] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(array, left, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;1.快速排序耗时&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> array;   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;array is not an Array or left or right is not a number!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态图示算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr &#125;;</span><br><span class="line">  <span class="keyword">var</span> pivoIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> pivot = arr.splice(pivoIndex, <span class="number">1</span>)[<span class="number">0</span>]; <span class="comment">// 将要选择排序的那一位选举出来 摘出来</span></span><br><span class="line">  <span class="keyword">var</span> left = [];</span><br><span class="line">  <span class="keyword">var</span> right = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 小的放左边，大的放右边</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;left&#x27;</span>, left, <span class="string">&#x27;right&#x27;</span>, right);</span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="comment">// var arr = [7, 3, 2, 10, 13, 8, 5];</span></span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-快速排序动图演示"><a href="#4-快速排序动图演示" class="headerlink" title="4.快速排序动图演示"></a><strong>4.快速排序动图演示</strong></h3><p><img src="/images/kuaisupaixu.gif" alt="kuaisupaixu"></p>
<h3 id="5-算法分析-5"><a href="#5-算法分析-5" class="headerlink" title="5.算法分析"></a><strong>5.算法分析</strong></h3><blockquote>
<p>最佳情况：T(n) = O(nlogn)</p>
</blockquote>
<blockquote>
<p>最差情况：T(n) = O(n2)</p>
</blockquote>
<blockquote>
<p>平均情况：T(n) = O(nlogn)</p>
</blockquote>
<h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a><strong>堆排序（Heap Sort）</strong></h2><p>堆排序可以说是一种利用堆的概念来排序的选择排序。</p>
<h3 id="1-算法简介-5"><a href="#1-算法简介-5" class="headerlink" title="1.算法简介"></a><strong>1.算法简介</strong></h3><p>堆排序（HeapSort）是指利用堆这种数据结构所涉及的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。</p>
<h3 id="2-算法描述和实现-5"><a href="#2-算法描述和实现-5" class="headerlink" title="2.算法描述和实现"></a><strong>2.算法描述和实现</strong></h3><p>具体算法描述如下</p>
<blockquote>
<p>1.将初始待排序的关键字序列（R1，R2…Rn）构建成大顶堆，此堆为初始的无序区。</p>
</blockquote>
<blockquote>
<p>2.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区[R1,R2,…Rn-1]和新的有序区(Rn),且满足R[1,2…n-1]&lt;R[n];</p>
</blockquote>
<blockquote>
<p>3.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区（R1，R2…Rn-1）调整为新堆，然后再将R[1]与无序区最后一个元素交换，得到新的无序区（R1，R2…Rn-2）和新的有序区（Rn-1，Rn）。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p>
</blockquote>
<h3 id="3-JavaScript代码实现-6"><a href="#3-JavaScript代码实现-6" class="headerlink" title="3.JavaScript代码实现"></a><strong>3.JavaScript代码实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  方法说明：堆排序</span></span><br><span class="line"><span class="comment">  @param &#123;Array&#125; arr 待排序数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;堆排序&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(arr).slice(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> heapSize = arr.length;</span><br><span class="line">    <span class="keyword">var</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;待排序数组的长度===&gt;&#x27;</span>, heapSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;建造之前的堆的样式&#x27;</span>, <span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line">    <span class="comment">// 建造堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      heapify(arr, i, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;堆初始化完成之后的样式&#x27;</span>, <span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在要把最大的放到最后一个，最后一个放到第一个，把堆的大小减少一个，在慢慢的把最大的循环上去</span></span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;堆排序耗时&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = heapSize - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">      temp = arr[<span class="number">0</span>];</span><br><span class="line">      arr[<span class="number">0</span>] = arr[j];</span><br><span class="line">      arr[j] = temp;</span><br><span class="line">      heapify(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;堆排序耗时&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;array is not array&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  建堆：维护堆的性质</span></span><br><span class="line"><span class="comment">  @param &#123;Array&#125; arr 数组</span></span><br><span class="line"><span class="comment">  @param &#123;Number&#125; x 数组下标</span></span><br><span class="line"><span class="comment">  @param &#123;Number&#125; len 堆大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, x, len</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(arr).slice(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">2</span> * x + <span class="number">1</span>; <span class="comment">// 左下标</span></span><br><span class="line">    <span class="keyword">var</span> r = <span class="number">2</span> * x + <span class="number">2</span>; <span class="comment">// 右下标</span></span><br><span class="line">    <span class="keyword">var</span> largest = x; <span class="comment">// 默认最大的是父节点</span></span><br><span class="line">    <span class="keyword">var</span> temp; <span class="comment">// 用于交换数据存储的中间值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找到一个堆中的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">      largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">      largest = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大者不是父节点 则交换位置</span></span><br><span class="line">    <span class="keyword">if</span> (largest != x) &#123;</span><br><span class="line">      temp = arr[x];</span><br><span class="line">      arr[x] = arr[largest];</span><br><span class="line">      arr[largest] = temp;</span><br><span class="line">      <span class="comment">// 递归寻找</span></span><br><span class="line">      heapify(arr, largest, len);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;arr is not an array or x is not a number&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">91</span>, <span class="number">60</span>, <span class="number">96</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">65</span>, <span class="number">46</span>, <span class="number">65</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">31</span>, <span class="number">77</span>, <span class="number">81</span>, <span class="number">22</span>];</span><br><span class="line"><span class="built_in">console</span>.log(heapSort(arr));<span class="comment">//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]</span></span><br></pre></td></tr></table></figure>
<h3 id="4-堆排序动图演示"><a href="#4-堆排序动图演示" class="headerlink" title="4.堆排序动图演示"></a><strong>4.堆排序动图演示</strong></h3><p><img src="/images/duipaixu.gif" alt="duipaixu"></p>
<h3 id="5-算法分析-6"><a href="#5-算法分析-6" class="headerlink" title="5.算法分析"></a><strong>5.算法分析</strong></h3><blockquote>
<p>最佳情况：T(n) = O(nlogn)</p>
</blockquote>
<blockquote>
<p>最差情况：T(n) = O(nlogn)</p>
</blockquote>
<blockquote>
<p>平均情况：T(n) = O(nlogn)</p>
</blockquote>
<h2 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序(Counting Sort)"></a><strong>计数排序(Counting Sort)</strong></h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h3 id="1-算法简介-6"><a href="#1-算法简介-6" class="headerlink" title="1.算法简介"></a><strong>1.算法简介</strong></h3><p>计数排序（Counting sort）是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
<h3 id="2-算法描述和实现-6"><a href="#2-算法描述和实现-6" class="headerlink" title="2.算法描述和实现"></a><strong>2.算法描述和实现</strong></h3><p>具体算法描述如下</p>
<blockquote>
<p>1.找出待排序的数组中的最大和最小的元素；</p>
</blockquote>
<blockquote>
<p>2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</p>
</blockquote>
<blockquote>
<p>3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）;</p>
</blockquote>
<blockquote>
<p>4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p>
</blockquote>
<h3 id="3-JavaScript代码实现-7"><a href="#3-JavaScript代码实现-7" class="headerlink" title="3.JavaScript代码实现"></a><strong>3.JavaScript代码实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;计数排序&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> B = [];</span><br><span class="line">  <span class="keyword">var</span> C = [];</span><br><span class="line">  <span class="keyword">var</span> min = max = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">&#x27;计数排序耗时&#x27;</span>);</span><br><span class="line">  <span class="comment">// 初始化计数排序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    min = min &lt;= arr[i] ? min : arr[i];</span><br><span class="line">    max = max &gt;= arr[i] ? max : arr[i];</span><br><span class="line">    C[arr[i]] = C[arr[i]] ? C[arr[i]] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;初始化结束之后&#x27;</span>, <span class="built_in">JSON</span>.stringify(C));</span><br><span class="line">  <span class="keyword">var</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = min; j &lt; max; j++) &#123;</span><br><span class="line">    C[j + <span class="number">1</span>] = (C[j + <span class="number">1</span>] || <span class="number">0</span>) + (C[j] || <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;计算完成之后&#x27;</span>, <span class="built_in">JSON</span>.stringify(C));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;计算完成之后arr&#x27;</span>, <span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line">  <span class="comment">// 现在C的下标就是这个值，C的内容就是这个值的个数</span></span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = len - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C[arr[l] - 1]===&gt;&#x27;</span>, C[arr[k]] - <span class="number">1</span>, <span class="string">&#x27;arrk===&gt;&#x27;</span>, arr[k]);</span><br><span class="line">    B[C[arr[k]] - <span class="number">1</span>] = arr[k];</span><br><span class="line">    C[arr[k]]--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;计数排序耗时&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(countingSort(arr)); <span class="comment">//[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]</span></span><br></pre></td></tr></table></figure>
<h3 id="4-计数排序动图演示"><a href="#4-计数排序动图演示" class="headerlink" title="4.计数排序动图演示"></a><strong>4.计数排序动图演示</strong></h3><p><img src="/images/jishupaixu.gif" alt="jishupaixu"></p>
<h3 id="5-算法分析-7"><a href="#5-算法分析-7" class="headerlink" title="5.算法分析"></a><strong>5.算法分析</strong></h3><p>当输入的元素是n个0到k之间的整数时，它的运行时间是O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
<blockquote>
<p>最佳情况：T(n) = O(n + k)</p>
</blockquote>
<blockquote>
<p>最差情况：T(n) = O(n+k)</p>
</blockquote>
<blockquote>
<p>平均情况：T(n) = O(n+k)</p>
</blockquote>
<h2 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a><strong>桶排序（Bucket Sort）</strong></h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<h3 id="1-算法简介-7"><a href="#1-算法简介-7" class="headerlink" title="1.算法简介"></a><strong>1.算法简介</strong></h3><p>桶排序(Bucket sort)的工作原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）</p>
<h3 id="2-算法描述和实现-7"><a href="#2-算法描述和实现-7" class="headerlink" title="2.算法描述和实现"></a><strong>2.算法描述和实现</strong></h3><p>具体算法描述如下：</p>
<blockquote>
<p>1.设置一个定量的数组当做空桶；</p>
</blockquote>
<blockquote>
<p>2.遍历输入数据，并且把数据一个一个放到对应的桶里去；</p>
</blockquote>
<blockquote>
<p>3.对每个不是空的桶进行排序；</p>
</blockquote>
<blockquote>
<p>4.从不是空的桶里把排好序的数据拼接起来。</p>
</blockquote>
<h3 id="3-javascript算法实现"><a href="#3-javascript算法实现" class="headerlink" title="3.javascript算法实现"></a><strong>3.javascript算法实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  方法说明：桶排序</span></span><br><span class="line"><span class="comment">  @param &#123;Array&#125; 数组</span></span><br><span class="line"><span class="comment">  @param &#123;Number&#125; 桶的数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">arr, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> buckets = [];</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">var</span> min = max = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> regex = <span class="string">&#x27;/^[1-9]+[0-9]*$/&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> space, n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;排序长度 ===&gt;&#x27;</span>, len);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义桶的数量</span></span><br><span class="line">  num = num || (num &gt; <span class="number">1</span> &amp;&amp; regex.test(num) ? num : <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;桶排序耗时&#x27;</span>);</span><br><span class="line">  <span class="comment">// 寻找到最大值和最小值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    min = (min &lt;= arr[i]) ? min : arr[i];</span><br><span class="line">    max = (max &gt;= arr[i]) ? max : arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;最大值===&gt; max&#x27;</span>, max, <span class="string">&#x27;最小值===&gt; min&#x27;</span>, min);</span><br><span class="line"></span><br><span class="line">  space = (max - min + <span class="number">1</span>) / num;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor((arr[j] - min) / space);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`第<span class="subst">$&#123;j&#125;</span>项，值==&gt; <span class="subst">$&#123;arr[j]&#125;</span> 桶的索引为 <span class="subst">$&#123;index&#125;</span>, space ===&gt; <span class="subst">$&#123;space&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (buckets[index]) &#123; <span class="comment">// 非空桶，插入排序</span></span><br><span class="line">      <span class="keyword">var</span> key = arr[j];</span><br><span class="line">      <span class="keyword">var</span> k = buckets[index].length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; buckets[index][k] &gt; key) &#123;</span><br><span class="line">        buckets[index][k + <span class="number">1</span>] = buckets[index][k];</span><br><span class="line">        k--;</span><br><span class="line">      &#125;</span><br><span class="line">      buckets[index][k + <span class="number">1</span>] = key;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 空桶初始化</span></span><br><span class="line">      buckets[index] = [];</span><br><span class="line">      buckets[index].push(arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (n &lt; num) &#123;</span><br><span class="line">    result = result.concat(buckets[n]);</span><br><span class="line">    n++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;桶排序完成===&gt;&#x27;</span>, buckets);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(bucketSort(arr, <span class="number">4</span>));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法说明：桶排序</span></span><br><span class="line"><span class="comment">@param  array 数组</span></span><br><span class="line"><span class="comment">@param  num   桶的数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">array, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> len = array.length, buckets = [], result = [], min = max = array[<span class="number">0</span>], regex = <span class="string">&#x27;/^[1-9]+[0-9]*$/&#x27;</span>, space, n = <span class="number">0</span>;</span><br><span class="line">  num = num || ((num &gt; <span class="number">1</span> &amp;&amp; regex.test(num)) ? num : <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">&#x27;桶排序耗时&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">      min = min &lt;= array[i] ? min : array[i];</span><br><span class="line">      max = max &gt;= array[i] ? max : array[i];</span><br><span class="line">  &#125;</span><br><span class="line">  space = (max - min + <span class="number">1</span>) / num;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor((array[j] - min) / space);</span><br><span class="line">      <span class="keyword">if</span> (buckets[index]) &#123;   <span class="comment">//  非空桶，插入排序</span></span><br><span class="line">          <span class="keyword">var</span> k = buckets[index].length - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; buckets[index][k] &gt; array[j]) &#123;</span><br><span class="line">              buckets[index][k + <span class="number">1</span>] = buckets[index][k];</span><br><span class="line">              k--;</span><br><span class="line">          &#125;</span><br><span class="line">          buckets[index][k + <span class="number">1</span>] = array[j];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;    <span class="comment">//空桶，初始化</span></span><br><span class="line">          buckets[index] = [];</span><br><span class="line">          buckets[index].push(array[j]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (n &lt; num) &#123;</span><br><span class="line">      result = result.concat(buckets[n]);</span><br><span class="line">      n++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;桶排序耗时&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(bucketSort(arr,<span class="number">4</span>));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-桶排序图示"><a href="#4-桶排序图示" class="headerlink" title="4.桶排序图示"></a><strong>4.桶排序图示</strong></h3><p><img src="/images/tongpaixu.png" alt="tongpaixu"></p>
<h3 id="5-算法分析-8"><a href="#5-算法分析-8" class="headerlink" title="5.算法分析"></a><strong>5.算法分析</strong></h3><p>桶排序最好情况下使用线性时间O(n),桶排序的时间复杂度，取决于对各个桶之间数据进行排序的时间复杂度，因为其他部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的的空间消耗就会增大。</p>
<blockquote>
<p>最佳情况：T(n) = O(n + k)</p>
</blockquote>
<blockquote>
<p>最差情况：T(n) = O(n + k)</p>
</blockquote>
<blockquote>
<p>平均情况：T(n) = O(n2)</p>
</blockquote>
<h2 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a><strong>基数排序（Radix Sort）</strong></h2><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
<h3 id="1-算法简介-8"><a href="#1-算法简介-8" class="headerlink" title="1.算法简介"></a><strong>1.算法简介</strong></h3><p>基数排序时按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<h3 id="2-算法描述和实现-8"><a href="#2-算法描述和实现-8" class="headerlink" title="2.算法描述和实现"></a><strong>2.算法描述和实现</strong></h3><p>具体算法描述如下：</p>
<blockquote>
<p>1.取得数组中的最大数，并取得位数。</p>
</blockquote>
<blockquote>
<p>2.arr为原始数组，从最低位开始取每个位组成radix数组；</p>
</blockquote>
<blockquote>
<p>3.对radix进行计数排序（利用计数排序适用于小范围数的特点）</p>
</blockquote>
<h3 id="3-JavaScript代码实现-8"><a href="#3-JavaScript代码实现-8" class="headerlink" title="3.JavaScript代码实现"></a><strong>3.JavaScript代码实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  基数排序适用于：</span></span><br><span class="line"><span class="comment">    (1)数据范围比较小,建议小于1000</span></span><br><span class="line"><span class="comment">    (2)每个数值都要大于等于0</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  @param &#123;Array&#125; arr 待排序数组</span></span><br><span class="line"><span class="comment">  @param &#123;Number&#125; 最大位数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr, maxDigit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mod = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> dev = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> counter = [];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">&#x27;基数排序耗时&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxDigit; i++ , mod *= <span class="number">10</span>, dev *= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, len = arr.length; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">var</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;基数===&gt;&#x27;</span>, bucket);</span><br><span class="line">      <span class="keyword">if</span> (counter[bucket] == <span class="literal">null</span>) &#123;</span><br><span class="line">        counter[bucket] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      counter[bucket].push(arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第一次排序完成===&gt;&#x27;</span>, counter);</span><br><span class="line">    <span class="comment">// 将排序好的再次重整排列</span></span><br><span class="line">    <span class="keyword">var</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;counter[j] ===&gt;&#x27;</span>, <span class="string">&#x27;j===&gt;&#x27;</span>, j, counter[j]);</span><br><span class="line">      <span class="keyword">if</span> (counter[j] != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;</span><br><span class="line">          arr[pos++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第一次排序完成 arr ===&gt;&#x27;</span>, arr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;基数排序耗时&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(radixSort(arr, <span class="number">2</span>)); <span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-基数排序动图演示"><a href="#4-基数排序动图演示" class="headerlink" title="4.基数排序动图演示"></a><strong>4.基数排序动图演示</strong></h3><p><img src="/images/jjshupaixu.gif" alt="jishupaixu"></p>
<h3 id="5-算法分析-9"><a href="#5-算法分析-9" class="headerlink" title="5.算法分析"></a><strong>5.算法分析</strong></h3><blockquote>
<p>最佳情况：T(n) = O(n * k)</p>
</blockquote>
<blockquote>
<p>最差情况：T(n) = O(n * k)</p>
</blockquote>
<blockquote>
<p>平均情况：T(n) = O(n * k)</p>
</blockquote>
<p>基数排序有两种方法</p>
<blockquote>
<p>MSD从高位开始进行排序</p>
</blockquote>
<blockquote>
<p>LSD从低位开始进行排序</p>
</blockquote>
<h2 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a><strong>基数排序 vs 计数排序 vs 桶排序</strong></h2><p>这三种方法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<blockquote>
<p>1.基数排序：根据键值的每位数字来分配桶</p>
</blockquote>
<blockquote>
<p>2.计数排序：每个桶只存储单一键值</p>
</blockquote>
<blockquote>
<p>3.桶排序：每个桶存储一定范围的数值</p>
</blockquote>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2020/11/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nodejs-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="深入理解Nodejs进程与线程" class="prev">PREV</a><a href="/2020/10/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Enode%E7%8E%AF%E5%A2%83%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" title="浏览器与node环境的事件循环机制" class="next">NEXT</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2021 <a target="_blank">J.K</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz", "FdzS5SOPHdhYQoEUngQ8K2QW");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>