{"meta":{"title":"前端Store","subtitle":"","description":"","author":"J.K","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"正则表达式","slug":"正则表达式","date":"2021-04-07T07:31:46.000Z","updated":"2021-04-25T03:06:39.870Z","comments":true,"path":"2021/04/07/正则表达式/","link":"","permalink":"http://example.com/2021/04/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"1.元字符 字符 技能 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\\\‘ 匹配 “\\“ 而 “\\(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 \\n 或 \\r。要匹配 $ 字符本身，请使用 \\$。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。要匹配 * 字符，请使用 \\*。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。要匹配 + 字符，请使用 \\+。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。要匹配 ? 字符，请使用 \\?。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像”(. (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 ( (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”(?&lt;!95 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"ES6系列要点","slug":"ES6系列要点","date":"2021-03-30T01:36:32.000Z","updated":"2021-04-25T03:06:39.859Z","comments":true,"path":"2021/03/30/ES6系列要点/","link":"","permalink":"http://example.com/2021/03/30/ES6%E7%B3%BB%E5%88%97%E8%A6%81%E7%82%B9/","excerpt":"","text":"1.说说var、let、const之间的区别1.1 var在ES5中，顶层对象的属性和全局变量是等价的，用var声明的变量既是全局变量，也是顶层变量 注意：顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象 12var a = 10;console.log(window.a) // 10 使用var声明的变量存在变量提升的情况 12console.log(a) // undefinedvar a = 20 在编译阶段，编译器会将其变成以下执行 123var aconsole.log(a)a = 20 使用var，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明 123var a = 20var a = 30console.log(a) // 30 在函数中使用使用var声明变量时候，该变量是局部的 123456var a = 20function change()&#123; var a = 30&#125;change()console.log(a) // 20 而如果在函数内不使用var，该变量是全局的 123456var a = 20function change()&#123; a = 30&#125;change()console.log(a) // 30 1.2 letlet是ES6新增的命令，用来声明变量 用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效 1234&#123; let a = 20&#125;console.log(a) // ReferenceError: a is not defined. 不存在变量提升 123console.log(a) // 报错ReferenceErrorlet a = 2 这表示在声明它之前，变量a是不存在的，这时如果用到它，就会抛出一个错误 只要块级作用域内存在let命令，这个区域就不再受外部影响 12345var a = 123if (true) &#123; a = &#x27;abc&#x27; // ReferenceError let a;&#125; 使用let声明变量前，该变量都不可用，也就是大家常说的“暂时性死区” 最后，let不允许在相同作用域中重复声明 123let a = 20let a = 30// Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared 注意的是相同作用域，下面这种情况是不会报错的 1234let a = 20&#123; let a = 30&#125; 因此，我们不能在函数内部重新声明参数 12345function func(arg) &#123; let arg;&#125;func()// Uncaught SyntaxError: Identifier &#x27;arg&#x27; has already been declared 1.3 constconst声明一个只读的常量，一旦声明，常量的值就不能改变 123const a = 1a = 3// TypeError: Assignment to constant variable. 这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值 12const a;// SyntaxError: Missing initializer in const declaration 如果之前用var或let声明过变量，再用const声明同样会报错 12345var a = 20let b = 20const a = 30const b = 30// 都会报错 const实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动 对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量 对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的，并不能确保改变量的结构不变 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only 其它情况，const与let一致 1.4 区别var、let、const三者区别可以围绕下面五点展开： 变量提升 暂时性死区 块级作用域 重复声明 修改声明的变量 使用 变量提升 var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined let和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错 1234567891011// var console.log(a) // undefined var a = 10 // let console.log(b) // Cannot access &#x27;b&#x27; before initialization let b = 10 // const console.log(c) // Cannot access &#x27;c&#x27; before initialization const c = 10 暂时性死区 var不存在暂时性死区 let和const存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量 1234567891011// varconsole.log(a) // undefinedvar a = 10// letconsole.log(b) // Cannot access &#x27;b&#x27; before initializationlet b = 10// constconsole.log(c) // Cannot access &#x27;c&#x27; before initializationconst c = 10 块级作用域 var不存在块级作用域 let和const存在块级作用域 1234567891011121314151617// var&#123; var a = 20&#125;console.log(a) // 20// let&#123; let b = 20&#125;console.log(b) // Uncaught ReferenceError: b is not defined// const&#123; const c = 20&#125;console.log(c) // Uncaught ReferenceError: c is not defined 重复声明 var允许重复声明变量 let和const在同一作用域不允许重复声明变量 1234567891011// var var a = 10 var a = 20 // 20 // let let b = 10 let b = 20 // Identifier &#x27;b&#x27; has already been declared // const const c = 10 const c = 20 // Identifier &#x27;c&#x27; has already been declared 修改声明的变量 var和let可以 const声明一个只读的常量。一旦声明，常量的值就不能改变 1234567891011121314// varvar a = 10a = 20console.log(a) // 20//letlet b = 10b = 20console.log(b) // 20// constconst c = 10c = 20console.log(c) // Uncaught TypeError: Assignment to constant variable 使用 能用const的情况尽量使用const，其他情况下大多数使用let，避免使用var 2.ES6中数组新增了哪些扩展?2.1 扩展运算符的应用ES6通过扩展元素符…，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll(&#x27;div&#x27;)]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 主要用于函数调用的时候，将一个数组变为参数序列 12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42 可以将某些数据结构转为数组 1[...document.querySelectorAll(&#x27;div&#x27;)] 能够更简单实现数组复制 123const a1 = [1, 2];const [...a2] = a1;// [1,2] 数组的合并也更为简洁了 12345const arr1 = [&#x27;a&#x27;, &#x27;b&#x27;];const arr2 = [&#x27;c&#x27;];const arr3 = [&#x27;d&#x27;, &#x27;e&#x27;];[...arr1, ...arr2, ...arr3]// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ] 注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组 下面看个例子就清楚多了 12345const arr1 = [&#x27;a&#x27;, &#x27;b&#x27;,[1,2]];const arr2 = [&#x27;c&#x27;];const arr3 = [...arr1,...arr2]arr[1][0] = 9999 // 修改arr1里面数组成员值console.log(arr[3]) // 影响到arr3,[&#x27;a&#x27;,&#x27;b&#x27;,[9999,2],&#x27;c&#x27;] 扩展运算符可以与解构赋值结合起来，用于生成数组 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = [&quot;foo&quot;];first // &quot;foo&quot;rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错 12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 可以将字符串转为真正的数组 12[...&#x27;hello&#x27;]// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组 12345678910let nodeList = document.querySelectorAll(&#x27;div&#x27;);let array = [...nodeList];let map = new Map([ [1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;],]);let arr = [...map.keys()]; // [1, 2, 3] 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错 12const obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object 2.2 构造函数新增的方法关于构造函数，数组新增的方法有如下： Array.from() Array.of() Array.from() 将两类对象转为真正的数组：类似数组的对象和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map） 1234567let arrayLike = &#123; &#x27;0&#x27;: &#x27;a&#x27;, &#x27;1&#x27;: &#x27;b&#x27;, &#x27;2&#x27;: &#x27;c&#x27;, length: 3&#125;;let arr2 = Array.from(arrayLike); // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组 12Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] Array.of() 用于将一组值，转换为数组 1Array.of(3, 11, 8) // [3,11,8] 没有参数的时候，返回一个空数组 当参数只有一个的时候，实际上是指定数组的长度 参数个数不少于 2 个时，Array()才会返回由参数组成的新数组 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 2.3 实例对象新增的方法关于数组实例对象新增的方法有如下： copyWithin() find()、findIndex() fill() entries()，keys()，values() includes() flat()，flatMap() copyWithin() 将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组 参数如下： target（必需）：从该位置开始替换数据。如果为负值，表示倒数。start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 12[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2// [4, 5, 3, 4, 5] find()、findIndex() find()用于找出第一个符合条件的数组成员 参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 findIndex返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 12345function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: &#x27;John&#x27;, age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 fill() 使用给定值，填充一个数组 12345[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] 还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置 12[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7, 1, 2)// [&#x27;a&#x27;, 7, &#x27;c&#x27;] 注意，如果填充的类型为对象，则是浅拷贝 entries()，keys()，values() keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 12345678910111213141516for (let index of [&#x27;a&#x27;, &#x27;b&#x27;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&#x27;a&#x27;, &#x27;b&#x27;].values()) &#123; console.log(elem);&#125;// &#x27;a&#x27;// &#x27;b&#x27;for (let [index, elem] of [&#x27;a&#x27;, &#x27;b&#x27;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot; includes() 用于判断数组是否包含给定的值 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 方法的第二个参数表示搜索的起始位置，默认为0 参数为负数则表示倒数的位置 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true flat()，flatMap() 将数组扁平化处理，返回一个新数组，对原数据没有影响 12[1, 2, [3, 4]].flat()// [1, 2, 3, 4] flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1 12345[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5] flatMap()方法对原数组的每个成员执行一个函数相当于执行Array.prototype.map()，然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组 123// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8] flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this 2.4 数组的空位数组的空位指，数组的某一个位置没有任何值 ES6 则是明确将空位转为undefined，包括Array.from、扩展运算符、copyWithin()、fill()、entries()、keys()、values()、find()和findIndex() 建议大家在日常书写中，避免出现空位 2.5 排序稳定性将sort()默认设置为稳定的排序算法 1234567891011121314const arr = [ &#x27;peach&#x27;, &#x27;straw&#x27;, &#x27;apple&#x27;, &#x27;spork&#x27;];const stableSorting = (s1, s2) =&gt; &#123; if (s1[0] &lt; s2[0]) return -1; return 1;&#125;;arr.sort(stableSorting)// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;] 排序结果中，straw在spork的前面，跟原始顺序一致 3.ES6中对象新增了哪些扩展?3.1 属性的简写ES6中，当对象键名与对应值名相等的时候，可以进行简写 1234const baz = &#123;foo:foo&#125;// 等同于const baz = &#123;foo&#125; 方法也能够进行简写 12345678910111213const o = &#123; method() &#123; return &quot;Hello!&quot;; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return &quot;Hello!&quot;; &#125;&#125; 在函数内作为返回值，也会变得方便很多 12345678function getPoint() &#123; const x = 1; const y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; 注意：简写的对象方法不能用作构造函数，否则会报错 1234567const obj = &#123; f() &#123; this.foo = &#x27;bar&#x27;; &#125;&#125;;new obj.f() // 报错 3.2 属性名表达式ES6 允许字面量定义对象时，将表达式放在括号内 12345678910let lastWord = &#x27;last word&#x27;;const a = &#123; &#x27;first word&#x27;: &#x27;hello&#x27;, [lastWord]: &#x27;world&#x27;&#125;;a[&#x27;first word&#x27;] // &quot;hello&quot;a[lastWord] // &quot;world&quot;a[&#x27;last word&#x27;] // &quot;world&quot; 表达式还可以用于定义方法名 1234567let obj = &#123; [&#x27;h&#x27; + &#x27;ello&#x27;]() &#123; return &#x27;hi&#x27;; &#125;&#125;;obj.hello() // hi 注意，属性名表达式与简洁表示法，不能同时使用，会报错 12345678// 报错const foo = &#x27;bar&#x27;;const bar = &#x27;abc&#x27;;const baz = &#123; [foo] &#125;;// 正确const foo = &#x27;bar&#x27;;const baz = &#123; [foo]: &#x27;abc&#x27;&#125;; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object] 123456789const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: &#x27;valueA&#x27;, [keyB]: &#x27;valueB&#x27;&#125;;myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125; 3.3 super关键字this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象 12345678910111213const proto = &#123; foo: &#x27;hello&#x27;&#125;;const obj = &#123; foo: &#x27;world&#x27;, find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto); // 为obj设置原型对象obj.find() // &quot;hello&quot; 3.4 扩展运算符的应用在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 注意：解构赋值必须是最后一个参数，否则会报错 解构赋值是浅拷贝 1234let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2; // 修改obj里面a属性中键值x.a.b // 2，影响到了结构出来x的值 对象的扩展运算符等同于使用Object.assign()方法 3.5 属性的遍历ES6 一共有 5 种方法可以遍历对象的属性。 for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性） Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名 Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举 上述遍历，都遵守同样的属性遍历的次序规则： 首先遍历所有数值键，按照数值升序排列 其次遍历所有字符串键，按照加入时间升序排列 最后遍历所有 Symbol 键，按照加入时间升序排 12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()] 3.6 对象新增的方法关于对象新增的方法，分别有以下： Object.is() Object.assign() Object.getOwnPropertyDescriptors() Object.setPrototypeOf()，Object.getPrototypeOf() Object.keys()，Object.values()，Object.entries() Object.fromEntries() Object.is() 严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign() Object.assign()方法用于对象的合并，将源对象source的所有可枚举属性，复制到目标对象target Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象 1234567const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 注意：Object.assign()方法是浅拷贝，遇到同名属性会进行替换 Object.getOwnPropertyDescriptors() 返回指定对象所有自身属性（非继承属性）的描述对象 12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return &#x27;abc&#x27; &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: get bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; Object.setPrototypeOf() Object.setPrototypeOf方法用来设置一个对象的原型对象 1234Object.setPrototypeOf(object, prototype)// 用法const o = Object.setPrototypeOf(&#123;&#125;, null); Object.getPrototypeOf() 用于读取一个对象的原型对象 1Object.getPrototypeOf(obj); Object.keys() 返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组 123var obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;Object.keys(obj)// [&quot;foo&quot;, &quot;baz&quot;] Object.values() 返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组 123const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;Object.values(obj)// [&quot;bar&quot;, 42] Object.entries() 返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组 1234const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;Object.entries(obj)// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]Object.fromEntries() 用于将一个键值对数组转为对象 12345Object.fromEntries([ [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42]])// &#123; foo: &quot;bar&quot;, baz: 42 &#125; 4.ES6中函数新增了哪些扩展?4.1 参数ES6允许为函数的参数设置默认值 1234567function log(x, y = &#x27;World&#x27;) &#123; console.log(x, y);&#125;console.log(&#x27;Hello&#x27;) // Hello Worldconsole.log(&#x27;Hello&#x27;, &#x27;China&#x27;) // Hello Chinaconsole.log(&#x27;Hello&#x27;, &#x27;&#x27;) // Hello 函数的形参是默认声明的，不能使用let或const再次声明 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 参数默认值可以与解构赋值的默认值结合起来使用 12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property &#x27;x&#x27; of undefined 上面的foo函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量x和y就不会生成，从而报错，这里设置默认值避免 12345function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined 5 参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的 12345678function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined]f(, 1) // 报错f(undefined, 1) // [1, 1] 4.2 属性函数的length属性 length将返回没有指定默认值的参数个数 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 rest 参数也不会计入length属性 1(function(...args) &#123;&#125;).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了 12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 name属性 返回该函数的函数名 1234567var f = function () &#123;&#125;;// ES5f.name // &quot;&quot;// ES6f.name // &quot;f&quot; 如果将一个具名函数赋值给一个变量，则 name属性都返回这个具名函数原本的名字 12const bar = function baz() &#123;&#125;;bar.name // &quot;baz&quot; Function构造函数返回的函数实例，name属性的值为anonymous 1(new Function).name // &quot;anonymous&quot; bind返回的函数，name属性值会加上bound前缀 1234function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // &quot;bound foo&quot;(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot; 4.3 作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域 等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的 下面例子中，y=x会形成一个单独作用域，x没有被定义，所以指向全局变量x 123456789let x = 1;function f(y = x) &#123; // 等同于 let y = x let x = 2; console.log(y);&#125;f() // 1 4.4 严格模式只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错 12345678910111213141516171819202122232425// 报错function doSomething(a, b = a) &#123; &#x27;use strict&#x27;; // code&#125;// 报错const doSomething = function (&#123;a, b&#125;) &#123; &#x27;use strict&#x27;; // code&#125;;// 报错const doSomething = (...a) =&gt; &#123; &#x27;use strict&#x27;; // code&#125;;const obj = &#123; // 报错 doSomething(&#123;a, b&#125;) &#123; &#x27;use strict&#x27;; // code &#125;&#125;; 4.5 箭头函数使用“箭头”（=&gt;）定义函数 123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 如果返回对象，需要加括号将对象包裹 1let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); 注意点： 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替 不可以使用yield命令，因此箭头函数不能用作 Generator 函数 5.Set、Map两种数据结构怎么理解? Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构集合: 是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合字典: 是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同 共同点: 集合、字典都可以存储不重复的值不同点: 集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储 5.1 SetSet是es6新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合 Set本身是一个构造函数，用来生成 Set 数据结构 1const s = new Set(); 增删改查 Set的实例关于增删改查的方法： add() delete() has() clear() add() 添加某个值，返回 Set 结构本身 当添加实例中已经存在的元素，set不会进行处理添加 1s.add(1).add(2).add(2); // 2只被添加了一次 delete() 删除某个值，返回一个布尔值，表示删除是否成功 1s.delete(1) has() 返回一个布尔值，判断该值是否为Set的成员 1s.has(2) clear() 清除所有成员，没有返回值 1s.clear() 遍历 Set实例遍历的方法有如下： 关于遍历的方法，有如下： keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 Set的遍历顺序就是插入顺序 keys方法、values方法、entries方法返回的都是遍历器对象 12345678910111213141516171819202122let set = new Set([&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;] forEach()用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的forEach方法有第二个参数，用于绑定处理函数的this 12345let set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + &#x27; : &#x27; + value))// 1 : 1// 4 : 4// 9 : 9 扩展运算符和Set 结构相结合实现数组或字符串去重 1234567// 数组let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)]; // [3, 5, 2]// 字符串let str = &quot;352255&quot;;let unique = [...new Set(str)].join(&quot;&quot;); // &quot;&quot; 实现并集、交集、和差集 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// （a 相对于 b 的）差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; 5.2 MapMap类型是键值对的有序列表，而键和值都可以是任意类型 Map本身是一个构造函数，用来生成 Map 数据结构 1const m = new Map() 增删改查Map 结构的实例针对增删改查有以下属性和操作方法： size 属性 set() get() has() delete() clear() size size属性返回 Map 结构的成员总数。 12345const map = new Map();map.set(&#x27;foo&#x27;, true);map.set(&#x27;bar&#x27;, false);map.size // 2 set() 设置键名key对应的键值为value，然后返回整个 Map 结构 如果key已经有值，则键值会被更新，否则就新生成该键 同时返回的是当前Map对象，可采用链式写法 123456const m = new Map();m.set(&#x27;edition&#x27;, 6) // 键是字符串m.set(262, &#x27;standard&#x27;) // 键是数值m.set(undefined, &#x27;nah&#x27;) // 键是 undefinedm.set(1, &#x27;a&#x27;).set(2, &#x27;b&#x27;).set(3, &#x27;c&#x27;) // 链式操作 get() get方法读取key对应的键值，如果找不到key，返回undefined 123456const m = new Map();const hello = function() &#123;console.log(&#x27;hello&#x27;);&#125;;m.set(hello, &#x27;Hello ES6!&#x27;) // 键是函数m.get(hello) // Hello ES6! has() has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中 12345678910const m = new Map();m.set(&#x27;edition&#x27;, 6);m.set(262, &#x27;standard&#x27;);m.set(undefined, &#x27;nah&#x27;);m.has(&#x27;edition&#x27;) // truem.has(&#x27;years&#x27;) // falsem.has(262) // truem.has(undefined) // true delete() delete方法删除某个键，返回true。如果删除失败，返回false 123456const m = new Map();m.set(undefined, &#x27;nah&#x27;);m.has(undefined) // truem.delete(undefined)m.has(undefined) // false clear() clear方法清除所有成员，没有返回值 1234567let map = new Map();map.set(&#x27;foo&#x27;, true);map.set(&#x27;bar&#x27;, false);map.size // 2map.clear()map.size // 0 遍历 Map结构原生提供三个遍历器生成函数和一个遍历方法： keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回所有成员的遍历器 forEach()：遍历 Map 的所有成员 遍历顺序就是插入顺序 12345678910111213141516171819202122232425262728293031323334353637383940const map = new Map([ [&#x27;F&#x27;, &#x27;no&#x27;], [&#x27;T&#x27;, &#x27;yes&#x27;],]);for (let key of map.keys()) &#123; console.log(key);&#125;// &quot;F&quot;// &quot;T&quot;for (let value of map.values()) &#123; console.log(value);&#125;// &quot;no&quot;// &quot;yes&quot;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;map.forEach(function(value, key, map) &#123; console.log(&quot;Key: %s, Value: %s&quot;, key, value);&#125;); 5.3 WeakSet 和 WeakMapWeakSet 创建WeakSet实例 1const ws = new WeakSet(); WeakSet可以接受一个具有 Iterable接口的对象作为参数 123const a = [[1, 2], [3, 4]];const ws = new WeakSet(a);// WeakSet &#123;[1, 2], [3, 4]&#125; 在API中WeakSet与Set有两个区别： 没有遍历操作的API没有size属性 WeackSet只能成员只能是引用类型，而不能是其他类型的值 1234567891011let ws=new WeakSet();// 成员不是引用类型let weakSet=new WeakSet([2,3]);console.log(weakSet) // 报错// 成员为引用类型let obj1=&#123;name:1&#125;let obj2=&#123;name:1&#125;let ws=new WeakSet([obj1,obj2]); console.log(ws) //WeakSet &#123;&#123;…&#125;, &#123;…&#125;&#125; WeakSet里面的引用只要在外部消失，它在 WeakSet里面的引用就会自动消失 WeakMap WeakMap结构与Map结构类似，也是用于生成键值对的集合 在API中WeakMap与Map有两个区别： 没有遍历操作的API没有clear清空方法 123456789101112// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap();const key = &#123;foo: 1&#125;;wm1.set(key, 2);wm1.get(key) // 2// WeakMap 也可以接受一个数组，// 作为构造函数的参数const k1 = [1, 2, 3];const k2 = [4, 5, 6];const wm2 = new WeakMap([[k1, &#x27;foo&#x27;], [k2, &#x27;bar&#x27;]]);wm2.get(k2) // &quot;bar&quot; WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名 1234567const map = new WeakMap();map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map keymap.set(null, 2)// TypeError: Invalid value used as weak map key WeakMap的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用 举个场景例子： 在网页的 DOM 元素上添加数据，就可以使用WeakMap结构，当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除 123456const wm = new WeakMap();const element = document.getElementById(&#x27;example&#x27;);wm.set(element, &#x27;some information&#x27;);wm.get(element) // &quot;some information&quot; 注意：WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用 下面代码中，键值obj会在WeakMap产生新的引用，当你修改obj不会影响到内部 12345678const wm = new WeakMap();let key = &#123;&#125;;let obj = &#123;foo: 1&#125;;wm.set(key, obj);obj = null;wm.get(key)// Object &#123;foo: 1&#125; 6.怎么理解ES6中 Decorator 的？使用场景？Docorator修饰对象为下面两种： 类的装饰类属性的装饰 6.1 类的装饰当对类本身进行装饰的时候，能够接受一个参数，即类本身 将装饰器行为进行分解，大家能够有个更深入的了解 1234567@decoratorclass A &#123;&#125;// 等同于class A &#123;&#125;A = decorator(A) || A; 下面@testable就是一个装饰器，target就是传入的类，即MyTestableClass，实现了为类添加静态属性 12345678910@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123; target.isTestable = true;&#125;MyTestableClass.isTestable // true 如果想要传递参数，可以在装饰器外层再封装一层函数 12345678910111213function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; &#125;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false 6.2 类属性的装饰当对类属性进行装饰的时候，能够接受三个参数： 类的原型对象需要装饰的属性名装饰属性名的描述对象 首先定义一个readonly装饰器 1234function readonly(target, name, descriptor)&#123; descriptor.writable = false; // 将可写属性设为false return descriptor;&#125; 使用readonly装饰类的name方法 1234class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125; 相当于以下调用 1readonly(Person.prototype, &#x27;name&#x27;, descriptor); 如果一个方法有多个装饰器，就像洋葱一样，先从外到内进入，再由内到外执行 1234567891011121314function dec(id)&#123; console.log(&#x27;evaluated&#x27;, id); return (target, property, descriptor) =&gt;console.log(&#x27;executed&#x27;, id);&#125;class Example &#123; @dec(1) @dec(2) method()&#123;&#125;&#125;// evaluated 1// evaluated 2// executed 2// executed 1 外层装饰器@dec(1)先进入，但是内层装饰器@dec(2)先执行","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://example.com/tags/es6/"}]},{"title":"提升webpack打包速度的方法","slug":"提升webpack打包速度的方法","date":"2021-03-25T11:28:40.000Z","updated":"2021-04-25T03:06:39.870Z","comments":true,"path":"2021/03/25/提升webpack打包速度的方法/","link":"","permalink":"http://example.com/2021/03/25/%E6%8F%90%E5%8D%87webpack%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"1.跟上技术的迭代，尽可能使用新版本的webpack,node,npm, yarn2.在尽可能少的模块上应用loader 合理的使用include或者exclude可以降低loader的使用频率，提高打包速度 那么图片文件是否需要配置include或者exclude呢，实际上是不需要的，因为无论引入哪里的图片，实际上都需要url-loader来帮我们打包到dist目录下 123456789101112&#123; module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, include: path.resolve(__dirname,&#x27;../src&#x27;), loader: &#x27;babel-loader&#x27; &#125; ] &#125;&#125; 3.Plugin尽可能精简，并确保可靠 比如线上环境的配置文件中使用了optimize-css-assets-webpack-plugin这样一个插件，对我们的CSS文件进行了压缩，可是如果我们在开发环境下，是没有必要对代码进行压缩的。 4.resolve参数合理配置 引入一个模块的时候，省略这个模块的后缀 引入一个文件夹路径时, 自动匹配路径下的index文件或child文件，一般不建议配置; 虽然mainFiles配置解决了我们的问题，但是它也会带来性能上的问题，因为需要在路径下不停的去找我们配置的名字的文件是否匹配,所以一般情况下我们不会配置这个参数 设置路径别名; 当看到的是lee这个路径的时候，实际上它是path.resolve(__dirname, ‘../src/child’)这个路径的别名 123456789&#123; resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;], // 引入文件省略后缀 mainFiles: [&#x27;index&#x27;, &#x27;child&#x27;], // 引入路径，自动查找文件 alias: &#123; &#x27;@&#x27;: path.resolve(__dirname,&#x27;../src&#x27;) // 设置路径别名 &#125; &#125;&#125; 5.使用DLLPlugin提升打包速度 背景: 我们在引入第三方模块的时候，每次重新打包的时候，webpack都要重新分析这些第三方模块，然后把它们打包到我们的项目之中。 解决方案: 我们可以把这些第三方模块单独打包生成一个文件，只在第一次打包的时候去分析这个文件里的代码，之后再打包的时候，直接用这个分析过的结果就可以了，这是一个最理想的优化方式。 具体操作: 创建一个配置文件，姑且命名为webpack.dll.js 12345678910111213141516171819202122const path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; entry: &#123; vendors: [&#x27;vue&#x27;, &#x27;vue-router&#x27;, &#x27;vuex&#x27;] &#125;, output: &#123; filename: &#x27;[name].dll.js&#x27;, path: path.resolve(__dirname, &#x27;../dll&#x27;), // 打包生成了webpack.dll.js这个文件，通过一个全局变量暴露出来 library: &#x27;[name]&#x27; &#125;, plugins: [ // 用DllPlugin这个插件, 来分析上面生成的库文件 // 把库里一些第三方模块的映射关系，放到vendors.manifest.json文件中 new webpack.DllPlugin(&#123; name: &#x27;[name]&#x27;, // 要分析文件的名字，要跟库保持一致 path: path.resolve(__dirname, &#x27;../dll/[name].manifest.json&#x27;) &#125;) ]&#125; 然后再在package.json里再配置一个命令 12345&#123; &quot;scrtpts&quot;: &#123; &quot;build:dll&quot;: &quot;webpack --config ./webpack.dll.js&quot; &#125;&#125; 然后我们运行打包命令npm run build:dll把引入的三个模块，打包到了dll文件夹下的vendors.dll.js文件 然后再html中引入vendors.dll.js文件; 需要安装一个插件 npm install add-asset-html-webpack-plugin –save,这个插件的作用就是往html-webpack-plugin上再去增加一些静态的资源 结合全局变量和刚才生成的vendors.manifest.json文件, 对我们源代码进行分析，一旦分析出来，使用的模块内容，是在vendors.dll.js里，那么它就会直接去使用vendors.dll.js里的内容了，就不会去node_modules引入第三方模块了 1234567891011121314151617const addAssetHtmlWebpackPlugin = require(&#x27;add-asset-html-webpack-plugin&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; plugins: [ new addAssetHtmlWebpackPlugin(&#123; filePath: path.resolve(__dirname, &#x27;../dll/vendors.dll.js&#x27;) &#125;), // 使用DllReferencePlugin这个插件, 当去打包src下的index.js时候，会引入一些第三方的模块 // 当发现我们在引入一些第三方模块时，会到vendors.manifest.json去找第三方模块的映射关系 // 如果能找到映射关系，它就知道没必要再打包出来，直接从vendors.dll.js里拿过来用就可以了 // 它会从定义的全局变量中拿，但是如果发现引入的第三方模块不在映射关系里，才会到node_modules中拿过来打包 new webpack.DllReferencePlugin(&#123; manifest: path.resolve(__dirname, &#x27;../dll/vendors.manifest.json&#x27;) &#125;) ]&#125; 6.控制包文件的大小 一些用不到的包，要通过Tree Shaking去除掉 还可以通过splitchunksplugin这样的插件对代码进行拆分，把一个大的文件拆分成小的文件，进行webpack的打包处理，这样也可以提升webpack的打包速度 7.thread-loader,parallel-webpack,happypack 多进程进行打包 webpack默认是同构NodeJS来运行的，所以是一个单进程的打包过程，有时候，我们可以借助node里的多进程来帮助我们提升webpack的打包速度 8.合理使用 sourceMap 打包的时候，生成的sourceMap越详细，打包的速度就越慢，所以我们要思考，不同环境打包的时候，什么样的sourceMap是最合适的，既要保证我们及时发现代码里的问题。production模式下配置cheap-module-source-map;development模式下配置eval-cheap-module-source-map 9.开发环境内存编译 我们在开发环境的时候使用的是webpack dev server,它在做打包的时候，不会生成dist目录，他会把编译生成的内容放到内存里，内存的读取，肯定要比硬盘的读取快的多，所以通过这种手段，也可以让我们在开发的过程中，webpack的性能得到很大的提升 10.开发环境，无用插件剔除 比如项目调试的时候，我们并不需要对代码进行压缩，我们就应该把mode设置成development而不是production,如果开发环境下就压缩的话是没用意义的，这会降低webpack的打包速度","categories":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"Vue组件间通信方式","slug":"Vue组件间通信方式","date":"2021-03-24T08:28:36.000Z","updated":"2021-04-25T03:06:39.861Z","comments":true,"path":"2021/03/24/Vue组件间通信方式/","link":"","permalink":"http://example.com/2021/03/24/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","excerpt":"","text":"组件间通信的分类 父子组件之间的通信 兄弟组件之间的通信 祖孙与后代组件之间的通信 非关系组件间之间的通信 组件间通信的方案整理vue中8种常规的通信方案 通过 props 传递 通过 $emit 触发自定义事件 使用 ref EventBus parent 或 root attrs 与 listeners Provide 与 Inject Vuex 1.props传递数据 适用场景：父组件传递数据给子组件 子组件设置props属性，定义接收父组件传递过来的参数 父组件在使用子组件标签中通过字面量来传递值 Children.vue组件 1234567891011props:&#123; // 字符串形式 name:String // 接收的类型参数 // 对象形式 age:&#123; type:Number, // 接收的类型为数值 defaule:18, // 默认值为18 require:true // age属性必须传递 &#125;&#125; Father.vue组件 1&lt;Children name=&quot;jack&quot; age=18 /&gt; 2.$emit 触发自定义事件 适用场景：子组件传递数据给父组件 子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值 父组件绑定监听器获取到子组件传递过来的参数 Children.vue组件 1this.$emit(&#x27;add&#x27;, good) Father.vue组件 1&lt;Children @add=&quot;cartAdd($event)&quot; /&gt; 3.ref 父组件在使用子组件的时候设置ref 父组件通过设置子组件ref来获取数据 父组件 123&lt;Children ref=&quot;foo&quot; /&gt;this.$refs.foo // 获取子组件实例，通过子组件实例我们就能拿到对应的数据 4.EventBus 使用场景：兄弟组件传值 创建一个中央时间总线EventBus 兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值 另一个兄弟组件通过$on监听自定义事件 Bus.js 1234const vm = new Vue()vm.$on(&#x27;listener&#x27;, callback)vm.$emit(&#x27;listener&#x27;, data)vm.$off(&#x27;listener&#x27;, callback) 自定义Bus.js 123456789101112131415161718192021222324class Bus &#123; constructor() &#123; // 存放事件的名字 this.callbacks = &#123;&#125; &#125; $on(name, fn) &#123; this.callbacks[name] = this.callbacks[name] || [] this.callbacks[name].push(fn) &#125; $emit(name, args) &#123; if (this.callbacks[name]) &#123; this.callbacks[name].forEach(cb =&gt; cb(args)); &#125; &#125; $off(name, fn) &#123; if (this.callbacks[name]) &#123; let delIndex = this.callbacks[name].indexOf(fn) this.callbacks[name].splice(delIndex, 1) &#125; &#125;&#125; 5.parent或root通过共同祖辈$parent或者$root搭建通信侨联 1234567// 兄弟组件this.$parent.on(&#x27;add&#x27;,this.add)// 另一个兄弟组件this.$parent.emit(&#x27;add&#x27;)// 或者直接通过$parent.$refs访问另一个兄弟组件this.$parent.$refs.foo 6.attrs与listeners 适用场景：祖先传递数据给子孙 设置批量向下传属性$attrs和 $listeners 包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。 可以通过 v-bind=”$attrs” 传⼊内部组件 12345&lt;!-- child组件：并未在props中声明foo --&gt;&lt;p&gt;&#123;&#123;$attrs.foo&#125;&#125;&lt;/p&gt;&lt;!-- parent组件 --&gt;&lt;HelloWorld foo=&quot;foo&quot;/&gt; 12345678910&lt;!-- 给Grandson隔代传值 --&gt;&lt;Child msg=&quot;lalala&quot; @some-event=&quot;onSomeEvent&quot;&gt;&lt;/Child&gt;&lt;!-- 在Child组件中引用Grandson组件时直接做展开 --&gt;&lt;Grandson v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/Grandson&gt;&lt;!-- Grandson使⽤ --&gt;&lt;div @click=&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from grandson&#x27;)&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; 7.provide 与 inject 在祖先组件定义provide属性，返回传递的值 在后代组件通过inject接收组件传递过来的值 祖先组件 12345provide()&#123; return &#123; foo:&#x27;foo&#x27; &#125;&#125; 后代组件 1inject:[&#x27;foo&#x27;] // 获取到祖先组件传递过来的值 小结 父子关系的组件数据传递选择 props 与 $emit进行传递，也可选择ref 兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递 祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject 复杂关系的组件数据传递可以通过vuex存放共享的变量","categories":[{"name":"vue.js","slug":"vue-js","permalink":"http://example.com/categories/vue-js/"}],"tags":[{"name":"组件间通信","slug":"组件间通信","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/"}]},{"title":"自定义指令模拟v-model","slug":"自定义指令模拟v-model","date":"2021-03-23T09:50:07.000Z","updated":"2021-04-25T03:06:39.872Z","comments":true,"path":"2021/03/23/自定义指令模拟v-model/","link":"","permalink":"http://example.com/2021/03/23/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E6%A8%A1%E6%8B%9Fv-model/","excerpt":"","text":"钩子函数 钩子函数的参数 模拟实现123456789101112131415Vue.directive(&#x27;mymodel&#x27;, &#123; bind: function(el, binding, vnode) &#123; const vm = vnode.context const &#123; value, expression &#125; = binding el.value = value el.addEventListener(&#x27;input&#x27;, e =&gt; &#123; vm[expression] = e.target.value &#125;) &#125;, // 当数据被更新的时候，需要更新指令绑定的元素 update: function(el, binding) &#123; const &#123; value &#125; = binding el.value = value &#125;&#125;)","categories":[{"name":"vue.js","slug":"vue-js","permalink":"http://example.com/categories/vue-js/"}],"tags":[{"name":"指令","slug":"指令","permalink":"http://example.com/tags/%E6%8C%87%E4%BB%A4/"}]},{"title":"Vue项目性能优化","slug":"Vue项目性能优化","date":"2021-03-17T05:46:38.000Z","updated":"2021-04-25T03:06:39.862Z","comments":true,"path":"2021/03/17/Vue项目性能优化/","link":"","permalink":"http://example.com/2021/03/17/Vue%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"Vue项目优化, 以下三部分组成: 基础的 Web 技术层面的优化。 webpack 配置层面的优化； Vue 代码层面的优化； 一.基础的 Web 技术优化1.开启 gzip 压缩gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。 目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右 2.浏览器缓存为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强缓存，协商缓存） 3.CDN 的使用浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。 4.使用 Chrome Performance 查找性能瓶颈window.performance是W3C性能小组引入的新的API，目前IE9以上的浏览器都支持。 字段说明: connectStart 和 connectEnd: 分别代表TCP建立连接和连接成功的时间节点。 domComplete：html文档完全解析完毕的时间节点。 domContentLoadedEventStart 和 domContentLoadedEventEnd：代表DOMContentLoaded事件触发和完成的时间节点。页面文档完全加载并解析完毕之后,会触发DOMContentLoaded事件，HTML文档不会等待样式文件,图片文件,子框架页面的加载(load事件可以用来检测HTML页面是否完全加载完毕(fully-loaded))。 domInteractive：代表浏览器解析html文档的状态为interactive时的时间节点。domInteractive并非DOMReady，它早于DOMReady触发，代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点。 domLoading：代表浏览器开始解析html文档的时间节点。我们知道IE浏览器下的document有readyState属性，domLoading的值就等于readyState改变为loading的时间节点。 domainLookupStart 和 domainLookupEnd：分别代表DNS查询的开始和结束时间节点。如果浏览器没有进行DNS查询（比如使用了cache），则两者的值都等于fetchStart。 fetchStart：是指在浏览器发起任何请求之前的时间值。在fetchStart和domainLookupStart之间，浏览器会检查当前文档的缓存。 loadEventStart 和 loadEventEnd：分别代表onload事件触发和结束的时间节点。 navigationStart：代表浏览器开始unload前一个页面文档的开始时间节点。比如我们当前正在浏览baidu.com，在地址栏输入google.com并回车，浏览器的执行动作依次为：unload当前文档（即baidu.com）-&gt;请求下一文档（即google.com）。navigationStart的值便是触发unload当前文档的时间节点。 redirectStart 和 redirectEnd：如果页面是由redirect而来，则redirectStart和redirectEnd分别代表redirect开始和结束的时间节点。 requestStart：代表浏览器发起请求的时间节点，请求的方式可以是请求服务器、缓存、本地资源等。 responseStart 和 responseEnd：分别代表浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻。 secureConnectionStart：可选。如果页面使用HTTPS，它的值是安全连接握手之前的时刻。如果该属性不可用，则返回undefined。如果该属性可用，但没有使用HTTPS，则返回0。 unloadEventStart 和 unloadEventEnd：如果前一个文档和请求的文档是同一个域的，则unloadEventStart和unloadEventEnd分别代表浏览器unload前一个文档的开始和结束时间节点。否则两者都等于0。 主要性能指标： DNS查询耗时 = domainLookupEnd - domainLookupStart TCP链接耗时 = connectEnd - connectStart request请求耗时 = responseEnd - responseStart 解析dom树耗时 = domComplete - domInteractive 白屏时间 = domLoading - fetchStart domready时间 = domContentLoadedEventEnd - fetchStart onload时间 = loadEventEnd - fetchStart 二.Webpack 层面的优化1 Webpack 对图片进行压缩在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。 所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片： 首先，安装 image-webpack-loader: 1npm install image-webpack-loader --save-dev 然后，在 webpack.base.conf.js 中进行配置： 123456789101112131415161718&#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use:[ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 10000, name: utils.assetsPath(&#x27;img/[name].[hash:7].[ext]&#x27;) &#125; &#125;, &#123; loader: &#x27;image-webpack-loader&#x27;, options: &#123; bypassOnDebug: true, &#125; &#125; ]&#125; 2.减少 ES6 转为 ES5 的冗余代码Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码： 1class HelloWebpack extends Component&#123;...&#125; 这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数： 12babel-runtime&#x2F;helpers&#x2F;createClass &#x2F;&#x2F; 用于实现 class 语法babel-runtime&#x2F;helpers&#x2F;inherits &#x2F;&#x2F; 用于实现 extends 语法 在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。 为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime/helpers/createClass’) 的方式导入，这样就能做到只让它们出现一次。 babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。 首先，安装 babel-plugin-transform-runtime ： 1npm install babel-plugin-transform-runtime --save-dev 然后，修改 .babelrc 配置文件为： 123&quot;plugins&quot;: [ &quot;transform-runtime&quot;] 3.提取公共代码如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题： 相同的资源被重复加载，浪费用户的流量和服务器的成本。 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。 所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下： 123456789101112131415161718// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。new webpack.optimize.CommonsChunkPlugin(&#123; name: &#x27;vendor&#x27;, minChunks: function(module, count) &#123; return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &#x27;../node_modules&#x27;) ) === 0 ); &#125;&#125;),// 抽取出代码模块的映射关系new webpack.optimize.CommonsChunkPlugin(&#123; name: &#x27;manifest&#x27;, chunks: [&#x27;vendor&#x27;]&#125;) 4.模板预编译当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。 预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。 如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。 5.提取组件的 CSS当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。 将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。 6.优化 SourceMap我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别， 当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。 SourceMap 的可选值如下（+ 号越多，代表速度越快，- 号越多，代表速度越慢, o 代表中等速度 ） 开发环境推荐：cheap-module-eval-source-map 生产环境推荐：cheap-module-source-map 原因如下： cheap：源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息； module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置； soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性； eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。 7.构建结果输出分析Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。 为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。 接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。 我们在项目中 webpack.prod.conf.js 进行配置： 1234if (config.build.bundleAnalyzerReport) &#123; var BundleAnalyzerPlugin = require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPlugin; webpackConfig.plugins.push(new BundleAnalyzerPlugin());&#125; 执行 $ npm run build --report 后生成分析报告： 8.Vue 项目的编译优化如果你的 Vue 项目使用 Webpack 编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的 Webpack 配置进行优化，提高 Webpack 的构建效率。 Vue 代码层面的优化1.v-if 和 v-show 区分使用场景2.computed 和 watch 区分使用场景computed：是计算属性，依赖其它属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 3.v-for 遍历必须为 item 添加 key，且避免同时使用 v-if v-for 遍历必须为 item 添加 key在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。 v-for 遍历避免同时使用 v-ifv-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。 4.路由懒加载Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。 如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。 5.第三方插件的按需引入我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例： 首先，安装 babel-plugin-component ： 1npm install babel-plugin-component -D 然后，将 .babelrc 修改为： 123456789101112&#123; &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]], &quot;plugins&quot;: [ [ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] ]&#125; 3.在 main.js 中引入部分组件： 12345import Vue from &#x27;vue&#x27;;import &#123; Button, Select &#125; from &#x27;element-ui&#x27;;Vue.use(Button)Vue.use(Select)","categories":[{"name":"性能优化","slug":"性能优化","permalink":"http://example.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"前端常见跨域解决方案","slug":"前端常见跨域解决方案","date":"2021-03-17T02:08:26.000Z","updated":"2021-04-25T03:06:39.869Z","comments":true,"path":"2021/03/17/前端常见跨域解决方案/","link":"","permalink":"http://example.com/2021/03/17/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"什么是跨域？跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 什么是同源策略？ 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口“三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送 常见跨域场景1234567891011121314151617181920URL 说明 是否允许通信http:&#x2F;&#x2F;www.domain.com&#x2F;a.jshttp:&#x2F;&#x2F;www.domain.com&#x2F;b.js 同一域名，不同文件或路径 允许http:&#x2F;&#x2F;www.domain.com&#x2F;lab&#x2F;c.jshttp:&#x2F;&#x2F;www.domain.com:8000&#x2F;a.jshttp:&#x2F;&#x2F;www.domain.com&#x2F;b.js 同一域名，不同端口 不允许 http:&#x2F;&#x2F;www.domain.com&#x2F;a.jshttps:&#x2F;&#x2F;www.domain.com&#x2F;b.js 同一域名，不同协议 不允许 http:&#x2F;&#x2F;www.domain.com&#x2F;a.jshttp:&#x2F;&#x2F;192.168.4.12&#x2F;b.js 域名和域名对应相同ip 不允许 http:&#x2F;&#x2F;www.domain.com&#x2F;a.jshttp:&#x2F;&#x2F;x.domain.com&#x2F;b.js 主域相同，子域不同 不允许http:&#x2F;&#x2F;domain.com&#x2F;c.js http:&#x2F;&#x2F;www.domain1.com&#x2F;a.jshttp:&#x2F;&#x2F;www.domain2.com&#x2F;b.js 不同域名 不允许 跨域解决方案 1.通过jsonp跨域2.document.domain + iframe跨域3.location.hash + iframe4.window.name + iframe跨域5.postMessage跨域6.跨域资源共享（CORS）7.nginx代理跨域8.nodejs中间件代理跨域9.WebSocket协议跨域 1.通过jsonp跨域1.原生实现 123456789101112131415// 客户端var script = document.createElement(&#x27;script&#x27;);script.type = &#x27;text/javascript&#x27;;// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数script.src = &#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;;document.head.appendChild(script);// 回调执行函数function handleCallback(res) &#123; alert(JSON.stringify(res));&#125;// 服务端返回handleCallback(&#123;&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;) 2.jquery ajax 1234567$.ajax(&#123; url: &#x27;http://www.domain2.com:8080/login&#x27;, type: &#x27;get&#x27;, dataType: &#x27;jsonp&#x27;, // 请求方式为jsonp jsonpCallback: &quot;handleCallback&quot;, // 自定义回调函数名 data: &#123;&#125;&#125;); jsonp缺点：只能实现get一种请求。 2.document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1.父窗口：(http://www.domain.com/a.html) 12345&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = &#x27;domain.com&#x27;; var user = &#x27;admin&#x27;;&lt;/script&gt; 2.子窗口：(http://child.domain.com/b.html) 12345&lt;script&gt; document.domain = &#x27;domain.com&#x27;; // 获取父窗口中变量 alert(&#x27;get js data from parent ---&gt; &#x27; + window.parent.user);&lt;/script&gt; 3.location.hash + iframe跨域实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 1.a.html：(http://www.domain1.com/a.html) 1234567891011121314&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById(&#x27;iframe&#x27;); // 向b.html传hash值 setTimeout(function() &#123; iframe.src = iframe.src + &#x27;#user=admin&#x27;; &#125;, 1000); // 开放给同域c.html的回调方法 function onCallback(res) &#123; alert(&#x27;data from c.html ---&gt; &#x27; + res); &#125;&lt;/script&gt; 2.b.html：(http://www.domain2.com/b.html) 123456789&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById(&#x27;iframe&#x27;); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () &#123; iframe.src = iframe.src + location.hash; &#125;;&lt;/script&gt; 3.c.html：(http://www.domain1.com/c.html) 1234567&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () &#123; // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback(&#x27;hello: &#x27; + location.hash.replace(&#x27;#user=&#x27;, &#x27;&#x27;)); &#125;;&lt;/script&gt; 4.window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 1.a.html：(http://www.domain1.com/a.html) 1234567891011121314151617181920212223242526272829303132333435363738var proxy = function(url, callback) &#123; var state = 0; var iframe = document.createElement(&#x27;iframe&#x27;); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name // IE Firefox仅触发1次，Chrome Safari Opera会触发2次 // Chrome Safari Opera 浏览器中当 IFRAME 标记被插入文档树后，载入&quot;about:blank&quot; 页面速度非常快立即就触发了 load 事件，以至于还没来得及执行为他指定新 URL 的语句；当新 URL 指定后，当前页面加载完成时又触发了一次 IFRAME 标记的 load 事件，这样总共就触发了两次。 // 而IE Firefox等其他浏览器则是载入 &quot;about:blank&quot; 页花费时间加多，页面并未完全加载时其 URL 已经被改变，因此相对 Chrome Safari Opera 浏览器第一次 load 事件并没有触发，只有等新 URL 中的页面加载完毕后 load 事件才被触发，这样总共只触发了一次。 iframe.onload = function() &#123; if (state === 1) &#123; // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); &#125; else if (state === 0) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = &#x27;http://www.domain1.com/proxy.html&#x27;; state = 1; &#125; &#125;; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() &#123; iframe.contentWindow.document.write(&#x27;&#x27;); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;&#125;;// 请求跨域b页面数据proxy(&#x27;http://www.domain2.com/b.html&#x27;, function(data)&#123; alert(data);&#125;); 2.proxy.html：(http://www.domain1.com/proxy.html) 中间代理页，与a.html同域，内容为空即可。 3.b.html：(http://www.domain2.com/b.html) 123&lt;script&gt; window.name = &#x27;This is domain2 data!&#x27;;&lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 5.postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数 data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。 origin： 协议+主机+端口号，可以设置为”*”，表示可以传递给任意窗口; 如果要指定和当前窗口同源的话设置为”/“。 1.a.html：(http://www.domain1.com/a.html) 12345678910111213141516&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById(&#x27;iframe&#x27;); iframe.onload = function() &#123; var data = &#123; name: &#x27;aym&#x27; &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), &#x27;http://www.domain2.com&#x27;); &#125;; // 接受domain2返回数据 window.addEventListener(&#x27;message&#x27;, function(e) &#123; alert(&#x27;data from domain2 ---&gt; &#x27; + e.data); &#125;, false);&lt;/script&gt; 2.b.html：(http://www.domain2.com/b.html) 1234567891011121314&lt;script&gt; // 接收domain1的数据 window.addEventListener(&#x27;message&#x27;, function(e) &#123; alert(&#x27;data from domain1 ---&gt; &#x27; + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), &#x27;http://www.domain1.com&#x27;); &#125; &#125;, false);&lt;/script&gt; 6.跨域资源共享（CORS）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 1.前端设置 原生ajax 12&#x2F;&#x2F; 前端设置是否带cookiexhr.withCredentials &#x3D; true; 示例代码： 1234567891011121314var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open(&#x27;post&#x27;, &#x27;http://www.domain2.com:8080/login&#x27;, true);xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);xhr.send(&#x27;user=admin&#x27;);xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;; axios设置 1axios.defaults.withCredentials = true 2.服务端设置 若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。 nodejs设置 12345678910111213// 跨域后台设置res.writeHead(200, &#123; // 后端允许发送Cookie &#x27;Access-Control-Allow-Credentials&#x27;: &#x27;true&#x27;, // 允许访问的域（协议+域名+端口） &#x27;Access-Control-Allow-Origin&#x27;: &#x27;http://www.domain1.com&#x27;, // 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， // 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 // HttpOnly的作用是让js无法读取cookie &#x27;Set-Cookie&#x27;: &#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;&#125;); 7.nginx代理跨域8.Nodejs中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 9.WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 1.前端代码 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var socket = io(&#x27;http://www.domain2.com:8080&#x27;); // 连接成功处理 socket.on(&#x27;connect&#x27;, function() &#123; // 监听服务端消息 socket.on(&#x27;message&#x27;, function(msg) &#123; console.log(&#x27;data from server: ---&gt; &#x27; + msg); &#125;); // 监听服务端关闭 socket.on(&#x27;disconnect&#x27;, function() &#123; console.log(&#x27;Server socket has closed.&#x27;); &#125;); &#125;); document.getElementsByTagName(&#x27;input&#x27;)[0].onblur = function() &#123; socket.send(this.value); &#125;;&lt;/script&gt; 2.Nodejs socket后台： 123456789101112131415161718192021222324252627var http = require(&#x27;http&#x27;);var socket = require(&#x27;socket.io&#x27;);// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; &#x27;Content-type&#x27;: &#x27;text/html&#x27; &#125;); res.end();&#125;);server.listen(&#x27;8080&#x27;);console.log(&#x27;Server is running at port 8080...&#x27;);// 监听socket连接socket.listen(server).on(&#x27;connection&#x27;, function(client) &#123; // 接收信息 client.on(&#x27;message&#x27;, function(msg) &#123; client.send(&#x27;hello：&#x27; + msg); console.log(&#x27;data from client: ---&gt; &#x27; + msg); &#125;); // 断开处理 client.on(&#x27;disconnect&#x27;, function() &#123; console.log(&#x27;Client socket has closed.&#x27;); &#125;);&#125;);","categories":[{"name":"浏览器特性","slug":"浏览器特性","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://example.com/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"javascript中的call和apply和bind","slug":"javascript中的call和apply和bind","date":"2021-03-12T08:35:55.000Z","updated":"2021-04-25T03:06:39.864Z","comments":true,"path":"2021/03/12/javascript中的call和apply和bind/","link":"","permalink":"http://example.com/2021/03/12/javascript%E4%B8%AD%E7%9A%84call%E5%92%8Capply%E5%92%8Cbind/","excerpt":"","text":"call,apply,bind的基本介绍语法: 123fun.call(thisArg, param1, param2, ...)fun.apply(thisArg, [param1,param2,...])fun.bind(thisArg, param1, param2, ...) 返回值: call/apply：fun执行的结果bind：返回fun的拷贝，并拥有指定的this值和初始参数 参数: thisArg(可选) fun的this指向thisArg对象 非严格模式下：thisArg指定为null，undefined，fun中的this指向window对象. 严格模式下：fun的this为undefined 值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象，如 String、Number、Boolean param1,param2(可选): 传给fun的参数。 如果param不传或为 null/undefined，则表示不需要传入任何参数. apply第二个参数为数组，数组内的值为传给fun的参数。 调用call/apply/bind的必须是个函数 call、apply和bind是挂在Function对象上的三个方法,只有函数才有这些方法。 只要是函数就可以，比如: Object.prototype.toString就是个函数，我们经常看到这样的用法：Object.prototype.toString.call(data) 区别： call与apply的唯一区别 传给fun的参数写法不同： apply是第2个参数，这个参数是一个数组：传给fun参数都写在数组中。 call从第2~n的参数都是传给fun的。 call/apply与bind的区别 执行： call/apply改变了函数的this上下文后马上执行该函数 bind则是返回改变了上下文后的函数,不执行该函数 返回值: call/apply 返回fun的执行结果 bind返回fun的拷贝，并指定了fun的this指向，保存了fun的参数。 bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Function.prototype.myCall = function(context, ...args) &#123; // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象 context = (context === null || context === undefined) ? window : Object(context); // 用于临时储存函数 const specialPrototype = Symbol(&#x27;唯一性&#x27;); // 函数的this指向隐式绑定到context上 context[specialPrototype] = this; // 通过隐式绑定执行函数并传递参数 let res = context[specialPrototype](...args); // 删除上下文对象的属性 delete context[specialPrototype]; // 返回函数执行结果 return res;&#125;Function.prototype.myApply = function(context) &#123; context = (context === null || context === undefined) ? window : Object(context) function isArrayLike(o) &#123; if (o &amp;&amp; // o不是null、undefined等 typeof o === &#x27;object&#x27; &amp;&amp; // o是对象 isFinite(o.length) &amp;&amp; // o.length是有限数值 o.length &gt;= 0 &amp;&amp; // o.length为非负值 o.length === Math.floor(o.length) &amp;&amp; // o.length是整数 o.length &lt; 4294967296 // o.length &lt; 2^32 ) &#123; return true; &#125; return false; &#125; const specialPrototype = Symbol(&#x27;唯一性&#x27;); context[specialPrototype] = this; let args = arguments[1]; let res; if (args) &#123; if (!Array.isArray(args) &amp;&amp; !isArrayLike(args)) &#123; throw new TypeError(&#x27;myApply 第二个参数不为数组并且不为类数组对象抛出错误&#x27;); &#125; else &#123; // 执行函数并展开数组，传递函数参数 res = context[specialPrototype](...args); &#125; &#125; else &#123; res = context[specialPrototype](); &#125; delete context[specialPrototype]; return res;&#125;Function.prototype.myBind = function() &#123; let thisfn = this; let context = [].shift.call(arguments); let args = [].slice.call(arguments); return function() &#123; let _args = [].slice.call(arguments); [].push.call(args, ..._args); thisfn.call(context, ...args) &#125;&#125; apply、call在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。 1234567891011function fruits() &#123;&#125;fruits.prototype = &#123; color: &quot;red&quot;, say: function() &#123; console.log(&quot;My color is &quot; + this.color); &#125;&#125;var apple = new fruits;apple.say(); //My color is red 但是如果我们有一个对象 banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法： 12345banana = &#123; color: &quot;yellow&quot;&#125;apple.say.call(banana); //My color is yellowapple.say.apply(banana); //My color is yellow 所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中banana没有say方法），但是其他的有（本栗子中apple有say方法），我们可以借助call 或 apply用其它对象的方法来操作。 apply、call 区别对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下： 123456var func = function(arg1, arg2) &#123; &#125;;// 就可以通过如下方式来调用:func.call(this, arg1, arg2);func.apply(this, [arg1, arg2]) 其中 this 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 为了巩固加深记忆，下面列举一些常用用法： apply、call实例数组之间追加123456var array1 = [12 , &quot;foo&quot; , &#123;name:&quot;Joe&quot;&#125; , -2458]; var array2 = [&quot;Doe&quot; , 555 , 100];Array.prototype.push.apply(array1, array2); // array1 值为 [12 , &quot;foo&quot; , &#123;name:&quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100] 获取数组中的最大值和最小值12345var numbers = [5, 458 , 120 , -215 ];var maxInNumbers = Math.max.apply(Math, numbers); //458var maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458 number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。 验证是否是数组（前提是toString()方法没有被重写过）123functionisArray(obj)&#123; return Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27; ;&#125; 类（伪）数组使用数组方法1var domNodes = Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;)); Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。 bind在讨论bind()方法之前我们先来看一道题目： 12var altwrite = document.write;altwrite(&quot;hello&quot;); 结果：Uncaught TypeError: Illegal invocationaltwrite()函数改变this的指向global或window对象，导致执行时提示非法调用异常，正确的方案就是使用bind()方法： 1altwrite.bind(document)(&quot;hello&quot;) 当然也可以使用call()方法： 1altwrite.call(document, &quot;hello&quot;) 绑定函数bind()最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。常见的错误就像上面的例子一样，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。如果不做特殊处理，一般会丢失原来的对象。使用bind()方法能够很漂亮的解决这个问题： 123456789101112131415this.num = 9; var mymodule = &#123; num: 81, getNum: function() &#123; console.log(this.num); &#125;&#125;;mymodule.getNum(); // 81var getNum = mymodule.getNum;getNum(); // 9, 因为在这个例子中，&quot;this&quot;指向全局对象var boundGetNum = getNum.bind(mymodule);boundGetNum(); // 81 bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。 MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 像这样： 12345678910var foo = &#123; bar : 1, eventBind: function()&#123; var _this = this; $(&#x27;.someClass&#x27;).on(&#x27;click&#x27;,function(event) &#123; /* Act on the event */ console.log(_this.bar); //1 &#125;); &#125;&#125; 由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题： 123456789var foo = &#123; bar : 1, eventBind: function()&#123; $(&#x27;.someClass&#x27;).on(&#x27;click&#x27;,function(event) &#123; /* Act on the event */ console.log(this.bar); //1 &#125;.bind(this)); &#125;&#125; 在上述代码里，bind() 创建了一个函数，当这个click事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用bind()时传入的参数）。因此，这里我们传入想要的上下文 this(其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向 foo 对象。再来一个简单的栗子： 123456789var bar = function()&#123; console.log(this.x);&#125;var foo = &#123; x:3&#125;bar(); // undefinedvar func = bar.bind(foo);func(); // 3 这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。 偏函数（Partial Functions）这是一个很好的特性，使用bind()我们设定函数的预定义参数，然后调用的时候传入其他参数即可： 1234567891011function list() &#123; return Array.prototype.slice.call(arguments);&#125;var list1 = list(1, 2, 3); // [1, 2, 3]// 预定义参数37var leadingThirtysevenList = list.bind(undefined, 37);var list2 = leadingThirtysevenList(); // [37]var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3] 和setTimeout一起使用123456789101112131415function Bloomer() &#123; this.petalCount = Math.ceil(Math.random() * 12) + 1;&#125;// 1秒后调用declare函数Bloomer.prototype.bloom = function() &#123; window.setTimeout(this.declare.bind(this), 100);&#125;;Bloomer.prototype.declare = function() &#123; console.log(&#x27;我有 &#x27; + this.petalCount + &#x27; 朵花瓣!&#x27;);&#125;;var bloo = new Bloomer();bloo.bloom(); //我有 5 朵花瓣! 注意：对于事件处理函数和setInterval方法也可以使用上面的方法 绑定函数作为构造函数绑定函数也适用于使用new操作符来构造目标函数的实例。当使用绑定函数来构造实例，注意：this会被忽略，但是传入的参数仍然可用。 12345678910111213141516171819202122232425function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function() &#123; console.log(this.x + &#x27;,&#x27; + this.y);&#125;;var p = new Point(1, 2);p.toString(); // &#x27;1,2&#x27;var emptyObj = &#123;&#125;;var YAxisPoint = Point.bind(emptyObj, 0/*x*/);// 实现中的例子不支持,// 原生bind支持:var YAxisPoint = Point.bind(null, 0/*x*/);var axisPoint = new YAxisPoint(5);axisPoint.toString(); // &#x27;0,5&#x27;axisPoint instanceof Point; // trueaxisPoint instanceof YAxisPoint; // truenew Point(17, 42) instanceof YAxisPoint; // true 实现上面的几个小节可以看出bind()有很多的使用场景，但是bind()函数是在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。这就需要我们自己实现bind()函数了。 首先我们可以通过给目标函数指定作用域来简单实现bind()方法： 123456Function.prototype.bind = function(context)&#123; self = this; //保存this，即调用bind方法的目标函数 return function()&#123; return self.apply(context,arguments); &#125;;&#125;; 考虑到函数柯里化的情况，我们可以构建一个更加健壮的bind()： 123456789Function.prototype.bind = function(context)&#123; var args = Array.prototype.slice.call(arguments, 1), self = this; return function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return self.apply(context,finalArgs); &#125;;&#125;; 这次的bind()方法可以绑定对象，也支持在绑定的时候传参。 继续，Javascript的函数还可以作为构造函数，那么绑定后的函数用这种方式调用时，情况就比较微妙了，需要涉及到原型链的传递： 1234567891011121314Function.prototype.bind = function(context)&#123; var args = Array.prototype.slice(arguments, 1), F = function()&#123;&#125;, self = this, bound = function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return self.apply((this instanceof F ? this : context), finalArgs); &#125;; F.prototype = self.prototype; bound.prototype = new F(); return bound;&#125;; 这是《JavaScript Web Application》一书中对bind()的实现：通过设置一个中转构造函数F，使绑定后的函数与调用bind()的函数处于同一原型链上，用new操作符调用绑定后的函数，返回的对象也能正常使用instanceof，因此这是最严谨的bind()实现。 对于为了在浏览器中能支持bind()函数，只需要对上述函数稍微修改即可： 1234567891011121314151617181920Function.prototype.bind = function (oThis) &#123; if (typeof this !== &quot;function&quot;) &#123; throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; return fToBind.apply( this instanceof fNOP &amp;&amp; oThis ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments)) ); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125;; 有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样： 1234567891011121314151617var bar = function()&#123; console.log(this.x);&#125;var foo = &#123; x:3&#125;var sed = &#123; x:4&#125;var func = bar.bind(foo).bind(sed);func(); //?var fiv = &#123; x:5&#125;var func = bar.bind(foo).bind(sed).bind(fiv);func(); //? 答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在Javascript中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。 apply、call、bind比较那么 apply、call、bind 三者相比较，之间又有什么异同呢？何时使用 apply、call，何时使用 bind 呢。简单的一个栗子： 12345678910111213var obj = &#123; x: 81,&#125;;var foo = &#123; getX: function() &#123; return this.x; &#125;&#125;console.log(foo.getX.bind(obj)()); //81console.log(foo.getX.call(obj)); //81console.log(foo.getX.apply(obj)); //81 三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。 也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。 再总结一下： apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；apply 、 call 、bind 三者都可以利用后续参数传参；bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"call和apply和bind","slug":"call和apply和bind","permalink":"http://example.com/tags/call%E5%92%8Capply%E5%92%8Cbind/"}]},{"title":"前端模块化的理解","slug":"前端模块化的理解","date":"2021-03-11T03:08:39.000Z","updated":"2021-04-25T03:06:39.869Z","comments":true,"path":"2021/03/11/前端模块化的理解/","link":"","permalink":"http://example.com/2021/03/11/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"模块的定义:可以理解成实现特定功能的相互独立的一组方法 为什么要使用模块化: 可维护性 命名空间 可复用性 模块化规范 CommonJS Module(es6) AMD UMD CMD common.js 和 es6 中模块引入的区别？CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。 运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。 自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。 但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。 在使用上的差别主要有： 1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 3、CommonJs 是单个值导出，ES6 Module可以导出多个 4、CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层 5、CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined CommonJSCommonJS 是一套 Javascript 模块规范，用于服务端 CommonJS 扩展了JavaScript声明模块的API, 通过CommonJS，每个JS文件独立地存储它模块的内容（就像一个被括起来的闭包一样）。在这种作用域中，我们通过 module.exports 语句来导出对象为模块，再通过 require 语句来引入 所有代码都运行在模块作用域，不会污染全局作用域 模块是同步加载的，即只有加载完成，才能执行后面的操作 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存 require返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值 如： 12345678function myModule() &#123; this.hello = function() &#123; return &#x27;hello!&#x27;; &#125;&#125;module.exports = myModule;// 然后再通过require去加载 ES Module原生ＪＳ(es6)解决方案, ES6设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量 模块功能主要由两个命令构成： export：用于规定模块的对外接口import：用于输入其他模块提供的功能 如: 12export default myModuleimport myModule from &#x27;./myModule&#x27; 动态加载 允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势 这个新功能允许您将import()作为函数调用，将其作为参数传递给模块的路径。它返回一个 promise，它用一个模块对象来实现，让你可以访问该对象的导出 1234import(&#x27;/modules/myModule.mjs&#x27;) .then((module) =&gt; &#123; // Do something with the module. &#125;); 复合写法 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起 12345export &#123; foo, bar &#125; from &#x27;my_module&#x27;;// 可以简单理解为import &#123; foo, bar &#125; from &#x27;my_module&#x27;;export &#123; foo, bar &#125;; 同理能够搭配as、*搭配使用 AMD （Asynchronous Module Definition）提倡依赖前置，在定义模块的时候就要声明其依赖的模块 异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行 代表库为require.js 如： 12345678910111213/** main.js 入口文件/主模块 **/// 首先用config()指定各模块路径和引用名require.config(&#123; baseUrl: &quot;js/lib&quot;, paths: &#123; &quot;jquery&quot;: &quot;jquery.min&quot;, //实际路径为js/lib/jquery.min.js &quot;underscore&quot;: &quot;underscore.min&quot;, &#125;&#125;);// 执行基本操作require([&quot;jquery&quot;,&quot;underscore&quot;],function($,_)&#123; // some code here&#125;); CMD (Common Module Definition)CMD规范是国内SeaJS的推广过程中产生的提倡就近依赖（按需加载），在用到某个模块的时候再去require 1234567define(function (require, exports, module) &#123; var one = require(&#x27;./one&#x27;) one.do()// 就近依赖，按需加载 var two = require(&#x27;./two&#x27;) two.do() &#125;) UMD (Universal Module Definition)AMD和CommonJS的结合,跨平台的解决方案,UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块 如 1234567891011(function (window, factory) &#123; if (typeof exports === &#x27;object&#x27;) &#123; module.exports = factory(); &#125; else if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) &#123; define(factory); &#125; else &#123; window.eventUtil = factory(); &#125;&#125;)(this, function () &#123; //module ...&#125;);","categories":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://example.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"web安全攻击手段以及如何防范","slug":"web安全攻击手段以及如何防范","date":"2021-03-11T02:50:38.000Z","updated":"2021-04-25T03:06:39.866Z","comments":true,"path":"2021/03/11/web安全攻击手段以及如何防范/","link":"","permalink":"http://example.com/2021/03/11/web%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83/","excerpt":"","text":"对于常规的Web攻击手段，如XSS、CRSF、SQL注入、（常规的不包括文件上传漏洞、DDoS攻击）等 比如XSS的防范需要转义掉输入的尖括号; 防止CRSF攻击需要将cookie设置为httponly，以及增加session相关的Hash token码; SQL注入的防范需要将分号等字符转义， xss(cross site scripting) 跨站脚本攻击定义: 指攻击者在网页嵌入脚本，用户浏览网页触发恶意脚本执行 XSS攻击分为3类：存储型（持久型）、反射型（非持久型）、基于DOM 如何防范: 设置HttpOnly以避免cookie劫持的危险 过滤，对诸如script、img、a等标签进行过滤 编码，像一些常见的符号，如&lt;&gt;在输入的时候要对其进行转换编码 限制，对于一些可以预期的输入可以通过限制长度强制截断来进行防御 CSRF(cross site request forgery) 跨站请求伪造(CSRF 或者 XSRF)CSRF攻击的全称是跨站请求伪造（ cross site request forgery)，是一种对网站的恶意利用，尽管听起来跟XSS跨站脚本攻击有点相似，但事实上CSRF与XSS差别很大，XSS利用的是站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的网站。 CSRF攻击原理 首先用户C浏览并登录了受信任站点A； 登录信息验证通过以后，站点A会在返回给浏览器的信息中带上已登录的cookie，cookie信息会在浏览器端保存一定时间（根据服务端设置而定）； 完成这一步以后，用户在没有登出（清除站点A的cookie）站点A的情况下，访问恶意站点B； 这时恶意站点 B的某个页面向站点A发起请求，而这个请求会带上浏览器端所保存的站点A的cookie； 站点A根据请求所带的cookie，判断此请求为用户C所发送的。 因此，站点A会报据用户C的权限来处理恶意站点B所发起的请求，而这个请求可能以用户C的身份发送 邮件、短信、消息，以及进行转账支付等操作，这样恶意站点B就达到了伪造用户C请求站点 A的目的。 受害者只需要做下面两件事情，攻击者就能够完成CSRF攻击： 登录受信任站点 A，并在本地生成cookie； 在不登出站点A（清除站点A的cookie）的情况下，访问恶意站点B。 CSRF的防御1、尽量使用POST，限制GET GET接口太容易被拿来做CSRF攻击，看上面示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。 当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。 2、将cookie设置为HttpOnly CRSF攻击很大程度上是利用了浏览器的cookie，为了防止站内的XSS漏洞盗取cookie,需要在cookie中设置“HttpOnly”属性，这样通过程序（如JavaScript脚本、Applet等）就无法读取到cookie信息，避免了攻击者伪造cookie的情况出现。在Java的Servlet的API中设置cookie为HttpOnly的代码如下： 1ctx.cookies.set(&#x27;cookiename&#x27;, &#x27;cookievalue&#x27;, &#123; httpOnly: true &#125;) 3、增加token CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于cookie中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。 由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信总不存在于cookie之中。鉴于此，系统开发人员可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务端进行token校验，如果请求中没有token或者token内容不正确，则认为是CSRF攻击而拒绝该请求。 假设请求通过POST方式提交，则可以在相应的表单中增加一个隐藏域： 1&lt;input type=&quot;hidden&quot; name=&quot;_toicen&quot; value=&quot;tokenvalue&quot;/&gt; token的值通过服务端生成，表单提交后token的值通过POST请求与参数一同带到服务端，每次会话可以使用相同的token，会话过期，则token失效，攻击者因无法获取到token，也就无法伪造请求。 在session中添加token的实现代码： 12345HttpSession session = request.getSession();Object token = session.getAttribute(&quot;_token&quot;);if(token == null I I &quot;&quot;.equals(token)) &#123; session.setAttribute(&quot;_token&quot;, UUID.randomUUIDO .toString());&#125; 4、通过Referer识别 根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。 在通常情况下，访问一个安全受限的页面的请求都来自于同一个网站。比如某银行的转账是通过用户访问http://www.xxx.com/transfer.do页面完成的，用户必须先登录www.xxx.com，然后通过单击页面上的提交按钮来触发转账事件。 当用户提交请求时，该转账请求的Referer值就会是提交按钮所在页面的URL（本例为www.xxx. com/transfer.do）。 如果攻击者要对银行网站实施CSRF攻击，他只能在其他网站构造请求，当用户通过其他网站发送请求到银行时，该请求的Referer的值是其他网站的地址，而不是银行转账页面的地址。 因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值即可，如果是以www.xx.om域名开头的地址，则说明该请求是来自银行网站自己的请求，是合法的； 如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。 取得HTTP请求Referer： 1ctx.headers[&quot;Referer&quot;] sql注入(SQL injection)定义: 在未授权情况下，非法访问数据库信息 如何防范: 杜绝用户提交的参数入库并且执行 在代码层，不准出现sql语句 在web输入参数处，对所有的参数做sql转义 上线测试，需要使用sql自动注入工具进行所有的页面sql注入测试","categories":[{"name":"浏览器特性","slug":"浏览器特性","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"函数相关知识","slug":"函数相关知识","date":"2021-03-03T07:36:12.000Z","updated":"2021-04-25T03:06:39.868Z","comments":true,"path":"2021/03/03/函数相关知识/","link":"","permalink":"http://example.com/2021/03/03/%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","excerpt":"","text":"箭头函数 如果形参只有一个，则小括号可以省略 函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果，所以 return也要去掉 箭头函数 this 指向声明时所在作用域下 this 的值，this是静态的 箭头函数不能作为构造函数实例化 不能使用 arguments 箭头函数不会更改 this 指向，用来指定回调函数会非常合适。因为其this是静态的，指向声明时所在的作用域 函数柯里化 是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 1234567891011121314// 普通的add函数function add(x, y) &#123; return x + y&#125;// Currying后function curryingAdd(x) &#123; return function (y) &#123; return x + y &#125;&#125;add(1, 2) // 3curryingAdd(1)(2) // 3 但是问题来了费这么大劲封装一层，到底有什么用处呢？ 来列一列柯里化有哪些好处呢？ 1.参数复用 1234567891011121314151617181920212223// 正常正则验证字符串 reg.test(txt)// 函数封装后function check(reg, txt) &#123; return reg.test(txt)&#125;check(/\\d+/g, &#x27;test&#x27;) //falsecheck(/[a-z]+/g, &#x27;test&#x27;) //true// Currying后function curryingCheck(reg) &#123; return function(txt) &#123; return reg.test(txt) &#125;&#125;var hasNumber = curryingCheck(/\\d+/g)var hasLetter = curryingCheck(/[a-z]+/g)hasNumber(&#x27;test1&#x27;) // truehasNumber(&#x27;testtest&#x27;) // falsehasLetter(&#x27;21212&#x27;) // false 上面的示例是一个正则的校验，正常来说直接调用check函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便。 2.提前确认 12345678910111213141516171819202122232425262728293031323334353637var on = function(element, event, handler) &#123; if (document.addEventListener) &#123; if (element &amp;&amp; event &amp;&amp; handler) &#123; element.addEventListener(event, handler, false); &#125; &#125; else &#123; if (element &amp;&amp; event &amp;&amp; handler) &#123; element.attachEvent(&#x27;on&#x27; + event, handler); &#125; &#125;&#125;var on = (function() &#123; if (document.addEventListener) &#123; return function(element, event, handler) &#123; if (element &amp;&amp; event &amp;&amp; handler) &#123; element.addEventListener(event, handler, false); &#125; &#125;; &#125; else &#123; return function(element, event, handler) &#123; if (element &amp;&amp; event &amp;&amp; handler) &#123; element.attachEvent(&#x27;on&#x27; + event, handler); &#125; &#125;; &#125;&#125;)();//换一种写法可能比较好理解一点，上面就是把isSupport这个参数给先确定下来了var on = function(isSupport, element, event, handler) &#123; isSupport = isSupport || document.addEventListener; if (isSupport) &#123; return element.addEventListener(event, handler, false); &#125; else &#123; return element.attachEvent(&#x27;on&#x27; + event, handler); &#125;&#125; 我们在做项目的过程中，封装一些dom操作可以说再常见不过，上面第一种写法也是比较常见，但是我们看看第二种写法，它相对一第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了会走哪一个方法，避免每次都进行判断。 3.延迟运行 12345678Function.prototype.bind = function (context) &#123; var _this = this var args = Array.prototype.slice.call(arguments, 1) return function() &#123; return _this.apply(context, args) &#125;&#125; 像我们js中经常使用的bind，实现的机制就是Currying. 说了这几点好处之后，发现还有个问题，难道每次使用Currying都要对底层函数去做修改， 有没有什么通用的封装方法？ 12345678910function currying(fn) &#123; // args 获取第一个方法内的全部参数 var args = Array.prototype.slice.call(arguments, 1); return function() &#123; // 将后面方法里的全部参数和args进行合并 var newArgs = args.concat(Array.prototype.slice.call(arguments)); // 把合并后的参数通过apply作为fn的参数并执行 return fn.apply(this, newArgs); &#125;&#125; 这边首先是初步封装,通过闭包把初步参数给保存下来，然后通过获取剩下的arguments进行拼接，最后执行需要currying的函数。 但是好像还有些什么缺陷，这样返回的话其实只能多扩展一个参数，currying(a)(b)(c)这样的话，貌似就不支持了（不支持多参数调用），一般这种情况都会想到使用递归再进行封装一层。 123456789101112131415161718function progressCurrying(fn, args) &#123; let _this = this; let length = fn.length; let args = args || []; return function() &#123; let _args = Array.prototype.slice.call(arguments); Array.prototype.push.apply(args, _args); // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数 if (_args.length &lt; length) &#123; return progressCurrying.call(_this, fn, args); &#125; // 参数收集完毕，则执行fn return fn.apply(_this, args); &#125;&#125; 这边其实是在初步的基础上，加上了递归的调用，只要参数个数小于最初的fn.length，就会继续执行递归。 curry的一些性能问题你只要知道下面四点就差不多了： 存取arguments对象通常要比存取命名参数要慢一点 一些老版本的浏览器在arguments.length的实现上是相当慢的 使用fn.apply( … ) 和 fn.call( … )通常比直接调用fn( … ) 稍微慢点 创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上 其实在大部分应用中，主要的性能瓶颈是在操作DOM节点上，这js的性能损耗基本是可以忽略不计的，所以curry是可以直接放心的使用。 最后再扩展一道经典面试题 // 实现一个add方法，使计算结果能够满足如下预期：add(1)(2)(3) = 6;add(1, 2, 3)(4) = 10;add(1)(2)(3)(4)(5) = 15; 123456789101112131415161718192021222324function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 let _args = Array.prototype.slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 let _adder = function() &#123; _args.push(...arguments); return _adder; &#125; // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function() &#123; return _args.reduce(function(a, b) &#123; return a + b; &#125;) &#125; return _adder&#125;add(1)(2)(3) // 6add(1, 2, 3)(4) // 10add(1)(2)(3)(4)(5) // 15add(2, 6)(1) // 9","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"函数","slug":"函数","permalink":"http://example.com/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"浅谈小程序运行机制","slug":"浅谈小程序运行机制","date":"2021-03-03T02:26:27.000Z","updated":"2021-04-25T03:06:39.870Z","comments":true,"path":"2021/03/03/浅谈小程序运行机制/","link":"","permalink":"http://example.com/2021/03/03/%E6%B5%85%E8%B0%88%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/","excerpt":"","text":"小程序与普通网页开发的区别 小程序的开发同普通的网页开发相比有很大的相似性，小程序的主要开发语言也是 JavaScript，但是二者还是有些差别的。 普通网页开发可以使用各种浏览器提供的 DOM API，进行 DOM 操作，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOMAPI。 普通网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。 网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。 小程序的执行环境 小程序架构 1.技术选型一般来说，渲染界面的技术有三种： 用纯客户端原生技术来渲染 用纯 Web 技术来渲染 用客户端原生技术与 Web 技术结合的混合技术（简称 Hybrid 技术）来渲染 通过以下几个方面分析，小程序采用哪种技术方案 开发门槛：Web 门槛低，Native 也有像 RN 这样的框架支持 体验：Native 体验比 Web 要好太多，Hybrid 在一定程度上比 Web 接近原生体验 版本更新：Web 支持在线更新，Native 则需要打包到微信一起审核发布 管控和安全：Web 可跳转或是改变页面内容，存在一些不可控因素和安全风险 由于小程序的宿主环境是微信，如果用纯客户端原生技术来编写小程序，那么小程序代码每次都需要与微信代码一起发版，这种方式肯定是不行的。 所以需要像web技术那样，有一份随时可更新的资源包放在云端，通过下载到本地，动态执行后即可渲染出界面。 如果用纯web技术来渲染小程序，在一些复杂的交互上可能会面临一些性能问题，这是因为在web技术中，UI渲染跟JavaScript的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。 所以最终采用了两者结合起来的Hybrid 技术来渲染小程序，可以用一种近似web的方式来开发，并且可以实现在线更新代码，同时引入组件也有以下好处： 扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力 体验更好，同时也减轻 WebView 的渲染工作 绕过 setData、数据通信和重渲染流程，使渲染性能更好 用客户端原生渲染内置一些复杂组件，可以提供更好的性能 2.双线程模型 小程序的渲染层和逻辑层分别由 2 个线程管理：视图层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS脚本。 那么为什么要这样设计呢，前面也提到了管控和安全，为了解决这些问题，我们需要阻止开发者使用一些，例如浏览器的window对象，跳转页面、操作DOM、动态执行脚本的开放性接口。 我们可以使用客户端系统的 JavaScript 引擎，iOS 下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境。 这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口。 这就是小程序双线程模型的由来： 逻辑层：创建一个单独的线程去执行 JavaScript，在这里执行的都是有关小程序业务逻辑的代码，负责逻辑处理、数据请求、接口调用等 视图层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以视图层存在多个 WebView 线程 JSBridge 起到架起上层开发与Native（系统层）的桥梁，使得小程序可通过API使用原生的功能，且部分组件为原生组件实现，从而有良好体验 3.双线程通信把开发者的 JS 逻辑代码放到单独的线程去运行，但在 Webview 线程里，开发者就没法直接操作 DOM。 那要怎么去实现动态更改界面呢？ 如上图所示，逻辑层和试图层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。 这也就是说，我们可以把 DOM 的更新通过简单的数据通信来实现。 Virtual DOM 相信大家都已有了解，大概是这么个过程：用 JS 对象模拟 DOM 树 -&gt; 比较两棵虚拟 DOM 树的差异 -&gt; 把差异应用到真正的 DOM 树上。 在渲染层把 WXML 转化成对应的 JS 对象。 在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。 经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。 我们通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。 而这样一个完整的框架，离不开小程序的基础库。 4.小程序的基础库小程序的基础库可以被注入到视图层和逻辑层运行，主要用于以下几个方面： 在视图层，提供各类组件来组建界面的元素 在逻辑层，提供各类 API 来处理各种逻辑 处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑 由于小程序的渲染层和逻辑层是两个线程管理，两个线程各自注入了基础库。 小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。 这样可以： 降低业务小程序的代码包大小 可以单独修复基础库中的 Bug，无需修改到业务小程序的代码包 5.Exparser 框架Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。 小程序内的所有组件，包括内置组件和自定义组件，都由Exparser组织管理。 Exparser的主要特点包括以下几点： 基于Shadow, DOM模型：模型上与WebComponents的ShadowDOM高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性&gt; + 地增加了其他API以支持小程序组件编程。 可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。 高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。 小程序中，所有节点树相关的操作都依赖于Exparser，包括WXML到页面最终节点树的构建、createSelectorQuery调用和自定义组件特性等。 内置组件 基于Exparser框架，小程序内置了一套组件，提供了视图容器类、表单类、导航类、媒体类、开放类等几十种组件。 有了这么丰富的组件，再配合WXSS，可以搭建出任何效果的界面。在功能层面上，也满足绝大部分需求。 6.运行机制 小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台状态的小程序切换到前台，这个过程就是热启动；冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。 小程序没有重启的概念 当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁 当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁 7.更新机制小程序冷启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。 如果需要马上应用最新版本，可以使用 wx.getUpdateManager API 进行处理。 8.性能优化主要的优化策略可以归纳为三点： 精简代码，降低WXML结构和JS代码的复杂性； 合理使用setData调用，减少setData次数和数据量； 必要时使用分包优化。 1.setData 工作原理小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。 在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。 当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。 而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。 2.常见的 setData 操作错误1.频繁的去 setData在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果： Android下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层； 渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时； 2.每次 setData 都传递大量新数据由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript 3.脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程， 后台态页面进行setData当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"http各版本及https简要介绍","slug":"http各版本及https简要介绍-0","date":"2021-03-01T09:53:40.000Z","updated":"2021-04-25T03:06:39.864Z","comments":true,"path":"2021/03/01/http各版本及https简要介绍-0/","link":"","permalink":"http://example.com/2021/03/01/http%E5%90%84%E7%89%88%E6%9C%AC%E5%8F%8Ahttps%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D-0/","excerpt":"","text":"HTTP优化：影响一个 HTTP 网络请求的因素主要有两个方面：带宽和延迟。 随着网络基础建设的完善，带宽因素已经不需要再考虑，仅需要考虑的就是延迟。延迟主要受三个方面影响：浏览器阻塞（HOL blocking）, DNS查询（DNS Lookup）,建立连接（Initial connection）. HTTP1.1 支持长连接。 在HTTP1.0的基础上引入了更多的缓存控制策略。 引入了请求范围设置，优化了带宽。 在错误通知管理中新增了错误状态响应码。 增加了Host头处理，可以传递主机名（hostname）。 缺点: 传输内容是明文，不够安全 HTTPS HTTPS运行在安全套接字协议(Secure Sockets Layer，SSL )或传输层安全协议（Transport Layer Security，TLS）之上，所有在TCP中传输的内容都需要经过加密。 连接方式不同，HTTP的端口是80，HTTPS的端口是443. HTTPS可以有效防止运营商劫持。 注: SSL运行在TCP之上 HTTP2.0（SPDY的升级版） HTTP2.0支持明文传输，而HTTP 1.X强制使用SSL/TLS加密传输。 和HTTP 1.x使用的header压缩方法不同。 HTTP2.0 基于二进制格式进行解析，而HTTP 1.x基于文本格式进行解析。 多路复用，HTTP1.1是多个请求串行化单线程处理，HTTP 2.0是并行执行，一个请求超时并不会影响其他请求。 HTTP2.0的多路复用提升了网页性能： 在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome下一般是六个），当在请求很多资源的时候，由于队头阻塞，当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。 HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。 注意: 主流浏览器只支持基于TLS部署的HTTP2.0协议，所以要将网站升级为HTTP 2.0，就需要先升级为HTTPS。 HTTP 2.0完全兼容HTTP 1.x,所以对于部署了HTTP 2.0的网站可以自动向下兼容HTTP 1.X. HTTP 3.0 (QUIC)QUIC (Quick UDP Internet Connections), 快速 UDP 互联网连接。 QUIC是基于UDP协议的。 两个主要特性： 1.线头阻塞(HOL)问题的解决更为彻底 基于TCP的HTTP/2，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的流数据传输。而基于UDP的QUIC协议则可以更为彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。 2.切换网络时的连接保持 当前移动端的应用环境，用户的网络可能会经常切换，比如从办公室或家里出门，WiFi断开，网络切换为3G或4G。基于TCP的协议，由于切换网络之后，IP会改变，因而之前的连接不可能继续保持。而基于UDP的QUIC协议，则可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接。","categories":[{"name":"http","slug":"http","permalink":"http://example.com/categories/http/"}],"tags":[{"name":"http协议","slug":"http协议","permalink":"http://example.com/tags/http%E5%8D%8F%E8%AE%AE/"}]},{"title":"express和koa的区别","slug":"express和koa的区别","date":"2021-02-26T07:10:07.000Z","updated":"2021-04-25T03:06:39.863Z","comments":true,"path":"2021/02/26/express和koa的区别/","link":"","permalink":"http://example.com/2021/02/26/express%E5%92%8Ckoa%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"虽然express.js有着精妙的中间件设计，但是以当前js标准来说，这种精妙的设计在现在可以说是太复杂。里面的层层回调和递归，不花一定的时间还真的很难读懂。 而koa2的代码呢？简直可以用四个字评论：精简彪悍！仅仅几个文件，用上最新的js标准，就很好实现了中间件，代码读起来一目了然。 1.express用法和koa用法简单展示如果你使用express.js启动一个简单的服务器，那么基本写法应该是这样： 1234567891011121314151617181920212223242526const express = require(&#x27;express&#x27;);const app = express();const router = express.Router();app.use(async (req, res, next) =&gt; &#123; console.log(&#x27;I am the first middleware&#x27;); next(); console.log(&#x27;first middleware end calling&#x27;);&#125;)app.use(async (req, res, next) =&gt; &#123; console.log(&#x27;I am the second middleware&#x27;); next(); console.log(&#x27;second middleware end calling&#x27;);&#125;)router.get(&#x27;/api/test1&#x27;, async (req, res, next) =&gt; &#123; console.log(&#x27;I am the router middleware =&gt; /api/test1&#x27;); res.status(200).send(&#x27;hello&#x27;);&#125;)app.use(&#x27;/&#x27;, router);app.listen(3000);console.log(&#x27;server listening at port 3000&#x27;) 换算成等价的koa2，那么用法是这样的： 12345678910111213141516171819202122232425262728const koa = require(&#x27;koa&#x27;);const Router = require(&#x27;koa-router&#x27;);const app = new koa();const router = Router();app.use(async (ctx, next) =&gt; &#123; console.log(&#x27;I am the first middleware&#x27;) await next() console.log(&#x27;first middleware end calling&#x27;)&#125;)app.use(async (ctx, next) =&gt; &#123; console.log(&#x27;I am the second middleware&#x27;) await next() console.log(&#x27;second middleware end calling&#x27;)&#125;)router.get(&#x27;/api/test1&#x27;, async(ctx, next) =&gt; &#123; console.log(&#x27;I am the router middleware =&gt; /api/test1&#x27;) ctx.body = &#x27;hello&#x27;&#125;)app.use(router.routes());app.listen(3000);console.log(&#x27;server listening at port 3000&#x27;) 二者的使用区别通过表格展示如下: 上表展示了二者的使用区别，从初始化就看出koa语法都是用的新标准。在挂载路由中间件上也有一定的差异性，这是因为二者内部实现机制的不同。其他都是大同小异的了。 在理念上，Koa 旨在 “修复和替换节点”，而 Express 旨在 “增加节点”。 Koa 使用Promise(JavaScript一种异步手段)和异步功能来摆脱回调地狱的应用程序，并简化错误处理。 它暴露了自己的 ctx.request 和 ctx.response 对象，而不是 node 的 req 和 res 对象。 另一方面，Express 通过附加的属性和方法增加了 node 的 req 和 res 对象，并且包含许多其他 “框架” 功能，如路由和模板，而 Koa 则没有。 因此，Koa 可被视为 node.js 的 http 模块的抽象，其中 Express 是 node.js 的应用程序框架。 因此，如果您想要更接近 node.js 和传统的 node.js 样式编码，那么您可能希望坚持使用Connect/Express 或类似的框架。 如果你想摆脱回调，请使用 Koa。 由于这种不同的理念，其结果是传统的 node.js “中间件”（即“（req，res，next）”的函数）与Koa不兼容。 你的应用基本上要重新改写了。 Koa 与 Connect/Express 有哪些不同? 基于 Promises 的控制流程没有回调地狱。 通过 try/catch 更好的处理错误。 无需域。 Koa 非常精简不同于 Connect 和 Express, Koa 不含任何中间件. 不同于 Express, 不提供路由. 不同于 Express, 不提供许多便捷设施。 例如，发送文件. Koa 更加模块化. Koa 对中间件的依赖较少例如, 不使用 “body parsing” 中间件，而是使用 body 解析函数。 Koa 抽象 node 的 request/response减少攻击。 更好的用户体验。 恰当的流处理。 Koa 路由（第三方库支持）由于 Express 带有自己的路由，而 Koa 没有任何内置路由，但是有 koa-router 和 koa-route 第三方库可用。同样的, 就像我们在 Express 中有 helmet 保证安全, 对于 koa 我们有 koa-helmet 和一些列的第三方库可用 2.koa2中间件 看完这个gif图，也可以思考下如何实现的。根据表现，可以猜测是next是一个函数，而且返回的可能是一个promise，被await调用。 2.1阅读koa-compose源码123456789101112131415161718192021222324252627282930313233343536373839404142function compose(middleware) &#123; if (!Array.isArray(middleware)) throw new TypeError(&#x27;Middleware stack must be an array!&#x27;); for (const fn of middleware) &#123; if (typeof fn !== &#x27;function&#x27;) throw new TypeError(&#x27;Middleware must be composed of functions!&#x27;); &#125; /** * @param &#123;Object&#125; context * @return &#123;Promise&#125; * @api public */ return function(context, next) &#123; // last called middleware # let index = -1; // 取出第一个中间件函数执行 return dispatch(0); // 递归函数 function dispatch(i) &#123; if (i &lt;= index) return Promise.reject(new Error(&#x27;next() called multiple times&#x27;)); index = i; let fn = middleware[i]; // next的值为undefined,当没有中间件的时候直接结束 // 其实这里可以去掉next参数，直接在下面fn = void 0,和之前的代码效果一样 // if (i === middleware.length) fn = void 0; if (i === middleware.length) fn = next; if (!fn) return Promise.resolve(); try &#123; // fn为当前执行的中间件函数 // 当前中间件函数执行时传入的next参数为下一个中间件 // 当所有的中间件都执行完毕时, 当前中间件传入的next参数是请求处理的回调 return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err); &#125; &#125; &#125;;&#125; 上面的代码等价于 123456789101112131415161718192021// 这样就可能更好理解了。// simpleKoaComposeconst [fn1, fn2, fn3] = this.middleware;const fnMiddleware = function(context)&#123; return Promise.resolve( fn1(context, function next()&#123; return Promise.resolve( fn2(context, function next()&#123; return Promise.resolve( fn3(context, function next()&#123; return Promise.resolve(); &#125;) ) &#125;) ) &#125;) );&#125;;fnMiddleware(ctx).then(handleResponse).catch(onerror); 也就是说koa-compose返回的是一个Promise，Promise中取出第一个函数（app.use添加的中间件），传入context和第一个next函数来执行。 第一个next函数里也是返回的是一个Promise，Promise中取出第二个函数（app.use添加的中间件），传入context和第二个next函数来执行。 第二个next函数里也是返回的是一个Promise，Promise中取出第三个函数（app.use添加的中间件），传入context和第三个next函数来执行。 第三个… 以此类推。最后一个中间件中有调用next函数，则返回Promise.resolve。如果没有，则不执行next函数。这样就把所有中间件串联起来了。这也就是我们常说的洋葱模型。 3.koa2 和 koa1 的简单对比koa1中主要是generator函数。koa2中会自动转换generator函数。 app.use时有一层判断，是否是generator函数，如果是则用koa-convert暴露的方法convert来转换重新赋值，再存入middleware，后续再使用。 koa-convert源码挺多，核心代码其实是这样的。 12345678function convert()&#123;return function (ctx, next) &#123; return co.call(ctx, mw.call(ctx, createGenerator(next))) &#125; function * createGenerator (next) &#123; return yield next() &#125;&#125; 最后还是通过co来转换的。所以接下来看co的源码。 123456789101112131415// 写一个请求简版请求function request(ms= 1000) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123;name: &#x27;若川&#x27;&#125;); &#125;, ms); &#125;);&#125;// 获取generator的值function* generatorFunc()&#123; const res = yield request(); console.log(res, &#x27;generatorFunc-res&#x27;);&#125;generatorFunc(); // 报告，我不会输出你想要的结果的 简单来说co，就是把generator自动执行，再返回一个promise。generator函数这玩意它不自动执行呀，还要一步步调用next()，也就是叫它走一步才走一步。 所以有了async、await函数。 123456// await 函数 自动执行async function asyncFunc()&#123; const res = await request(); console.log(res, &#x27;asyncFunc-res await 函数 自动执行&#x27;);&#125;asyncFunc(); // 输出结果 也就是说co需要做的事情，是让generator向async、await函数一样自动执行。 最终来看下co源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970function co(gen) &#123; var ctx = this; var args = slice.call(arguments, 1) // we wrap everything in a promise to avoid promise chaining, // which leads to memory leak errors. // see https://github.com/tj/co/issues/180 return new Promise(function(resolve, reject) &#123; // 把参数传递给gen函数并执行 if (typeof gen === &#x27;function&#x27;) gen = gen.apply(ctx, args); // 如果不是函数 直接返回 if (!gen || typeof gen.next !== &#x27;function&#x27;) return resolve(gen); onFulfilled(); /** * @param &#123;Mixed&#125; res * @return &#123;Promise&#125; * @api private */ function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; /** * @param &#123;Error&#125; err * @return &#123;Promise&#125; * @api private */ function onRejected(err) &#123; var ret; try &#123; ret = gen.throw(err); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; /** * Get the next value in the generator, * return a promise. * * @param &#123;Object&#125; ret * @return &#123;Promise&#125; * @api private */ // 反复执行调用自己 function next(ret) &#123; // 检查当前是否为 Generator 函数的最后一步，如果是就返回 if (ret.done) return resolve(ret.value); // 确保返回值是promise对象。 var value = toPromise.call(ctx, ret.value); // 使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。 if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); // 在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。 return onRejected(new TypeError(&#x27;You may only yield a function, promise, generator, array, or object, &#x27; + &#x27;but the following object was passed: &quot;&#x27; + String(ret.value) + &#x27;&quot;&#x27;)); &#125; &#125;);&#125; 总结 koa-compose是将app.use添加到middleware数组中的中间件（函数），通过使用Promise串联起来，next()返回的是一个promise。 koa-convert 判断app.use传入的函数是否是generator函数，如果是则用koa-convert来转换，最终还是调用的co来转换。 co源码实现原理：其实就是通过不断的调用generator函数的next()函数，来达到自动执行generator函数的效果（类似async、await函数的自动自行）。 koa框架总结：主要就是四个核心概念，洋葱模型（把中间件串联起来），http请求上下文（context）、http请求对象、http响应对象。 koa洋葱模型怎么实现的。 app.use() 把中间件函数存储在middleware数组中，最终会调用koa-compose导出的函数compose返回一个promise，中间函数的第一个参数ctx是包含响应和请求的一个对象，会不断传递给下一个中间件。next是一个函数，返回的是一个promise。 如果中间件中的next()方法报错了怎么办。1234567891011121314ctx.onerror = function &#123; this.app.emit(&#x27;error&#x27;, err, this);&#125;;listen()&#123; const fnMiddleware = compose(this.middleware); if (!this.listenerCount(&#x27;error&#x27;)) this.on(&#x27;error&#x27;, this.onerror); const onerror = err =&gt; ctx.onerror(err); fnMiddleware(ctx).then(handleResponse).catch(onerror);&#125;onerror(err) &#123; // 代码省略 // ...&#125; 中间件链错误会由ctx.onerror捕获，该函数中会调用this.app.emit(‘error’, err, this)（因为koa继承自events模块，所以有’emit’和on等方法），可以使用app.on(‘error’, (err) =&gt; {})，或者app.onerror = (err) =&gt; {}进行捕获。 co的原理是怎样的。 co的原理是通过不断调用generator函数的next方法来达到自动执行generator函数的，类似async、await函数自动执行。","categories":[{"name":"node.js","slug":"node-js","permalink":"http://example.com/categories/node-js/"}],"tags":[{"name":"express/koa","slug":"express-koa","permalink":"http://example.com/tags/express-koa/"}]},{"title":"闭包","slug":"闭包","date":"2021-02-24T07:13:15.000Z","updated":"2021-04-25T03:06:39.872Z","comments":true,"path":"2021/02/24/闭包/","link":"","permalink":"http://example.com/2021/02/24/%E9%97%AD%E5%8C%85/","excerpt":"","text":"闭包闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。 闭包有两个常用的用途。 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。 函数作为返回值123456789101112function fn() &#123; var max = 10; return function bar(x) &#123; if (x &gt; max) &#123; console.log(x) &#125; &#125;&#125;var f1 = fn()f1(15) 如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。 函数作为参数被传递1234567891011var max = 10;var fn = function(x) &#123; if (x &gt; max) &#123; console.log(x) &#125;&#125;(function(f) &#123; var max = 100; f(15)&#125;)(fn) 如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。 自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。 另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。 当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。 但是有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。 第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。 第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。 第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。 注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。 而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。 因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。 ——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图： 第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。 执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。 这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。 使用闭包会增加内容开销，现在很明显了吧！","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://example.com/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"Map结构","slug":"Map结构","date":"2021-02-23T03:39:46.000Z","updated":"2021-04-25T03:06:39.860Z","comments":true,"path":"2021/02/23/Map结构/","link":"","permalink":"http://example.com/2021/02/23/Map%E7%BB%93%E6%9E%84/","excerpt":"","text":"map相关方法map.set(key, val) 1.如果对同一个键多次赋值，后面的值将覆盖前面的值。2.注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。3.Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。4.如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。 map.get(key)map.size, size属性返回 Map 结构的成员总数。map.has(key), has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。map.delete(key), delete方法删除某个键，返回true。如果删除失败，返回false。map.clear(), clear方法清除所有成员，没有返回值。 遍历方法 Map 结构原生提供三个遍历器生成函数和一个遍历方法。 Map.prototype.keys()：返回键名的遍历器。Map.prototype.values()：返回键值的遍历器。Map.prototype.entries()：返回所有成员的遍历器。Map.prototype.forEach()：遍历 Map 的所有成员。 与其他数据结构的互相转换1.Map 转为数组Map 转为数组最方便的方法，就是使用扩展运算符（…） 123456const myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#x27;abc&#x27;]);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ] 2.数组 转为 Map将数组传入 Map 构造函数，就可以转为 Map。 12345678new Map([ [true, 7], [&#123;foo: 3&#125;, [&#x27;abc&#x27;]]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]// &#125; 3.Map 转为对象如果所有 Map 的键都是字符串，它可以无损地转为对象。 12345678910111213function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set(&#x27;yes&#x27;, true) .set(&#x27;no&#x27;, false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; 如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。 4.对象转为 Map对象转为 Map 可以通过Object.entries()。 1234567891011121314let obj = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;let map = new Map(Object.entries(obj));// 此外，也可以自己实现一个转换函数。function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125; 5.Map 转为 JSONMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。 1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set(&#x27;yes&#x27;, true).set(&#x27;no&#x27;, false);strMapToJson(myMap)// &#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27; 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。 1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#x27;abc&#x27;]);mapToArrayJson(myMap)// &#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27; 6.JSON 转为 MapJSON 转为 Map，正常情况下，所有键名都是字符串。 123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap(&#x27;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#x27;)// Map &#123;&#x27;yes&#x27; =&gt; true, &#x27;no&#x27; =&gt; false&#125; 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。 123456function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125;jsonToMap(&#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;)// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"map","slug":"map","permalink":"http://example.com/tags/map/"}]},{"title":"vue双向数据绑定原理","slug":"vue双向数据绑定原理","date":"2021-02-22T10:26:36.000Z","updated":"2021-04-25T03:06:39.866Z","comments":true,"path":"2021/02/22/vue双向数据绑定原理/","link":"","permalink":"http://example.com/2021/02/22/vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/","excerpt":"","text":"思路整理已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳这里 整理了一下，要实现mvvm的双向绑定，就必须要实现以下几点： 1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 4、mvvm入口函数，整合以上三者 上述流程如图所示： 实现Observer我们知道可以利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function Observer(data) &#123; this.data = data; this.walk(data);&#125;Observer.prototype = &#123; constructor: Observer, walk: function(data) &#123; var me = this; Object.keys(data).forEach(function(key) &#123; me.convert(key, data[key]); &#125;); &#125;, convert: function(key, val) &#123; this.defineReactive(this.data, key, val); &#125;, defineReactive: function(data, key, val) &#123; var dep = new Dep(); var childObj = observe(val); Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; if (Dep.target) &#123; dep.depend(); &#125; return val; &#125;, set: function(newVal) &#123; if (newVal === val) &#123; return; &#125; val = newVal; // 新的值是object的话，进行监听 childObj = observe(newVal); // 通知订阅者 dep.notify(); &#125; &#125;); &#125;&#125;;function observe(value, vm) &#123; if (!value || typeof value !== &#x27;object&#x27;) &#123; return; &#125; return new Observer(value);&#125;;var uid = 0;function Dep() &#123; this.id = uid++; this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, depend: function() &#123; Dep.target.addDep(this); &#125;, removeSub: function(sub) &#123; var index = this.subs.indexOf(sub); if (index != -1) &#123; this.subs.splice(index, 1); &#125; &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125;; 实现Compilecompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189function Compile(el, vm) &#123; this.$vm = vm; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) &#123; this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; constructor: Compile, node2Fragment: function(el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;, init: function() &#123; this.compileElement(this.$fragment); &#125;, compileElement: function(el) &#123; var childNodes = el.childNodes, me = this; [].slice.call(childNodes).forEach(function(node) &#123; var text = node.textContent; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; if (me.isElementNode(node)) &#123; me.compile(node); &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; me.compileText(node, RegExp.$1.trim()); &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; me.compileElement(node); &#125; &#125;); &#125;, compile: function(node) &#123; var nodeAttrs = node.attributes, me = this; [].slice.call(nodeAttrs).forEach(function(attr) &#123; var attrName = attr.name; if (me.isDirective(attrName)) &#123; var exp = attr.value; var dir = attrName.substring(2); // 事件指令 if (me.isEventDirective(dir)) &#123; compileUtil.eventHandler(node, me.$vm, exp, dir); // 普通指令 &#125; else &#123; compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); &#125; node.removeAttribute(attrName); &#125; &#125;); &#125;, compileText: function(node, exp) &#123; compileUtil.text(node, this.$vm, exp); &#125;, isDirective: function(attr) &#123; return attr.indexOf(&#x27;v-&#x27;) == 0; &#125;, isEventDirective: function(dir) &#123; return dir.indexOf(&#x27;on&#x27;) === 0; &#125;, isElementNode: function(node) &#123; return node.nodeType == 1; &#125;, isTextNode: function(node) &#123; return node.nodeType == 3; &#125;&#125;;// 指令处理集合var compileUtil = &#123; text: function(node, vm, exp) &#123; this.bind(node, vm, exp, &#x27;text&#x27;); &#125;, html: function(node, vm, exp) &#123; this.bind(node, vm, exp, &#x27;html&#x27;); &#125;, model: function(node, vm, exp) &#123; this.bind(node, vm, exp, &#x27;model&#x27;); var me = this, val = this._getVMVal(vm, exp); node.addEventListener(&#x27;input&#x27;, function(e) &#123; var newValue = e.target.value; if (val === newValue) &#123; return; &#125; me._setVMVal(vm, exp, newValue); val = newValue; &#125;); &#125;, class: function(node, vm, exp) &#123; this.bind(node, vm, exp, &#x27;class&#x27;); &#125;, bind: function(node, vm, exp, dir) &#123; var updaterFn = updater[dir + &#x27;Updater&#x27;]; updaterFn &amp;&amp; updaterFn(node, this._getVMVal(vm, exp)); new Watcher(vm, exp, function(value, oldValue) &#123; updaterFn &amp;&amp; updaterFn(node, value, oldValue); &#125;); &#125;, // 事件处理 eventHandler: function(node, vm, exp, dir) &#123; var eventType = dir.split(&#x27;:&#x27;)[1], fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp]; if (eventType &amp;&amp; fn) &#123; node.addEventListener(eventType, fn.bind(vm), false); &#125; &#125;, _getVMVal: function(vm, exp) &#123; var val = vm; exp = exp.split(&#x27;.&#x27;); exp.forEach(function(k) &#123; val = val[k]; &#125;); return val; &#125;, _setVMVal: function(vm, exp, value) &#123; var val = vm; exp = exp.split(&#x27;.&#x27;); exp.forEach(function(k, i) &#123; // 非最后一个key，更新val的值 if (i &lt; exp.length - 1) &#123; val = val[k]; &#125; else &#123; val[k] = value; &#125; &#125;); &#125;&#125;;var updater = &#123; textUpdater: function(node, value) &#123; node.textContent = typeof value == &#x27;undefined&#x27; ? &#x27;&#x27; : value; &#125;, htmlUpdater: function(node, value) &#123; node.innerHTML = typeof value == &#x27;undefined&#x27; ? &#x27;&#x27; : value; &#125;, classUpdater: function(node, value, oldValue) &#123; var className = node.className; className = className.replace(oldValue, &#x27;&#x27;).replace(/\\s$/, &#x27;&#x27;); var space = className &amp;&amp; String(value) ? &#x27; &#x27; : &#x27;&#x27;; node.className = className + space + value; &#125;, modelUpdater: function(node, value, oldValue) &#123; node.value = typeof value == &#x27;undefined&#x27; ? &#x27;&#x27; : value; &#125;&#125;; 实现WatcherWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function Watcher(vm, expOrFn, cb) &#123; this.cb = cb; this.vm = vm; this.expOrFn = expOrFn; this.depIds = &#123;&#125;; if (typeof expOrFn === &#x27;function&#x27;) &#123; this.getter = expOrFn; &#125; else &#123; this.getter = this.parseGetter(expOrFn.trim()); &#125; console.log(&#x27;qqqq&#x27;, typeof this.getter, expOrFn); this.value = this.get();&#125;Watcher.prototype = &#123; constructor: Watcher, update: function() &#123; this.run(); &#125;, run: function() &#123; var value = this.get(); var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); &#125; &#125;, addDep: function(dep) &#123; // 1. 每次调用run()的时候会触发相应属性的getter // getter里面会触发dep.depend()，继而触发这里的addDep // 2. 假如相应属性的dep.id已经在当前watcher的depIds里，说明不是一个新的属性，仅仅是改变了其值而已 // 则不需要将当前watcher添加到该属性的dep里 // 3. 假如相应属性是新的属性，则将当前watcher添加到新属性的dep里 // 如通过 vm.child = &#123;name: &#x27;a&#x27;&#125; 改变了 child.name 的值，child.name 就是个新属性 // 则需要将当前watcher(child.name)加入到新的 child.name 的dep里 // 因为此时 child.name 是个新值，之前的 setter、dep 都已经失效，如果不把 watcher 加入到新的 child.name 的dep中 // 通过 child.name = xxx 赋值的时候，对应的 watcher 就收不到通知，等于失效了 // 4. 每个子属性的watcher在添加到子属性的dep的同时，也会添加到父属性的dep // 监听子属性的同时监听父属性的变更，这样，父属性改变时，子属性的watcher也能收到通知进行update // 这一步是在 this.get() --&gt; this.getVMVal() 里面完成，forEach时会从父级开始取值，间接调用了它的getter // 触发了addDep(), 在整个forEach过程，当前wacher都会加入到每个父级过程属性的dep // 例如：当前watcher的是&#x27;child.child.name&#x27;, 那么child, child.child, child.child.name这三个属性的dep都会加入当前watcher if (!this.depIds.hasOwnProperty(dep.id)) &#123; dep.addSub(this); this.depIds[dep.id] = dep; &#125; &#125;, get: function() &#123; Dep.target = this; var value = this.getter.call(this.vm, this.vm); Dep.target = null; return value; &#125;, parseGetter: function(exp) &#123; if (/[^\\w.$]/.test(exp)) return; var exps = exp.split(&#x27;.&#x27;); console.log(&#x27;vvv&#x27;, this.vm); return function(obj) &#123; for (var i = 0, len = exps.length; i &lt; len; i++) &#123; if (!obj) return; obj = obj[exps[i]]; &#125; console.log(&#x27;ooo&#x27;, obj); return obj; &#125; &#125;&#125;; 实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。 实现MVVMMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM({data:{name: ‘kindeng’}}); vm._data.name = ‘dmq’; 这样的方式来改变数据。 显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的： var vm = new MVVM({data: {name: ‘kindeng’}}); vm.name = ‘dmq’; 所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function MVVM(options) &#123; this.$options = options || &#123;&#125;; var data = this._data = this.$options.data; var me = this; // 数据代理 // 实现 vm.xxx -&gt; vm._data.xxx Object.keys(data).forEach(function(key) &#123; me._proxyData(key); &#125;); this._initComputed(); observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; constructor: MVVM, $watch: function(key, cb, options) &#123; new Watcher(this, key, cb); &#125;, _proxyData: function(key, setter, getter) &#123; var me = this; setter = setter || Object.defineProperty(me, key, &#123; configurable: false, enumerable: true, get: function proxyGetter() &#123; return me._data[key]; &#125;, set: function proxySetter(newVal) &#123; me._data[key] = newVal; &#125; &#125;); &#125;, _initComputed: function() &#123; var me = this; var computed = this.$options.computed; if (typeof computed === &#x27;object&#x27;) &#123; Object.keys(computed).forEach(function(key) &#123; Object.defineProperty(me, key, &#123; get: typeof computed[key] === &#x27;function&#x27; ? computed[key] : computed[key].get, set: function() &#123;&#125; &#125;); &#125;); &#125; &#125;&#125;; 实例化代码12345678910111213141516171819202122232425262728var vm = new MVVM(&#123; el: &#x27;#mvvm-app&#x27;, data: &#123; someStr: &#x27;hello &#x27;, className: &#x27;btn&#x27;, htmlStr: &#x27;&lt;span style=&quot;color: #f00;&quot;&gt;red&lt;/span&gt;&#x27;, child: &#123; someStr: &#x27;World !&#x27; &#125; &#125;, computed: &#123; getHelloWord: function() &#123; return this.someStr + this.child.someStr; &#125; &#125;, methods: &#123; clickBtn: function(e) &#123; var randomStrArr = [&#x27;childOne&#x27;, &#x27;childTwo&#x27;, &#x27;childThree&#x27;]; this.child.someStr = randomStrArr[parseInt(Math.random() * 3)]; &#125; &#125;&#125;);vm.$watch(&#x27;child.someStr&#x27;, function() &#123; console.log(arguments);&#125;);","categories":[{"name":"vue.js","slug":"vue-js","permalink":"http://example.com/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://example.com/tags/vue-js/"}]},{"title":"函数防抖与函数节流","slug":"函数防抖与函数节流","date":"2021-02-22T02:05:18.000Z","updated":"2021-04-25T03:06:39.868Z","comments":true,"path":"2021/02/22/函数防抖与函数节流/","link":"","permalink":"http://example.com/2021/02/22/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/","excerpt":"","text":"debounce-函数防抖：将一个弹簧按下，继续加压，继续按下，只会在最后放手的一瞬反弹。即我们希望函数只会调用一次，即使在这之前反复调用它，最终也只会调用一次而已。 throttle-函数节流：一个水龙头在滴水，可能一次性会滴很多滴，但是我们只希望它每隔 500ms 滴一滴水，保持这个频率。即我们希望函数在以一个可以接受的频率重复调用。 函数防抖基本思想 某些代码不可以在没有间断的情况下连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作(清除定时器)就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。 基本实现1234567891011function debounce(fn, wait) &#123; let timer; return function() &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, wait) &#125;&#125; 函数节流throttle-函数节流：一个水龙头在滴水，可能一次性会滴很多滴，但是我们只希望它每隔 500ms 滴一滴水，保持这个频率。即我们希望函数在以一个可以接受的频率重复调用。 12345678910111213function throttle(fn, wait) &#123; let previous = 0; // 用于记录上一次执行的时间 return function() &#123; let now = +new Date(); let remain = wait - (now - previous); if (remain &lt; 0) &#123; previous = now; fn.apply(this, arguments) &#125; &#125;&#125; 事件第一次触发的时候我要执行该函数，事件停止后，也要再触发一次函数。 1234567891011121314151617181920212223242526272829function throttle(fn, wait, options = &#123;&#125;) &#123; let previous = 0; // 用于记录上一次执行的时间 let timeout; return function() &#123; let now = +new Date(); let remain = wait - (now - previous); if (remain &lt; 0) &#123; if (previous === 0 &amp;&amp; !options.begin) &#123; previous = now; return &#125; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; fn.apply(this, arguments) &#125; else if (!timeout &amp;&amp; options.end) &#123; timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); timeout = null; &#125;, wait) &#125; &#125;&#125; 这样就完成了强大的节流函数了， 第一次来的时候，可以执行一次回调函数，结束的时候也会执行一次回调函数。并且可以通过options来配置。 如果设置了options.begin === true就第一触发事件就立刻会执行回调函数。因为我们设置previous的的初始值为0，所以如果previous === 0就表示是第一次触发该事件，与上options.begin就可以得出第一次是否执行该回调函数。 如果设置了options.end === true事件停止触发后也会执行一次该回调函数。其实在事件触发的整个时间内，定时器中的回调函数从来都没有被执行过，只有在事件停止出发后，定时器内的回调函数才被执行。只要设置了options.end就相当于只是用计算时间的方式来实现节流。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"工具函数","slug":"工具函数","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"}]},{"title":"三次握手与四次挥手理解","slug":"三次握手与四次挥手理解","date":"2021-02-20T10:13:48.000Z","updated":"2021-04-25T03:06:39.867Z","comments":true,"path":"2021/02/20/三次握手与四次挥手理解/","link":"","permalink":"http://example.com/2021/02/20/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%90%86%E8%A7%A3/","excerpt":"","text":"1.三次握手过程理解 第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 2.四次挥手过程理解 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 常见问题1.为什么连接的时候是三次握手，关闭的时候却是四次握手？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到Server端所有的报文都发送完了，才能发送FIN报文，因此不能一起发送。故需要四步握手。 __2.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？__ 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 3.为什么不能用两次握手进行连接？ 3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机Server和Client之间的通信，假定Client给Server发送一个连接请求分组，Server收到了这个分组，并发送了确认应答分组。按照两次握手的协定，Server认为连接已经成功地建立了，可以开始发送数据分组。可是，Client在Server的应答分组在传输中被丢失的情况下，将不知道Server是否已准备好，不知道Server建立什么样的序列号，Client甚至怀疑Server是否收到自己的连接请求分组。在这种情况下，Client认为连接还未建立成功，将忽略Server发来的任何数据分组，只等待连接确认应答分组。而Server在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 4.如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。","categories":[{"name":"http","slug":"http","permalink":"http://example.com/categories/http/"}],"tags":[{"name":"http协议","slug":"http协议","permalink":"http://example.com/tags/http%E5%8D%8F%E8%AE%AE/"}]},{"title":"前端经典算法题","slug":"前端经典算法题","date":"2021-02-19T08:02:26.000Z","updated":"2021-04-25T03:06:39.869Z","comments":true,"path":"2021/02/19/前端经典算法题/","link":"","permalink":"http://example.com/2021/02/19/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98/","excerpt":"","text":"1.判断一个字符串是否回文回文是指类似于“上海自来水来自海上”或者“madam”，从前往后和从后往前读，字符串的内容是一样的，称为回文。判断一个字符串是否是回文有很多种思路： 1.创建一个与原字符串前后倒过来的新字符串，比较二者是否相等，如果相等则是回文 1.1 利用中介Array.reverse()的反转数组的特性123456function isPalindRome(str) &#123; return str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) === str;&#125;console.log(isPalindRome(&#x27;madam&#x27;)); //trueconsole.log(isPalindRome(&#x27;mada&#x27;)); //false 1.2 不利用任何方法，手动创建新字符串1234567function isPalindRome(str) &#123; let newStr = &#x27;&#x27;; for(let i = str.length - 1; i &gt;= 0; i --)&#123; newStr = newStr + str[i]; &#125; return newStr === str;&#125; 2.从字符串的头和尾开始，依次比较字符串组是否相等，逐渐往中间收，如果全部相等，则是回文 123456789function isPalindRome(str) &#123; let length = str.length; for(let i = 0; i &lt;= Math.floor(str.length / 2); i ++)&#123; if(str[i] !== str[length - 1 - i])&#123; return false; &#125; &#125; return true;&#125; 2.数组去重 2.1 利用ES6新增的Set，因为Set的元素是非重复的 12345function deduplicate(arr) &#123; return [...new Set(arr)] // return Array.from(new Set(arr))&#125; 2.2 创建一个新数组，只包含源数组非重复的元素 123456789function deduplicate(arr) &#123; let newArray = []; for (let i of arr) &#123; if (newArray.indexOf(i) === -1) &#123; newArray.push(i); &#125; &#125; return newArray;&#125; 3: 统计字符串中出现最多次数的字符及其次数1234567891011121314151617181920function getMaxCount(str) &#123; let resultMap = new Map(); for (let letter of str) &#123; if (resultMap.has(letter)) &#123; resultMap.set(letter, resultMap.get(letter) + 1); &#125; else &#123; resultMap.set(letter, 1); &#125; &#125; let maxCount = Math.max(...resultMap.values()) let maxCountLetters = []; //可能几个字符同时都是出现次数最多的，所以用一个Array去装这些字符 resultMap.forEach((value, key, mapSelf) =&gt; &#123; if (value === maxCount) &#123; maxCountLetters.push(key); &#125; &#125;) return &#123;maxCountLetters, maxCount&#125;&#125; 4.滑动窗口算法什么是滑动窗口？滑动窗口算法是在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这就降低了问题的复杂度，从而也降低了循环的嵌套深度。滑动窗口主要应用在数组和字符串的场景。 简单示例先通过一个简单的示例来看一下滑动窗口的运作，比如有一个数组[1,3,5,6,2,2]，设定滑动窗口（window）大小为3，那么当窗口从数组开始位置滑动到最终位置时依次计算每个窗口内3个元素的和，表示为sum。 上图我们可以看出，随着窗口在数组上向右移动，窗口内的数据也在不断变化，我们只用对窗口内连续区间内的数据进行处理即可。由于区间是连续的，因此当窗口移动时只用对旧窗口的数据进行裁剪处理，这样便减少了重复计算，降低了时间复杂度。 以上图为例，当窗口位于[1,3,5]时，处理完该窗口的数据之后，将窗口向右移动一格，等于是将原有窗口左边的1裁剪掉，然后将窗口右边的6添加上，而整个过程看起来就像窗口在向右移动一样。 对于类似“请找到满足 xx 的最 x 的区间（子串、子数组）的 xx ”这类问题都可以使用该方法进行解决。 滑动窗口的基本步骤需要注意的是：窗口的移动是按照移动的顺序来进行的；窗口的大小不一定是固定的，可以不断缩小或变大的。 对于滑动窗口算法的基本解题思路，以字符串S示例如下： （1）采用双指针来指定窗口的范围，初始化left=right=0，而索引闭区间[left,right]便是一个窗口。（2）不断增大窗口的right指针，直到窗口中的字符串满足条件。（3）此时，停止right的增加，转而不断增加left指针，用于缩小窗口[left,right]，直到窗口中的字符串不再符合要求。每增加一次left，需要更新一轮结果。（4）重复第2和第3步，直到right到达字符串的尽头。其中，第2步相当于在寻找一个「可行解」，然后第3步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。 案例题目: 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例: 输入: s = “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 1234567891011121314151617181920function calLength(str) &#123; let l = str.length; let max = 0, right = 0; let map = new Map(); for (let i = 0; i &lt; l; i++) &#123; if (i !== 0) &#123; map.delete(str.charAt(i - 1)) &#125; while(right &lt; l &amp;&amp; !map.has(str.charAt(right))) &#123; map.set(str.charAt(right), str.charAt(right)) right++; &#125; max = Math.max(max, map.size) &#125; return max&#125; 遍历二叉树所有节点1.构造节点12345function Node(value) &#123; this.value = value this.left = left this.right = right&#125; 2.构造二叉树12345678910111213function createNode() &#123; let root = new Node(&#x27;A&#x27;) root.left = new Node(&#x27;B&#x27;) root.left.left = new Node(&#x27;D&#x27;) root.left.right = new Node(&#x27;E&#x27;) root.left.left.left = new Node(&#x27;F&#x27;) root.right = new Node(&#x27;C&#x27;) root.right.left = new Node(&#x27;G&#x27;) root.right.right = new Node(&#x27;H&#x27;) root.right.right.right = new Node(&#x27;M&#x27;) return root&#125; 3.遍历二叉树1234567891011121314function getAllNode(node) &#123; let nodeList = [] nodeList.push(node.value) if (node.left) &#123; nodeList.push(...getAllNode(node.left)) &#125; if (node.right) &#123; nodeList.push(...getAllNode(node.right)) &#125; return nodeList&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"IntersectionObserver API 使用教程","slug":"IntersectionObserver-API-使用教程","date":"2021-02-19T01:58:01.000Z","updated":"2021-04-25T03:06:39.860Z","comments":true,"path":"2021/02/19/IntersectionObserver-API-使用教程/","link":"","permalink":"http://example.com/2021/02/19/IntersectionObserver-API-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"网页开发时，常常需要了解某个元素是否进入了”视口”（viewport），即用户能不能看到它。 上图的绿色方块不断滚动，顶部会提示它的可见性。 传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成性能问题。 目前有一个新的 IntersectionObserver API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。 一、API1var io = new IntersectionObserver(callback, option); 上面代码中，IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。 构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。 12345678// 开始观察io.observe(document.getElementById(&#x27;example&#x27;));// 停止观察io.unobserve(element);// 关闭观察器io.disconnect(); 上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。 12io.observe(elementA);io.observe(elementB); 二、callback 参数目标元素的可见性变化时，就会调用观察器的回调函数callback。 callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。 123var io = new IntersectionObserver(entries =&gt; &#123; console.log(entries);&#125;); 上面代码中，回调函数采用的是箭头函数的写法。callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。 三、IntersectionObserverEntry对象IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性。 123456789101112131415161718192021222324252627282930&#123; // 可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 time: 3893.92, // 根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null rootBounds: ClientRect &#123; bottom: 920, height: 1024, left: 0, right: 1024, top: 0, width: 920 &#125;, // 目标元素的矩形区域的信息 boundingClientRect: ClientRect &#123; // ... &#125;, // 目标元素与视口（或根元素）的交叉区域的信息 intersectionRect: ClientRect &#123; // ... &#125;, // 目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0 intersectionRatio: 0.54, // 被观察的目标元素，是一个 DOM 节点对象 target: element&#125; 四、实例：惰性加载（lazy load）有时，我们希望某些静态资源（比如图片），只有用户向下滚动，它们进入视口时才加载，这样可以节省带宽，提高网页性能。这就叫做”惰性加载”。 有了 IntersectionObserver API，实现起来就很容易了。 123456789101112131415161718function query(selector) &#123; return Array.from(document.querySelectorAll(selector));&#125;var observer = new IntersectionObserver( function(changes) &#123; changes.forEach(function(change) &#123; var container = change.target; var content = container.querySelector(&#x27;template&#x27;).content; container.appendChild(content); observer.unobserve(container); &#125;); &#125;);query(&#x27;.lazy-loaded&#x27;).forEach(function (item) &#123; observer.observe(item);&#125;); 上面代码中，只有目标区域可见时，才会将模板内容插入真实 DOM，从而引发静态资源的加载。 五、实例：无限滚动无限滚动（infinite scroll）的实现也很简单。 1234567891011var intersectionObserver = new IntersectionObserver(function (entries) &#123; // 如果不可见，就返回 if (entries[0].intersectionRatio &lt;= 0) return; loadItems(10); console.log(&#x27;Loaded new items&#x27;);&#125;);// 开始观察intersectionObserver.observe( document.querySelector(&#x27;.scrollerFooter&#x27;)); 无限滚动时，最好在页面底部有一个页尾栏（又称sentinels）。一旦页尾栏可见，就表示用户到达了页面底部，从而加载新的条目放在页尾栏前面。这样做的好处是，不需要再一次调用observe()方法，现有的IntersectionObserver可以保持使用。 六、Option 对象IntersectionObserver构造函数的第二个参数是一个配置对象。它可以设置以下属性。 6.1 threshold 属性threshold属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。 123new IntersectionObserver(entries =&gt; &#123;/* ... */&#125;, &#123; threshold: [0, 0.25, 0.5, 0.75, 1]&#125;); 用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。 6.2 root 属性，rootMargin 属性很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在iframe窗口里滚动）。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。 IntersectionObserver API 支持容器内滚动。root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。 123456789var opts = &#123; root: document.querySelector(&#x27;.container&#x27;), rootMargin: &quot;500px 0px&quot; &#125;;var observer = new IntersectionObserver( callback, opts); 上面代码中，除了root属性，还有rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。 这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。 七、注意点IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。 规格写明，IntersectionObserver的实现，应该采用requestIdleCallback()，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"懒加载/无限滚动","slug":"懒加载-无限滚动","permalink":"http://example.com/tags/%E6%87%92%E5%8A%A0%E8%BD%BD-%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8/"}]},{"title":"从0到1实现一个完整的promise","slug":"从0到1实现一个完整的promise","date":"2021-01-04T09:48:31.000Z","updated":"2021-04-25T03:06:39.867Z","comments":true,"path":"2021/01/04/从0到1实现一个完整的promise/","link":"","permalink":"http://example.com/2021/01/04/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84promise/","excerpt":"","text":"基础框架new Promise()时接收一个executor函数作为参数，该函数会立即执行，函数中有两个参数，它们也是函数，分别是resolve和reject，函数同步执行一定要放在try…catch中，否则无法进行错误捕获。 12345678910function MyPromise(executor) &#123; try &#123; // 这里要保证executor中传入的resolve和reject的this指向一致 executor(this.resolve.bind(this), this.reject.bind(this)) &#125; catch (reason) &#123; this.reject(reason) &#125;&#125;MyPromise.prototype.resolve = function(value) &#123; /* ...some code */ &#125;MyPromise.prototype.reject = function(reason) &#123; /* ...some code */ &#125; 添加状态机 Promise是一个状态机的机制，初始状态为 pending，成功状态为 fulfilled，失败状态为 rejected。只能从 pending -&gt; fulfilled，或者从 pending -&gt; rejected，并且状态一旦转变，就永远不会再变了。 123456789101112131415161718192021function MyPromise(executor) &#123; this.state = &#x27;pending&#x27; try &#123; // 这里要保证executor中传入的resolve和reject的this指向一致 executor(this.resolve.bind(this), this.reject.bind(this)) &#125; catch (reason) &#123; this.reject(reason) &#125;&#125;MyPromise.prototype.resolve = function(value) &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;fulfilled&#x27; /* ...some code */ &#125;&#125;MyPromise.prototype.reject = function(reason) &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;rejected&#x27; /* ...some code */ &#125;&#125; 添加then方法 Promise拥有一个then方法，接收两个函数 onFulfilled 和 onRejected，分别作为Promise成功和失败的回调。所以，在then方法中我们需要对状态state进行判断，如果是fulfilled，则执行onFulfilled(value)方法，如果是rejected，则执行onRejected(reason)方法。 由于成功值value和失败原因reason是由用户在executor中通过resolve(value) 和 reject(reason)传入的，所以我们需要有一个全局的value和reason供后续方法获取。 12345678910111213141516171819202122232425262728293031323334function MyPromise(executor) &#123; this.state = &#x27;pending&#x27; this.value = null this.reason = null try &#123; // 这里要保证executor中传入的resolve和reject的this指向一致 executor(this.resolve.bind(this), this.reject.bind(this)) &#125; catch (reason) &#123; this.reject(reason) &#125;&#125;MyPromise.prototype.resolve = function(value) &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;fulfilled&#x27; this.value = value /* ...some code */ &#125;&#125;MyPromise.prototype.reject = function(reason) &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;rejected&#x27; this.reason = reason /* ...some code */ &#125;&#125;MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; if (this.state === &#x27;fulfilled&#x27;) &#123; onFulfilled(this.value) &#125; if (this.state === &#x27;rejected&#x27;) &#123; onRejected(this.reason) &#125;&#125; 实现异步调用resolve 同步调用resolve()没有问题，但如果是异步调用，比如放到setTimeout中，因为目前的代码在调用then()方法时，state仍是pending状态，当timer到时候调用resolve()把state修改为fulfilled状态，但是onFulfilled()函数已经没有时机调用了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function MyPromise(executor) &#123; this.state = &#x27;pending&#x27; this.value = null this.reason = null this.fulfillCallbacks = [] this.rejectedCallbacks = [] try &#123; // 这里要保证executor中传入的resolve和reject的this指向一致 executor(this.resolve.bind(this), this.reject.bind(this)) &#125; catch (reason) &#123; this.reject(reason) &#125;&#125;MyPromise.prototype.resolve = function(value) &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;fulfilled&#x27; this.value = value this.fulfillCallbacks.forEach(fulfillCallback =&gt; &#123; fulfillCallback() &#125;) &#125;&#125;MyPromise.prototype.reject = function(reason) &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;rejected&#x27; this.reason = reason this.rejectedCallbacks.forEach(rejectedCallback =&gt; &#123; rejectedCallback() &#125;) &#125;&#125;MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; if (this.state === &#x27;pending&#x27;) &#123; this.fulfillCallbacks.push(() =&gt; &#123; onFulfilled(this.value) &#125;) this.rejectedCallbacks.push(() =&gt; &#123; onRejected(this.reason) &#125;) &#125; if (this.state === &#x27;fulfilled&#x27;) &#123; onFulfilled(this.value) &#125; if (this.state === &#x27;rejected&#x27;) &#123; onRejected(this.reason) &#125;&#125; 我们添加了两个回调函数数组onFulfilledCallbacks和onRejectedCallbacks，用来存储then()方法中传入的成功和失败回调。然后，当用户调用resolve()或reject()的时候，修改state状态，并从相应的回调数组中依次取出回调函数执行。 同时，通过这种方式我们也实现了可以注册多个then()函数，并且在成功或者失败时按照注册顺序依次执行。 then返回的仍是Promise 读过PromiseA+规范的同学肯定知道，then()方法返回的仍是一个Promise，并且返回Promise的resolve的值是上一个Promise的onFulfilled()函数或onRejected()函数的返回值。如果在上一个Promise的then()方法回调函数的执行过程中发生了错误，那么会将其捕获到，并作为返回的Promise的onRejected函数的参数传入。 123456789101112131415161718192021222324252627282930313233MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; let promise2 = null // 创建一个onCall统一处理 let onCall = (promise2, onCallFn, v, resolve, reject) =&gt; &#123; try &#123; let x = onCallFn(v) this.resolvePromise(promise2, x, resolve, reject) &#125; catch (reason) &#123; reject(reason) &#125; &#125; promise2 = new MyPromise((resolve, reject) =&gt; &#123; if (this.state === &#x27;pending&#x27;) &#123; this.fulfillCallbacks.push(() =&gt; &#123; onCall(promise2, onFulfilled, this.value, resolve, reject) &#125;) this.rejectedCallbacks.push(() =&gt; &#123; onCall(promise2, onRejected, this.reason, resolve, reject) &#125;) &#125; if (this.state === &#x27;fulfilled&#x27;) &#123; onCall(promise2, onFulfilled, this.value, resolve, reject) &#125; if (this.state === &#x27;rejected&#x27;) &#123; onCall(promise2, onRejected, this.reason, resolve, reject) &#125; &#125;) return promise2&#125; resolvePromise()是用来解析then()回调函数中返回的仍是一个Promise，这个Promise有可能是我们自己的，有可能是别的库实现的，也有可能是一个具有then()方法的对象，所以这里靠resolvePromise()来实现统一处理。 12345678910111213141516171819202122232425262728293031323334353637MyPromise.prototype.resolvePromise = function(promise2, x, resolve, reject) &#123; let called = false // called 防止多次调用 if (promise2 === x) &#123; return reject(new TypeError(&#x27;循环引用&#x27;)) &#125; let typeX = Object.prototype.toString.call(x) if (typeX !== null &amp;&amp; (typeX === &#x27;[object Object]&#x27; || typeX === &#x27;[object Function]&#x27;)) &#123; try &#123; let then = x.then if (typeof then === &#x27;function&#x27;) &#123; then.call(x, v =&gt; &#123; if (called) return called = true this.resolvePromise(promise2, v, resolve, reject) &#125;, reason =&gt; &#123; if (called) return called = true reject(reason) &#125;) &#125; else &#123; if (called) return called = true resolve(x) &#125; &#125; catch (reason) &#123; if (called) return called = true reject(reason) &#125; &#125; else &#123; // x是普通值，直接resolve resolve(x) &#125;&#125; 下面是翻译自PromiseA+规范关于resolvePromise()的要求： Promise 解决过程 Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 [[Resolve]](promise, x)，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。 这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。 运行 [[Resolve]](promise, x) 需遵循以下步骤： x 与 promise 相等如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise x 为 Promise如果 x 为 Promise ，则使 promise 接受 x 的状态: 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝 如果 x 处于执行态，用相同的值执行 promise 如果 x 处于拒绝态，用相同的据因拒绝 promise x 为对象或函数如果 x 为对象或者函数： 把 x.then 赋值给 then 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise 如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 如果调用 then 方法抛出了异常 e： 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 否则以 e 为据因拒绝 promise 如果 then 不是函数，以 x 为参数执行 promise 如果 x 不为对象或者函数，以 x 为参数执行 promise 如果一个 promise 被一个循环的 thenable 链中的对象解决，而 [[Resolve]](promise, thenable) 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为据因来拒绝 promise。 参考上述规范，结合代码中的注释，相信大家可以理解resolvePromise()的作用了。 实现catch()方法then()方法的onFulfilled和onRejected回调函数都不是必传项，如果不传，那么我们就无法接收reject(reason)中的错误，这时我们可以通过链式调用catch()方法用来接收错误。 不仅如此，catch()可以作为Promise链式调用的最后一步，前面Promise发生的错误会冒泡到最后一个catch()中，从而捕获异常。 那么catch()方法到底是如何实现的呢？ 答案就是在Promise的实现中，onFulfilled和onRejected函数是有默认值的： 12345678MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; &#123; return value &#125; onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125;&#125;MyPromise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected)&#125; 可以看到，onRejected的默认值是把错误reason通过throw抛出去。由于我们对于同步代码的执行都是在try…catch中的，所以如果Promise发生了错误，如果没传onRejected，默认的函数会把错误reason抛出，然后会被promise2捕捉到，作为reject(reason)决议。 catch()实现就是调用this.then(null, onRejected)，由于promise2被reject，所以会执行onRejected回调，于是就捕捉到了第一个promise的错误。 总结来说，then()方法中不传onRejected回调，Promise内部会默认帮你写一个函数作为回调，作用就是throw抛出reject或者try…catch到的错误，然后错误reason会被promise2作为reject(reason)进行决议，于是会被下一个then()方法的onRejected回调函数调用，而catch只是写了一个特殊的then(null, onRejected)而已。 所以，我们在写Promise的链式调用的时候，在then()中可以不传onRejected回调，只需要在链式调用的最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。 实现finally方法finally是某些库对Promise实现的一个扩展方法，无论是resolve还是reject，都会走finally方法。 123456789MyPromise.prototype.finally = function(finallyCallback) &#123; return this.then(value =&gt; &#123; finallyCallback() return value &#125;, reason =&gt; &#123; finallyCallback() throw reason &#125;)&#125; 实现done方法done方法作为Promise链式调用的最后一步，用来向全局抛出没有被Promise内部捕获的错误，并且不再返回一个Promise。一般用来结束一个Promise链。 12345MyPromise.prototype.done = function() &#123; return this.catch(reason =&gt; &#123; throw reason &#125;)&#125; 实现Promise.all方法Promise.all()接收一个包含多个Promise的数组，当所有Promise均为fulfilled状态时，返回一个结果数组，数组中结果的顺序和传入的Promise顺序一一对应。如果有一个Promise为rejected状态，则整个Promise.all为rejected。 1234567891011121314MyPromise.all = function(promiseList) &#123; return new MyPromise((resolve, reject) =&gt; &#123; let result = [] promiseList.forEach((promise, index) =&gt; &#123; promise.then(value =&gt; &#123; result[index] = value if (result.length === promiseList.length) &#123; resolve(result) &#125; &#125;, reject) &#125;) &#125;)&#125; 实现Promise.race方法Promise.race()接收一个包含多个Promise的数组，当有一个Promise为fulfilled状态时，整个大的Promise为onfulfilled，并执行onFulfilled回调函数。如果有一个Promise为rejected状态，则整个Promise.race为rejected。 123456789MyPromise.race = function(promiseList) &#123; return new MyPromise((resolve, reject) =&gt; &#123; promiseList.forEach(promise =&gt; &#123; promise.then(value =&gt; &#123; resolve(value) &#125;, reject) &#125;) &#125;)&#125; 实现Promise.resolve方法Promise.resolve用来生成一个fulfilled完成态的Promise，一般放在整个Promise链的开头，用来开始一个Promise链。 123456789MyPromise.resolve = function(value) &#123; let promise = null promise = new MyPromise((resolve, reject) =&gt; &#123; this.prototype.resolvePromise(promise, value, resolve, reject) &#125;) return promise&#125; 由于传入的value有可能是普通值，有可能是thenable，也有可能是另一个Promise，所以调用resolvePromise进行解析。 实现Promise.reject方法Promise.reject用来生成一个rejected失败态的Promise。 12345MyPromise.reject = function(reason) &#123; return new MyPromise((resolve, reject) =&gt; &#123; reject(reason) &#125;)&#125; 如何停止一个Promise链假设这样一个场景，我们有一个很长的Promise链式调用，这些Promise是依次依赖的关系，如果链条中的某个Promise出错了，就不需要再向下执行了，默认情况下，我们是无法实现这个需求的，因为Promise无论是then还是catch都会返回一个Promise，都会继续向下执行then或catch。举例： 123456789new Promise(function(resolve, reject) &#123; resolve(1111)&#125;).then(function(value) &#123; // &quot;ERROR!!!&quot;&#125;).catch() .then() .then() .catch() .then() 有没有办法让这个链式调用在ERROR!!!的后面就停掉，完全不去执行链式调用后面所有回调函数呢？ 我们自己封装一个Promise.stop方法。 123MyPromise.stop = function() &#123; return new MyPromise(function() &#123;&#125;);&#125;; stop中返回一个永远不执行resolve或者reject的Promise，那么这个Promise永远处于pending状态，所以永远也不会向下执行then或catch了。这样我们就停止了一个Promise链。 但是这样会有一个缺点，就是链式调用后面的所有回调函数都无法被垃圾回收器回收。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149function MyPromise(executor) &#123; this.state = &#x27;pending&#x27; this.value = null this.reason = null this.fulfillCallbacks = [] this.rejectedCallbacks = [] try &#123; executor(this.resolve.bind(this), this.reject.bind(this)) &#125; catch (reason) &#123; this.reject(reason) &#125;&#125;MyPromise.prototype.resolve = function(value) &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;fulfilled&#x27; this.value = value this.fulfillCallbacks.forEach(fulfillCallback =&gt; &#123; fulfillCallback() &#125;) &#125;&#125;MyPromise.prototype.reject = function(reason) &#123; if (this.state = &#x27;pending&#x27;) &#123; this.state = &#x27;rejected&#x27; this.reason = reason this.rejectedCallbacks.forEach(rejectedCallback =&gt; &#123; rejectedCallback() &#125;) &#125;&#125;MyPromise.prototype.then = function(onFilfilled, onRejected) &#123; onFilfilled = typeof onFilfilled === &#x27;function&#x27; ? onFilfilled : value =&gt; &#123; return value &#125; onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125; let promise2 = null let callOn = (promise2, callOnFn, v, resolve, reject) =&gt; &#123; try &#123; let x = callOnFn(v) this.resolvePromise(promise2, x, resolve, reject) &#125; catch (reason) &#123; reject(reason) &#125; &#125; promise2 = new MyPromise((resolve, reject) =&gt; &#123; if (this.state === &#x27;pending&#x27;) &#123; this.fulfillCallbacks.push(() =&gt; &#123; callOn(promise2, onFilfilled, this.value, resolve, reject) &#125;) this.rejectedCallbacks.push(() =&gt; &#123; callOn(promise2, onRejected, this.reason, resolve, reject) &#125;) &#125; if (this.state === &#x27;fulfilled&#x27;) &#123; callOn(promise2, onFilfilled, this.value, resolve, reject) &#125; if (this.state === &#x27;rejected&#x27;) &#123; callOn(promise2, onRejected, this.reason, resolve, reject) &#125; &#125;) return promise2&#125;MyPromise.prototype.resolvePromise = function(promise2, x, resolve, reject) &#123; let called = false if (promise2 === x) &#123; return reject(new TypeError(&#x27;循环引用&#x27;)) &#125; let typeX = Object.prototype.toString(x) if (typeX !== null &amp;&amp; (typeX === &#x27;[object Object]&#x27; || typeX === &#x27;[object Function]&#x27;)) &#123; try &#123; let then = x.then if (typeof then === &#x27;function&#x27;) &#123; then.call(x, v =&gt; &#123; if (called) return called = true this.resolvePromise(promise2, v, resolve, reject) &#125;, reason =&gt; &#123; if (called) return called = true reject(reason) &#125;) &#125; else &#123; if (called) return called = true resolve(x) &#125; &#125; catch (reason) &#123; if (called) return called = true reject(reason) &#125; &#125; else &#123; resolve(x) &#125;&#125;MyPromise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected)&#125;MyPromise.prototype.finally = function(fn) &#123; return this.then(value =&gt; &#123; fn() return value &#125;, reason =&gt; &#123; fn() throw reason &#125;)&#125;MyPromise.prototype.done = function() &#123; this.catch(reason =&gt; &#123; throw reason &#125;)&#125;MyPromise.all = function(promiseList) &#123; return new MyPromise((resolve, reject) =&gt; &#123; let result = [] promiseList.forEach((promise, index) =&gt; &#123; promise.then(value =&gt; &#123; result[index] = value if (result.length === promiseList.length) &#123; resolve(result) &#125; &#125;, reject) &#125;) &#125;)&#125;MyPromise.race = function(promiseList) &#123; return new MyPromise((resolve, reject) =&gt; &#123; promiseList.forEach(promise =&gt; &#123; promise.then(value =&gt; &#123; resolve(value) &#125;, reject) &#125;) &#125;)&#125;MyPromise.resolve = function(value) &#123; let promise; promise = new MyPromise((resolve, reject) =&gt; &#123; this.prototype.resolvePromise(promise, value, resolve, reject) &#125;) return promise;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"promise","slug":"promise","permalink":"http://example.com/tags/promise/"}]},{"title":"深入理解Nodejs进程与线程","slug":"深入理解Nodejs-进程与线程","date":"2020-11-03T08:25:07.000Z","updated":"2021-04-25T03:06:39.871Z","comments":true,"path":"2020/11/03/深入理解Nodejs-进程与线程/","link":"","permalink":"http://example.com/2020/11/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nodejs-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"进程进程 Process是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器。进程是资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。 Node.js开启服务进程例子 123456const http = require(&#x27;http&#x27;); const server = http.createServer(); server.listen(3000,()=&gt;&#123; process.title=&#x27;程序员成长指北测试进程&#x27;; console.log(&#x27;进程id&#x27;,process.pid) )&#125; 线程线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。 单线程 单线程就是一个进程只开一个线程 Javascript 就是属于单线程，程序顺序执行(这里暂且不提JS异步)，可以想象一下队列，前面一个执行完之后，后面才可以执行，当你在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。你如果采用 Javascript 进行编码时候，请尽可能的利用Javascript异步操作的特性。 经典计算耗时造成线程阻塞的例子 1234567891011121314151617181920212223const http = require(&#x27;http&#x27;); const longComputation = () =&gt; &#123; let sum = 0; for (let i = 0; i &lt; 1e10; i++) &#123; sum += i; &#125;; return sum; &#125;; const server = http.createServer(); server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; if (req.url === &#x27;/compute&#x27;) &#123; console.info(&#x27;计算开始&#x27;,new Date()); const sum = longComputation(); console.info(&#x27;计算结束&#x27;,new Date()); return res.end(`Sum is $&#123;sum&#125;`); &#125; else &#123; res.end(&#x27;Ok&#x27;) &#125; &#125;); server.listen(3000); //打印结果 //计算开始 2019-07-28T07:08:49.849Z //计算结束 2019-07-28T07:09:04.522Z 查看打印结果，当我们调用 127.0.0.1:3000/compute的时候，如果想要调用其他的路由地址比如127.0.0.1/大约需要15秒时间，也可以说一个用户请求完第一个 compute接口后需要等待15秒，这对于用户来说是极其不友好的。下文我会通过创建多进程的方式 child_process.fork 和 cluster 来解决解决这个问题。 单线程的一些说明 Node.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。 当你的项目中需要有大量计算，CPU 耗时的操作时候，要注意考虑开启多进程来完成了。 Node.js 开发过程中，错误会引起整个应用退出，应用的健壮性值得考验，尤其是错误的异常抛出，以及进程守护是必须要做的。 单线程无法利用多核CPU，但是后来Node.js 提供的API以及一些第三方工具相应都得到了解决，文章后面都会讲到。 Node.js 中的进程与线程Node.js 是 Javascript 在服务端的运行环境，构建在 chrome 的 V8 引擎之上，基于事件驱动、非阻塞I/O模型，充分利用操作系统提供的异步 I/O 进行多任务的执行，适合于 I/O 密集型的应用场景，因为异步，程序无需阻塞等待结果返回，而是基于回调通知的机制，原本同步模式等待的时间，则可以用来处理其它任务。 科普：在 Web 服务器方面，著名的 Nginx 也是采用此模式（事件驱动），避免了多线程的线程创建、线程上下文切换的开销，Nginx 采用 C 语言进行编写，主要用来做高性能的 Web 服务器，不适合做业务。 Web业务开发中，如果你有高并发应用场景那么 Node.js 会是你不错的选择。 在单核 CPU 系统之上我们采用 单进程 + 单线程 的模式来开发。在多核 CPU 系统之上，可以通过 child_process.fork 开启多个进程（Node.js 在 v0.8 版本之后新增了Cluster 来实现多进程架构） ，即 多进程 + 单线程 模式。注意：开启多进程不是为了解决高并发，主要是解决了单进程模式下 Node.js CPU 利用率不足的情况，充分利用多核 CPU 的性能。 Node.js 中的进程process 模块 Node.js 中的进程 Process 是一个全局对象，无需 require 直接使用，给我们提供了当前进程中的相关信息。官方文档提供了详细的说明，感兴趣的可以亲自实践下 Process 文档。 process.env:环境变量，例如通过 process.env.NODE_ENV 获取不同环境项目配置信息 process.nextTick:这个在谈及 EventLoop 时经常为会提到 process.pid:获取当前进程id process.ppid:当前进程对应的父进程 process.cwd():获取当前进程工作目录 process.platform:获取当前进程运行的操作系统平台 process.uptime():当前进程已运行时间，例如：pm2 守护进程的 uptime 值 进程事件:process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听 三个标准流:process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出 process.title 指定进程名称，有的时候需要给进程指定一个名称 以上仅列举了部分常用到功能点，除了 Process 之外 Node.js 还提供了 child_process 模块用来对子进程进行操作，在下文 Nodejs进程创建会继续讲述。 Node.js 进程创建 进程创建有多种方式，本篇文章以child_process模块和cluster模块进行讲解。 node是单进程的，必然存在一个问题，就是无法充分利用cpu等资源。node提供了child_process模块来实现子进程，从而实现一个广义上的多进程的模式。通过child_process模块，可以实现1个主进程，多个子进程的模式，主进程称为master进程，子进程又称工作进程。在子进程中不仅可以调用其他node程序，也可以执行非node程序以及shell命令等等，执行完子进程后，以流或者回调的形式返回。 cluster意为集成，集成了两个方面，第一个方面就是集成了child_process.fork方法创建node子进程的方式，第二个方面就是集成了根据多核CPU创建子进程后，自动控制负载均衡的方式。 __child_process模块__child_process 是 Node.js 的内置模块，官网地址： childprocess 官网地址：http://nodejs.cn/api/childprocess.html#childprocesschild_process 几个常用函数：四种方式 child_process.spawn()：适用于返回大量数据，例如图像处理，二进制数据处理。 child_process.exec()：适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。 child_process.execFile()：类似 child_process.exec()，区别是不能通过 shell 来执行，不支持像 I/O 重定向和文件查找这样的行为 child_process.fork()：衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统* CPU 核心数*设置。 CPU 核心数这里特别说明下，fork 确实可以开启多个进程，但是并不建议衍生出来太多的进程，cpu核心数的获取方式 constcpus=require(‘os’).cpus();,这里 cpus 返回一个对象数组，包含所安装的每个 CPU/内核的信息，二者总和的数组哦。假设主机装有两个cpu，每个cpu有4个核，那么总核数就是8。 fork开启子进程 Demo fork开启子进程解决文章起初的计算耗时造成线程阻塞。在进行 compute 计算时创建子进程，子进程计算完成通过 send 方法将结果发送给主进程，主进程通过 message 监听到信息后处理并退出 123456789101112131415161718192021222324// fork_app.jsconst http = require(&#x27;http&#x27;); const fork = require(&#x27;child_process&#x27;).fork; const server = http.createServer((req, res) =&gt; &#123; if(req.url == &#x27;/compute&#x27;)&#123; const compute = fork(&#x27;./fork_compute.js&#x27;); compute.send(&#x27;开启一个新的子进程&#x27;); // 当一个子进程使用 process.send() 发送消息时会触发 &#x27;message&#x27; 事件 compute.on(&#x27;message&#x27;, sum =&gt; &#123; res.end(`Sum is $&#123;sum&#125;`); compute.kill(); &#125;); // 子进程监听到一些错误消息退出 compute.on(&#x27;close&#x27;, (code, signal) =&gt; &#123; console.log(`收到close事件，子进程收到信号 $&#123;signal&#125; 而终止，退出码 $&#123;code&#125;`); compute.kill(); &#125;) &#125;else&#123; res.end(`ok`); &#125; &#125;); server.listen(3000, 127.0.0.1, () =&gt; &#123; console.log(`server started at http://$&#123;127.0.0.1&#125;:$&#123;3000&#125;`); &#125;); 针对文初需要进行计算的的例子我们创建子进程拆分出来单独进行运算。 123456789101112131415161718// fork_compute.jsconst computation = () =&gt; &#123; let sum = 0; console.info(&#x27;计算开始&#x27;); console.time(&#x27;计算耗时&#x27;); for (let i = 0; i &lt; 1e10; i++) &#123; sum += i &#125;; console.info(&#x27;计算结束&#x27;); console.timeEnd(&#x27;计算耗时&#x27;); return sum; &#125;; process.on(&#x27;message&#x27;, msg =&gt; &#123; console.log(msg, &#x27;process.pid&#x27;, process.pid); // 子进程id const sum = computation(); // 如果Node.js进程是通过进程间通信产生的，那么，process.send()方法可以用来给父进程发送消息 process.send(sum); &#125;) cluster模块cluster 开启子进程Demo 1234567891011121314151617181920const http = require(&#x27;http&#x27;); const numCPUs = require(&#x27;os&#x27;).cpus().length; const cluster = require(&#x27;cluster&#x27;); if(cluster.isMaster)&#123; console.log(&#x27;Master proces id is&#x27;,process.pid); // fork workers for(let i= 0;i&lt;numCPUs;i++)&#123; cluster.fork(); &#125; cluster.on(&#x27;exit&#x27;,function(worker,code,signal)&#123; console.log(&#x27;worker process died,id&#x27;,worker.process.pid) &#125;) &#125;else&#123; // Worker可以共享同一个TCP连接 // 这里是一个http服务器 http.createServer(function(req,res)&#123; res.writeHead(200); res.end(&#x27;hello word&#x27;); &#125;).listen(8000); &#125; cluster原理分析 cluster模块调用fork方法来创建子进程，该方法与child_process中的fork是同一个方法。cluster模块采用的是经典的主从模型，Cluster会创建一个master，然后根据你指定的数量复制出多个子进程，可以使用 cluster.isMaster属性判断当前进程是master还是worker(工作进程)。由master进程来管理所有的子进程，主进程不负责具体的任务处理，主要工作是负责调度和管理。 cluster模块使用内置的负载均衡来更好地处理线程之间的压力，该负载均衡使用了 Round-robin算法（也被称之为循环算法）。当使用Round-robin调度策略时，master accepts()所有传入的连接请求，然后将相应的TCP请求处理发送给选中的工作进程（该方式仍然通过IPC来进行通信）。 开启多进程时候端口疑问讲解：如果多个Node进程监听同一个端口时会出现 Error:listen EADDRIUNS的错误，而cluster模块为什么可以让多个子进程监听同一个端口呢?原因是master进程内部启动了一个TCP服务器，而真正监听端口的只有这个服务器，当来自前端的请求触发服务器的connection事件后，master会将对应的socket具柄发送给子进程。 __child_process模块与cluster模块总结__无论是 child_process 模块还是 cluster 模块，为了解决 Node.js 实例单线程运行，无法利用多核 CPU 的问题而出现的。核心就是父进程（即 master 进程）负责监听端口，接收到新的请求后将其分发给下面的 worker 进程。 cluster模块的一个弊端： cluster内部隐时的构建TCP服务器的方式来说对使用者确实简单和透明了很多，但是这种方式无法像使用childprocess那样灵活，因为一直主进程只能管理一组相同的工作进程，而自行通过childprocess来创建工作进程，一个主进程可以控制多组进程。原因是child_process操作子进程时，可以隐式的创建多个TCP服务器，对比上面的两幅图应该能理解我说的内容。 Node.js进程通信原理前面讲解的无论是child_process模块，还是cluster模块，都需要主进程和工作进程之间的通信。通过fork()或者其他API，创建了子进程之后，为了实现父子进程之间的通信，父子进程之间才能通过message和send()传递信息。 IPC这个词我想大家并不陌生，不管那一张开发语言只要提到进程通信，都会提到它。IPC的全称是Inter-Process Communication,即进程间通信。它的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道，匿名管道，socket，信号量，共享内存，消息队列等。Node中实现IPC通道是依赖于libuv。windows下由命名管道(name pipe)实现，*nix系统则采用Unix Domain Socket实现。表现在应用层上的进程间通信只有简单的message事件和send()方法，接口十分简洁和消息化。 IPC创建和实现示意图 IPC通信管道是如何创建的 父进程在实际创建子进程之前，会创建 IPC通道并监听它，然后才 真正的创建出 子进程，这个过程中也会通过环境变量（NODECHANNELFD）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接。 Node.js句柄传递 讲句柄之前，先想一个问题，send句柄发送的时候，真的是将服务器对象发送给了子进程？ 子进程对象send()方法可以发送的句柄类型 net.Socket TCP套接字 net.Server TCP服务器，任意建立在TCP服务上的应用层服务都可以享受它带来的好处 net.Native C++层面的TCP套接字或IPC管道 dgram.Socket UDP套接字 dgram.Native C++层面的UDP套接字 send句柄发送原理分析 send()方法在将消息发送到IPC管道前，实际将消息组装成了两个对象，一个参数是hadler，另一个是message。message参数如下所示： 12345&#123; cmd:&#x27;NODE_HANDLE&#x27;, type:&#x27;net.Server&#x27;, msg:message &#125; 发送到IPC管道中的实际上是我们要发送的句柄文件描述符。这个message对象在写入到IPC管道时，也会通过 JSON.stringfy()进行序列化。所以最终发送到IPC通道中的信息都是字符串，send()方法能发送消息和句柄并不意味着它能发送任何对象。 连接了IPC通道的子线程可以读取父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才触发message事件将消息传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cmd的值如果以NODE为前缀，它将响应一个内部事件internalMessage，如果message.cmd值为NODEHANDLE,它将取出 message.type值和得到的文件描述符一起还原出一个对应的对象。 以发送的TCP服务器句柄为例，子进程收到消息后的还原过程代码如下: 1234567function(message,handle,emit)&#123; var self = this; var server = new net.Server(); server.listen(handler,function()&#123; emit(server); &#125;); &#125; 这段还原代码， 子进程根据message.type创建对应的TCP服务器对象，然后监听到文件描述符上。由于底层细节不被应用层感知，所以子进程中，开发者会有一种服务器对象就是从父进程中直接传递过来的错觉。 Node进程之间只有消息传递，不会真正的传递对象，这种错觉是抽象封装的结果。目前Node只支持我前面提到的几种句柄，并非任意类型的句柄都能在进程之间传递，除非它有完整的发送和还原的过程。 Node.js多进程架构模型 编写主进程 master.js 主要处理以下逻辑： 创建一个 server 并监听 3000 端口。 根据系统 cpus 开启多个子进程 通过子进程对象的 send 方法发送消息到子进程进行通信 在主进程中监听了子进程的变化，如果是自杀信号重新启动一个工作进程。 主进程在监听到退出消息的时候，先退出子进程在退出主进程 123456789101112131415161718192021222324252627282930313233343536373839// master.js const fork = require(&#x27;child_process&#x27;).fork; const cpus = require(&#x27;os&#x27;).cpus(); const server = require(&#x27;net&#x27;).createServer(); server.listen(3000); process.title = &#x27;node-master&#x27; const workers = &#123;&#125;; const createWorker = () =&gt; &#123; const worker = fork(&#x27;worker.js&#x27;) worker.on(&#x27;message&#x27;, function (message) &#123; if (message.act === &#x27;suicide&#x27;) &#123; createWorker(); &#125; &#125;) worker.on(&#x27;exit&#x27;, function(code, signal) &#123; console.log(&#x27;worker process exited, code: %s signal: %s&#x27;, code, signal); delete workers[worker.pid]; &#125;); worker.send(&#x27;server&#x27;, server); workers[worker.pid] = worker; console.log(&#x27;worker process created, pid: %s ppid: %s&#x27;, worker.pid, process.pid); &#125; for (let i=0; i&lt;cpus.length; i++) &#123; createWorker(); &#125; process.once(&#x27;SIGINT&#x27;, close.bind(this, &#x27;SIGINT&#x27;)); // kill(2) Ctrl-C process.once(&#x27;SIGQUIT&#x27;, close.bind(this, &#x27;SIGQUIT&#x27;)); // kill(3) Ctrl-\\ process.once(&#x27;SIGTERM&#x27;, close.bind(this, &#x27;SIGTERM&#x27;)); // kill(15) default process.once(&#x27;exit&#x27;, close.bind(this)); function close (code) &#123; console.log(&#x27;进程退出！&#x27;, code); if (code !== 0) &#123; for (let pid in workers) &#123; console.log(&#x27;master process exited, kill worker pid: &#x27;, pid); workers[pid].kill(&#x27;SIGINT&#x27;); &#125; &#125; process.exit(0); &#125; 工作进程 worker.js 子进程处理逻辑如下： 创建一个 server 对象，注意这里最开始并没有监听 3000 端口 通过 message 事件接收主进程 send 方法发送的消息 监听 uncaughtException 事件，捕获未处理的异常，发送自杀信息由主进程重建进程，子进程在链接关闭之后退出 1234567891011121314151617181920212223242526// worker.js const http = require(&#x27;http&#x27;); const server = http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plan&#x27; &#125;); res.end(&#x27;I am worker, pid: &#x27; + process.pid + &#x27;, ppid: &#x27; + process.ppid); throw new Error(&#x27;worker process exception!&#x27;); // 测试异常进程退出、重启 &#125;); let worker; process.title = &#x27;node-worker&#x27; process.on(&#x27;message&#x27;, function (message, sendHandle) &#123; if (message === &#x27;server&#x27;) &#123; worker = sendHandle; worker.on(&#x27;connection&#x27;, function(socket) &#123; server.emit(&#x27;connection&#x27;, socket); &#125;); &#125; &#125;); process.on(&#x27;uncaughtException&#x27;, function (err) &#123; console.log(err); process.send(&#123;act: &#x27;suicide&#x27;&#125;); worker.close(function () &#123; process.exit(1); &#125;) &#125;) Node.js 进程守护什么是进程守护？ 每次启动 Node.js 程序都需要在命令窗口输入命令 node app.js 才能启动，但如果把命令窗口关闭则Node.js 程序服务就会立刻断掉。除此之外，当我们这个 Node.js 服务意外崩溃了就不能自动重启进程了。这些现象都不是我们想要看到的，所以需要通过某些方式来守护这个开启的进程，执行 node app.js 开启一个服务进程之后，我还可以在这个终端上做些别的事情，且不会相互影响。，当出现问题可以自动重启。 如何实现进程守护 这里我只说一些第三方的进程守护框架，pm2 和 forever ，它们都可以实现进程守护，底层也都是通过上面讲的 child_process 模块和 cluster 模块 实现的，这里就不再提它们的原理。 pm2 指定生产环境启动一个名为 test 的 node 服务 pm2 start app.js –env production –name test pm2常用api pm2 stopName/processID 停止某个服务，通过服务名称或者服务进程ID pm2deleteName/processID 删除某个服务，通过服务名称或者服务进程ID pm2 logs[Name] 查看日志，如果添加服务名称，则指定查看某个服务的日志，不加则查看所有日志 pm2 start app.js-i4 集群，-i参数用来告诉PM2以clustermode的形式运行你的app（对应的叫forkmode），后面的数字表示要启动的工作线程的数量。如果给定的数字为0，PM2则会根据你CPU核心的数量来生成对应的工作线程。注意一般在生产环境使用cluster_mode模式，测试或者本地环境一般使用fork模式，方便测试到错误。 pm2 reloadNamepm2 restartName 应用程序代码有更新，可以用重载来加载新代码，也可以用重启来完成,reload可以做到0秒宕机加载新的代码，restart则是重新启动，生产环境中多用reload来完成代码更新！ pm2 showName 查看服务详情 pm2 list 查看pm2中所有项目 pm2 monit用monit可以打开实时监视器去查看资源占用情况 pm2 官网地址 http://pm2.keymetrics.io/docs/usage/quick-start/forever 官网地址 https://github.com/foreverjs/forever注意：二者更推荐pm2，看一下二者对比就知道我为什么更推荐使用pm2了。https://www.jianshu.com/p/fdc12d82b661 linux 关闭一个进程 查找与进程相关的PID号ps aux | grep server说明: root 20158 0.0 5.0 1251592 95396 ? Sl 5月17 1:19 node /srv/mini-program-api/launch_pm2.js上面是执行命令后在linux中显示的结果，第二个参数就是进程对应的PID 杀死进程1.以优雅的方式结束进程 kill -l PID -l选项告诉kill命令用好像启动进程的用户已注销的方式结束进程。当使用该选项时，kill命令也试图杀死所留下的子进程。但这个命令也不是总能成功–或许仍然需要先手工杀死子进程，然后再杀死父进程。2.kill 命令用于终止进程 例如：kill-9[PID]-9 表示强迫进程立即停止 这个强大和危险的命令迫使进程在运行时突然终止，进程在结束后不能自我清理。危害是导致系统资源无法正常释放，一般不推荐使用，除非其他办法都无效。当使用此命令时，一定要通过ps -ef确认没有剩下任何僵尸进程。只能通过终止父进程来消除僵尸进程。如果僵尸进程被init收养，问题就比较严重了。杀死init进程意味着关闭系统。如果系统中有僵尸进程，并且其父进程是init， 而且僵尸进程占用了大量的系统资源，那么就需要在某个时候重启机器以清除进程表了。3.killall命令 杀死同一进程组内的所有进程。其允许指定要终止的进程的名称，而非PID。 killall httd Node.js 线程Node.js关于单线程的误区 123456const http = require(&#x27;http&#x27;); const server = http.createServer(); server.listen(3000,()=&gt;&#123; process.title=&#x27;程序员成长指北测试进程&#x27;; console.log(&#x27;进程id&#x27;,process.pid) &#125;) 仍然看本文第一段代码，创建了http服务，开启了一个进程，都说了Node.js是单线程，所以 Node 启动后线程数应该为 1，但是为什么会开启7个线程呢？难道Javascript不是单线程不知道小伙伴们有没有这个疑问？ 解释一下这个原因： Node 中最核心的是 v8 引擎，在 Node 启动后，会创建 v8 的实例，这个实例是多线程的。 主线程：编译、执行代码。 编译/优化线程：在主线程执行的时候，可以优化代码。 分析器线程：记录分析代码运行时间，为 Crankshaft 优化代码执行提供依据。 垃圾回收的几个线程。 所以大家常说的 Node 是单线程的指的是 JavaScript 的执行是单线程的(开发者编写的代码运行在单线程环境中)，但 Javascript 的宿主环境，无论是 Node 还是浏览器都是多线程的因为libuv中有线程池的概念存在的，libuv会通过类似线程池的实现来模拟不同操作系统的异步调用，这对开发者来说是不可见的。 某些异步 IO 会占用额外的线程 还是上面那个例子，我们在定时器执行的同时，去读一个文件： 12345const fs = require(&#x27;fs&#x27;) setInterval(() =&gt; &#123; console.log(new Date().getTime()) &#125;, 3000) fs.readFile(&#x27;./index.html&#x27;, () =&gt; &#123;&#125;) 线程数量变成了 11 个，这是因为在 Node 中有一些 IO 操作（DNS，FS）和一些 CPU 密集计算（Zlib，Crypto）会启用 Node 的线程池，而线程池默认大小为 4，因为线程数变成了 11。我们可以手动更改线程池默认大小： process.env.UV_THREADPOOL_SIZE = 64 一行代码轻松把线程变成 71。 Libuv Libuv 是一个跨平台的异步IO库，它结合了UNIX下的libev和Windows下的IOCP的特性，最早由Node的作者开发，专门为Node提供多平台下的异步IO支持。Libuv本身是由C++语言实现的，Node中的非苏塞IO以及事件循环的底层机制都是由libuv实现的。 libuv架构图 在Window环境下，libuv直接使用Windows的IOCP来实现异步IO。在非Windows环境下，libuv使用多线程来模拟异步IO。 注意下面我要说的话，Node的异步调用是由libuv来支持的，以上面的读取文件的例子，读文件实质的系统调用是由libuv来完成的，Node只是负责调用libuv的接口，等数据返回后再执行对应的回调方法。 直到 Node 10.5.0 的发布，官方才给出了一个实验性质的模块 worker_threads 给 Node 提供真正的多线程能力。 先看下简单的 demo： 12345678910111213141516171819202122232425262728293031const &#123; isMainThread, parentPort, workerData, threadId, MessageChannel, MessagePort, Worker &#125; = require(&#x27;worker_threads&#x27;); function mainThread() &#123; for (let i = 0; i &lt; 5; i++) &#123; const worker = new Worker(__filename, &#123; workerData: i &#125;); worker.on(&#x27;exit&#x27;, code =&gt; &#123; console.log(`main: worker stopped with exit code $&#123;code&#125;`); &#125;); worker.on(&#x27;message&#x27;, msg =&gt; &#123; console.log(`main: receive $&#123;msg&#125;`); worker.postMessage(msg + 1); &#125;); &#125; &#125; function workerThread() &#123; console.log(`worker: workerDate $&#123;workerData&#125;`); parentPort.on(&#x27;message&#x27;, msg =&gt; &#123; console.log(`worker: receive $&#123;msg&#125;`); &#125;), parentPort.postMessage(workerData); &#125; if (isMainThread) &#123; mainThread(); &#125; else &#123; workerThread(); &#125; 上述代码在主线程中开启五个子线程，并且主线程向子线程发送简单的消息。 由于 worker_thread 目前仍然处于实验阶段，所以启动时需要增加 –experimental-worker flag，运行后观察活动监视器，开启了5个子线程 worker_thread 模块 workerthread 核心代码（地址https://github.com/nodejs/node/blob/master/lib/workerthreads.js） worker_thread 模块中有 4 个对象和 2 个类，可以自己去看上面的源码。 isMainThread: 是否是主线程，源码中是通过 threadId === 0 进行判断的。 MessagePort: 用于线程之间的通信，继承自 EventEmitter。 MessageChannel: 用于创建异步、双向通信的通道实例。 threadId: 线程 ID。 Worker: 用于在主线程中创建子线程。第一个参数为 filename，表示子线程执行的入口。 parentPort: 在 worker 线程里是表示父进程的 MessagePort 类型的对象，在主线程里为 null workerData: 用于在主进程中向子进程传递数据（data 副本） 总结多进程 vs 多线程 对比一下多线程与多进程：","categories":[{"name":"node.js","slug":"node-js","permalink":"http://example.com/categories/node-js/"}],"tags":[{"name":"进程与线程","slug":"进程与线程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"}]},{"title":"javascript十大排序算法","slug":"javascript十大排序算法","date":"2020-10-15T08:24:28.000Z","updated":"2021-04-25T03:06:39.865Z","comments":true,"path":"2020/10/15/javascript十大排序算法/","link":"","permalink":"http://example.com/2020/10/15/javascript%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"排序算法说明1.排序的定义对一序列对象根据某个关键字进行排序 输入：n个数：a1,a2,a3,…,an 输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。 再讲的形象点就是排排坐，调座位，高的站后面，矮的站前面。 2.对于评述算法优劣术语的说明稳定：如果a原本在b前面，而a=b,排序之后a仍然在b的前面；不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成；外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度：一个算法执行所耗费的时间。空间复杂度：运行完一个程序所需内存的大小。 3.排序算法图片总结 冒泡排序(Bubble Sort)1.算法描述冒泡排序是一种简单的排序算法。它重复的走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复的进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮“到数列的顶端。 2.算法描述和实现 1.比较相邻的元素。如果第一个比第二个大，就交换它们两个； 2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数。 3.针对所有的元素重复以上的操作，除了最后一个； 4.重复步骤1~3，直到排序完成。 3.JavaScript代码实现12345678910111213141516171819function bubbleSort(arr) &#123; let len = arr.length; for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; // 相邻元素两两对比 let tmp = arr[j]; // 元素交换 arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125; return arr;&#125;let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(bubbleSort(arr));// [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 改进冒泡排序: 设置一标志性变量post，用于记录每趟排序中最后一次交换的位置。由于post位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到post位置即可。 改进后算法如下: 123456789101112131415161718192021function bubbleSort2(arr) &#123; let i = arr.length - 1; while (i &gt; 0) &#123; let pos = 0; for (let j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; pos = j; // 记录最后修改位置 let tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; i = pos; &#125; return arr;&#125;​​let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];// let arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 0, 1];console.log(bubbleSort2(arr)); 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用每趟排序中进行正向和反向两遍冒泡的方法可以得到两个最终值（最大者和最小者），从而使排序躺数几乎减少了一半。 改进后的排序算法实现为 123456789101112131415161718192021222324252627282930313233function bubbleSort3(arr) &#123; var low = 0; var high = arr.length - 1; var tmp, j; console.time(&#x27;2.改进后的冒泡排序耗时&#x27;); while (low &lt; high) &#123; for (j = low; j &lt; high; j++) &#123; // 这里排序出最高的 if (arr[j] &gt; arr[j + 1]) &#123; // 正向冒泡，找出最大者 tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; high--; for (j = high; j &gt; low; j--) &#123; // 反向冒泡 找出最小者 if (arr[j] &lt; arr[j - 1]) &#123; tmp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = tmp; &#125; &#125; low++; &#125; console.timeEnd(&#x27;2.改进后的冒泡排序耗时&#x27;); return arr;&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(bubbleSort3(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 4.冒泡排序动图演示 5.算法分析 最佳情况：T(n) = O(n) 当输入值的数据已经是正序时（都已经是正序了，为毛何必还排序呢….） 最差情况：T(n) = O(n2) 当输入的数据是反序时(卧槽，我直接反序不就完了….) 平均情况：T(n) = O(n2) 选择排序（Selection Sort）表现最稳定的排序算法之一（这个稳定性不是指算法层面上的稳定哈），因为无论是什么数据进去都是O(n²)的时间复杂度……所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 1.算法简介选择排序（Selection-sort）是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2.算法描述和实现n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 1.初始状态：无序区为R[1,…n]，有序区为空； 2.第i趟排序（i=1,2,3,4,…n-1）开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录R[k],将它与无序区的第1个记录R交换，使R[1,…i]和R[i+1…n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； 3.n-1趟结束，数组有序化了。 3.JavaScript代码实现12345678910111213141516171819202122// 选择排序function selectionSort(arr) &#123; var length = arr.length; var minIndex, tmp; console.time(&quot;选择排序耗时&quot;); for (var i = 0; i &lt; length - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; tmp = arr[minIndex]; arr[minIndex] = arr[i]; arr[i] = tmp; &#125; console.timeEnd(&quot;选择排序耗时&quot;); return arr;&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 4.选择排序动图演示 5.算法分析 最佳情况：T(n) = O(n) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 插入排序(Insertion Sort)插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸排的时候从来不按牌的大小调整牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了… 1.算法简介插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描找到对应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把一排序元素逐步向后挪威，为最新元素提供插入空间。 2.算法的描述和实现一般来说，插入排序都采用in-place在数组上实现。具体的算法描述如下： 1.从第一个元素开始，该元素可以认为已经被排序。 2.取出下一个元素，在已经排序的元素序列中从后向前扫描 3.如果该元素（已排序）大于新元素，将该元素移到下一位置 4.重复步骤3，直到找到已排序的元素小于或等于新元素的位置； 5.将新元素插入到该位置后； 6.重复步骤2~5 3.JavaScript代码实现12345678910function insertSort (array) &#123; for (let i = 0; i &lt; array.length; i++) &#123; for (let j = 0; j &lt; i; j++) &#123; if (array[i] &lt; array[j]) &#123; array.splice(j, 0, array[i]); array.splice(i + 1, 1); &#125; &#125; &#125;&#125; 4.插入排序动图演示 5.算法分析 最佳情况：输入数组按升序排序。T(n) = O(n) 最坏情况：输入数组按降序排序。T(n) = O(n2) 平均情况：T(n) = O(n2) 希尔排序(Shell Sort)1959年Sheel发明：第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 1.算法简介希尔排序的核心在于间隔序列的设定。既可以提前设好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）的合著者Robert Sedgewick提出的》。 2.算法描述和实现先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 1.选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk = 1 2.按增量序列个数k，对序列进行k趟排序； 3.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。 3.JavaScript代码实现123456789101112131415161718192021222324function sheelSort2 (array) &#123; let N = array.length; let h = 1; // 计算出步长最大值 while (h &lt; N / 3) &#123; h = 3 * h + 1; &#125; // 以步长进行循环 while (h &gt;= 1) &#123; // 以当前步长为起点循环数组 for (let i = h; i &lt; N; i++) &#123; // 找出距离当前元素为步长的元素，然后交换数值 for (let j = i - h; j &gt;= 0; j = j - h) &#123; if (array[j] &gt; array[j + h]) &#123; let temp = array[j]; array[j] = array[j + h]; array[j + h] = temp; &#125; &#125; &#125; // 重置步长，再次进行循环 h = (h - 1) / 3; &#125;&#125; 4.希尔排序图示 5.算法分析 最佳情况：T(n) = O(nlog2 n) 最坏情况：T(n) = O(nlog2 n) 平均情况：T(n) =O(nlog n) 归并排序(Merge Sort)和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n)的时间复杂度。代价是需要额外的内存空间。 1.算法简介归并排序时建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，成为2-路归并。 2.算法描述和实现具体算法描述如下： 1.把长度为n的输入序列分成两个长度为n/2的子序列； 2.对这两个子序列分别采用归并排序。 3.将两个排序好的子序列合并成一个最终的排序序列。 3.JavaScript代码实现123456789101112131415161718192021222324252627282930313233343536373839404142// 这个思想有点难啊，看起来和之前的二叉树的中序遍历差不多 function mergeSort(arr) &#123; // 采用自上而下的递归方法 // console.log(&#x27;mergeSort&#x27;, arr); var length = arr.length; if (length &lt; 2) &#123; return arr; &#125; var middle = Math.floor(length / 2); var left = arr.slice(0, middle); var right = arr.slice(middle); // console.log(&#x27;mergeSort&#x27;, &#x27;left&#x27;, left, &#x27;right&#x27;, right); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right) &#123; var result = []; console.log(&#x27;left&#x27;, left, &#x27;right&#x27;, right); // console.time(&#x27;归并排序耗时&#x27;); while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) &#123; result.push(left.shift()); &#125; while (right.length) &#123; result.push(right.shift()); &#125; // console.timeEnd(&#x27;归并排序耗时&#x27;); return result;&#125; var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(mergeSort(arr)); 4.归并排序动图演示 5.算法分析 最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 快速排序(Quick Sort)快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的算法之一了。 1.算法简介快速排序的基本思想：通过一趟排序将待记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 2.算法描述和实现快速排序使用分治法来把一个串（list）分为两个子串（sub-list）。具体算法描述如下： 1.从数列中挑出一个元素，称为“基准”(pivot) 2.重新排序数列，所有元素比基准值小的摆放在最前面，所有元素比基准值大的摆在基准的后面（相同的可任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（Partition）操作； 3.递归的（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 3.JavaScript代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function quickSort(arr, left, right) &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === &#x27;Array&#x27; &amp;&amp; typeof length === &#x27;number&#x27; &amp;&amp; typeof right === &#x27;number&#x27;) &#123; // console.log(&#x27;进来的数组&#x27;, JSON.stringify(arr), &#x27;left ==&gt;&#x27;, left, &#x27;right===&gt;&#x27;, right); if (left &lt; right) &#123; var key = arr[left]; // 起始位置 var setPos = left + 1; // 设置的位置 var tmp; for (var i = left + 1; i &lt;= right; i++) &#123; if (arr[i] &lt; key) &#123; tmp = arr[i]; // 交换位置，并将下次小于的位置+1 arr[i] = arr[setPos]; arr[setPos] = tmp; setPos++; &#125; &#125; // 循环完成之后将key与 pos-1的位置交换 arr[left] = arr[setPos - 1]; arr[setPos - 1] = key; // console.log(&#x27;每一次排序&#x27;, &#x27;当前key值===&gt;&#x27;, key, &#x27;排序完成当前数组===&gt;&#x27;, JSON.stringify(arr)); quickSort(arr, left, setPos - 2); quickSort(arr, setPos, right); // console.log(&#x27;arr=======&gt;&#x27;, arr); &#125; &#125; else &#123; return &#x27;array is not an Array or left or right is not a number!&#x27;; &#125; return arr;&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];// var arr = [7, 3, 2, 10, 13, 8, 5];console.log(quickSort(arr, 0, arr.length - 1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]// 另一种方式function quickSort(array, left, right) &#123; console.time(&#x27;1.快速排序耗时&#x27;); if (Object.prototype.toString.call(array).slice(8, -1) === &#x27;Array&#x27; &amp;&amp; typeof left === &#x27;number&#x27; &amp;&amp; typeof right === &#x27;number&#x27;) &#123; if (left &lt; right) &#123; var x = array[right], i = left - 1, temp; for (var j = left; j &lt;= right; j++) &#123; if (array[j] &lt;= x) &#123; i++; temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; quickSort(array, left, i - 1); quickSort(array, i + 1, right); &#125; console.timeEnd(&#x27;1.快速排序耗时&#x27;); return array; &#125; else &#123; return &#x27;array is not an Array or left or right is not a number!&#x27;; &#125;&#125;// 动态图示算法function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr &#125;; var pivoIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivoIndex, 1)[0]; // 将要选择排序的那一位选举出来 摘出来 var left = []; var right = []; // 小的放左边，大的放右边 for (var i = 0, len = arr.length; i &lt; len; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; console.log(&#x27;left&#x27;, left, &#x27;right&#x27;, right); return quickSort(left).concat([pivot], quickSort(right));&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];// var arr = [7, 3, 2, 10, 13, 8, 5];console.log(quickSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 4.快速排序动图演示 5.算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn) 堆排序（Heap Sort）堆排序可以说是一种利用堆的概念来排序的选择排序。 1.算法简介堆排序（HeapSort）是指利用堆这种数据结构所涉及的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。 2.算法描述和实现具体算法描述如下 1.将初始待排序的关键字序列（R1，R2…Rn）构建成大顶堆，此堆为初始的无序区。 2.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区[R1,R2,…Rn-1]和新的有序区(Rn),且满足R[1,2…n-1]&lt;R[n]; 3.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区（R1，R2…Rn-1）调整为新堆，然后再将R[1]与无序区最后一个元素交换，得到新的无序区（R1，R2…Rn-2）和新的有序区（Rn-1，Rn）。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 3.JavaScript代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* 方法说明：堆排序 @param &#123;Array&#125; arr 待排序数组*/function heapSort(arr) &#123; console.log(&#x27;堆排序&#x27;); if (Object.prototype.toString.call(arr).slice(8, -1) === &#x27;Array&#x27;) &#123; var heapSize = arr.length; var temp; console.log(&#x27;待排序数组的长度===&gt;&#x27;, heapSize); console.log(&#x27;建造之前的堆的样式&#x27;, JSON.stringify(arr)); // 建造堆 for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123; heapify(arr, i, heapSize); &#125; console.log(&#x27;堆初始化完成之后的样式&#x27;, JSON.stringify(arr)); // 现在要把最大的放到最后一个，最后一个放到第一个，把堆的大小减少一个，在慢慢的把最大的循环上去 console.time(&#x27;堆排序耗时&#x27;); for (var j = heapSize - 1; j &gt;= 1; j--) &#123; temp = arr[0]; arr[0] = arr[j]; arr[j] = temp; heapify(arr, 0, --heapSize); &#125; console.timeEnd(&#x27;堆排序耗时&#x27;); return arr; &#125; else &#123; return &#x27;array is not array&#x27;; &#125;&#125;/* 建堆：维护堆的性质 @param &#123;Array&#125; arr 数组 @param &#123;Number&#125; x 数组下标 @param &#123;Number&#125; len 堆大小*/function heapify(arr, x, len) &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === &#x27;Array&#x27; &amp;&amp; typeof x === &#x27;number&#x27;) &#123; var l = 2 * x + 1; // 左下标 var r = 2 * x + 2; // 右下标 var largest = x; // 默认最大的是父节点 var temp; // 用于交换数据存储的中间值 // 寻找到一个堆中的最大值 if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; // 如果最大者不是父节点 则交换位置 if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; // 递归寻找 heapify(arr, largest, len); &#125; &#125; else &#123; return &#x27;arr is not an array or x is not a number&#x27;; &#125;&#125; var arr = [91, 60, 96, 13, 35, 65, 46, 65, 10, 30, 20, 31, 77, 81, 22];console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96] 4.堆排序动图演示 5.算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 计数排序(Counting Sort)计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 1.算法简介计数排序（Counting sort）是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。 2.算法描述和实现具体算法描述如下 1.找出待排序的数组中的最大和最小的元素； 2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）; 4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 3.JavaScript代码实现1234567891011121314151617181920212223242526272829303132333435function countingSort(arr) &#123; console.log(&#x27;计数排序&#x27;); var len = arr.length; var B = []; var C = []; var min = max = arr[0]; console.time(&#x27;计数排序耗时&#x27;); // 初始化计数排序 for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= arr[i] ? min : arr[i]; max = max &gt;= arr[i] ? max : arr[i]; C[arr[i]] = C[arr[i]] ? C[arr[i]] + 1 : 1; &#125; console.log(&#x27;初始化结束之后&#x27;, JSON.stringify(C)); var k = 0; for (var j = min; j &lt; max; j++) &#123; C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); &#125; console.log(&#x27;计算完成之后&#x27;, JSON.stringify(C)); console.log(&#x27;计算完成之后arr&#x27;, JSON.stringify(arr)); // 现在C的下标就是这个值，C的内容就是这个值的个数 debugger; for (var k = len - 1; k &gt;= 0; k--) &#123; console.log(&#x27;C[arr[l] - 1]===&gt;&#x27;, C[arr[k]] - 1, &#x27;arrk===&gt;&#x27;, arr[k]); B[C[arr[k]] - 1] = arr[k]; C[arr[k]]--; &#125; console.timeEnd(&#x27;计数排序耗时&#x27;); return B;&#125;var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9] 4.计数排序动图演示 5.算法分析当输入的元素是n个0到k之间的整数时，它的运行时间是O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。 最佳情况：T(n) = O(n + k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k) 桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 1.算法简介桶排序(Bucket sort)的工作原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序） 2.算法描述和实现具体算法描述如下： 1.设置一个定量的数组当做空桶； 2.遍历输入数据，并且把数据一个一个放到对应的桶里去； 3.对每个不是空的桶进行排序； 4.从不是空的桶里把排好序的数据拼接起来。 3.javascript算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* 方法说明：桶排序 @param &#123;Array&#125; 数组 @param &#123;Number&#125; 桶的数量*/function bucketSort(arr, num) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var len = arr.length; var buckets = []; var result = []; var min = max = arr[0]; var regex = &#x27;/^[1-9]+[0-9]*$/&#x27;; var space, n = 0; console.log(&#x27;排序长度 ===&gt;&#x27;, len); // 定义桶的数量 num = num || (num &gt; 1 &amp;&amp; regex.test(num) ? num : 10); console.log(&#x27;桶排序耗时&#x27;); // 寻找到最大值和最小值 for (var i = 0; i &lt; len; i++) &#123; min = (min &lt;= arr[i]) ? min : arr[i]; max = (max &gt;= arr[i]) ? max : arr[i]; &#125; console.log(&#x27;最大值===&gt; max&#x27;, max, &#x27;最小值===&gt; min&#x27;, min); space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) &#123; var index = Math.floor((arr[j] - min) / space); console.log(`第$&#123;j&#125;项，值==&gt; $&#123;arr[j]&#125; 桶的索引为 $&#123;index&#125;, space ===&gt; $&#123;space&#125;`); if (buckets[index]) &#123; // 非空桶，插入排序 var key = arr[j]; var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; key) &#123; buckets[index][k + 1] = buckets[index][k]; k--; &#125; buckets[index][k + 1] = key; &#125; else &#123; // 空桶初始化 buckets[index] = []; buckets[index].push(arr[j]); &#125; &#125; while (n &lt; num) &#123; result = result.concat(buckets[n]); n++; &#125; console.log(&#x27;桶排序完成===&gt;&#x27;, buckets); return result;&#125; var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(bucketSort(arr, 4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 1234567891011121314151617181920212223242526272829303132333435363738/*方法说明：桶排序@param array 数组@param num 桶的数量*/function bucketSort(array, num) &#123; if (array.length &lt;= 1) &#123; return array; &#125; var len = array.length, buckets = [], result = [], min = max = array[0], regex = &#x27;/^[1-9]+[0-9]*$/&#x27;, space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10); console.time(&#x27;桶排序耗时&#x27;); for (var i = 1; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; &#125; space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) &#123; var index = Math.floor((array[j] - min) / space); if (buckets[index]) &#123; // 非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123; buckets[index][k + 1] = buckets[index][k]; k--; &#125; buckets[index][k + 1] = array[j]; &#125; else &#123; //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); &#125; &#125; while (n &lt; num) &#123; result = result.concat(buckets[n]); n++; &#125; console.timeEnd(&#x27;桶排序耗时&#x27;); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bucketSort(arr,4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 4.桶排序图示 5.算法分析桶排序最好情况下使用线性时间O(n),桶排序的时间复杂度，取决于对各个桶之间数据进行排序的时间复杂度，因为其他部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的的空间消耗就会增大。 最佳情况：T(n) = O(n + k) 最差情况：T(n) = O(n + k) 平均情况：T(n) = O(n2) 基数排序（Radix Sort）基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数； 1.算法简介基数排序时按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 2.算法描述和实现具体算法描述如下： 1.取得数组中的最大数，并取得位数。 2.arr为原始数组，从最低位开始取每个位组成radix数组； 3.对radix进行计数排序（利用计数排序适用于小范围数的特点） 3.JavaScript代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 基数排序适用于： (1)数据范围比较小,建议小于1000 (2)每个数值都要大于等于0 @param &#123;Array&#125; arr 待排序数组 @param &#123;Number&#125; 最大位数*/function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; var counter = []; console.time(&#x27;基数排序耗时&#x27;); for (var i = 0; i &lt; maxDigit; i++ , mod *= 10, dev *= 10) &#123; for (var j = 0, len = arr.length; j &lt; len; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); console.log(&#x27;基数===&gt;&#x27;, bucket); if (counter[bucket] == null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; console.log(&#x27;第一次排序完成===&gt;&#x27;, counter); // 将排序好的再次重整排列 var pos = 0; for (var j = 0; j &lt; counter.length; j++) &#123; console.log(&#x27;counter[j] ===&gt;&#x27;, &#x27;j===&gt;&#x27;, j, counter[j]); if (counter[j] != null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; console.log(&#x27;第一次排序完成 arr ===&gt;&#x27;, arr); &#125; console.timeEnd(&#x27;基数排序耗时&#x27;); return arr;&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(radixSort(arr, 2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 4.基数排序动图演示 5.算法分析 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 基数排序有两种方法 MSD从高位开始进行排序 LSD从低位开始进行排序 基数排序 vs 计数排序 vs 桶排序这三种方法都利用了桶的概念，但对桶的使用方法上有明显差异： 1.基数排序：根据键值的每位数字来分配桶 2.计数排序：每个桶只存储单一键值 3.桶排序：每个桶存储一定范围的数值","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"浏览器与node环境的事件循环机制","slug":"浏览器与node环境的事件循环机制","date":"2020-10-14T08:50:38.000Z","updated":"2021-04-25T03:06:39.871Z","comments":true,"path":"2020/10/14/浏览器与node环境的事件循环机制/","link":"","permalink":"http://example.com/2020/10/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Enode%E7%8E%AF%E5%A2%83%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/","excerpt":"","text":"JavaScript中事件循环JavaScript中事件循环，主要就在理解宏任务和微任务这两种异步任务。 宏任务（macrotask） script (可以理解为外层同步代码)setTimeOut / setIntervalsetImmediate(node环境 或 IE10以上)I/O (node环境)各种callback、UI渲染 / UI事件postMessage / messageChannel等 优先级：主代码块 &gt; setImmediate &gt; postMessage &gt; setTimeOut/setInterval 微任务（microtask） process.nextTickPromiseMutationObserverasync(实质上也是promise) 优先级：process.nextTick &gt; Promise &gt; MutationOberser 执行分区：我们常常吧EventLoop中分为 内存、执行栈、WebApi、异步回调队列(包括微任务队列和宏任务队列) 事件处理过程（关于macrotask和microtask的理解）： Nodejs中事件循环Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。 先看一段代码 123456789101112131415161718192021222324252627setTimeout(()=&gt;&#123; console.log(&#x27;timer1&#x27;) Promise.resolve().then(function() &#123; console.log(&#x27;promise1&#x27;) &#125;)&#125;, 0)setTimeout(()=&gt;&#123; console.log(&#x27;timer2&#x27;) Promise.resolve().then(function() &#123; console.log(&#x27;promise2&#x27;) &#125;)&#125;, 0)//浏览器输出结果// timer1// promise1// timer2// promise2//Node输出结果// timer1// timer2// promise1// promise2 Node.js的事件循环Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。 根据Node.js官方介绍，每次事件循环都包含了6个阶段，对应到 libuv 源码中的实现，如下图所示： 1.timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调2.I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调3.idle, prepare 阶段：仅node内部使用4.poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里5.check 阶段：执行 setImmediate() 的回调6.close callbacks 阶段：执行 socket 的 close 事件回调 我们重点看timers、poll、check这3个阶段就好，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。 timers 阶段 timers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行， 事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。 比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。 1234567setTimeout(() =&gt; &#123; console.log(&#x27;timeout&#x27;)&#125;, 0)setImmediate(() =&gt; &#123; console.log(&#x27;immediate&#x27;)&#125;) 但是把它们放到一个I/O回调里面，就一定是 setImmediate() 先执行，因为poll阶段后面就是check阶段。 poll 阶段 poll 阶段主要有2个功能： 1.处理 poll 队列的事件2.当有已超时的 timer，执行它的回调函数 even loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况： 1.若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列2.若没有预设的setImmediate()，event loop将阻塞在该阶段等待 注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。 check 阶段 setImmediate()的回调会被加入check队列中， 从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。 小结 1.event loop 的每个阶段都有一个任务队列2.当 event loop 到达某个阶段时，将执行该阶段的任务队列，直到队列清空或执行的回调达到系统上限后，才会转入下一个阶段3.当所有阶段被顺序执行一次后，称 event loop 完成了一个 tick 现在，我们再来看Node.js 与浏览器的 Event Loop 差异 回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。 而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。 最初demo回顾 回顾文章最开始的demo，全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行； 首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2； 至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2。 对比浏览器端的处理过程： process.nextTick() VS setImmediate() 来自官方文档有意思的一句话，从语义角度看，setImmediate() 应该比 process.nextTick() 先执行才对，而事实相反，命名是历史原因也很难再变。 总结 1.Node.js 的事件循环分为6个阶段2.浏览器和Node 环境下，microtask 任务队列的执行时机不同Node.js中，microtask 在事件循环的各个阶段之间执行浏览器端，microtask 在事件循环的 macrotask 执行完之后执行3.递归的调用process.nextTick()会导致I/O starving，官方推荐使用setImmediate()","categories":[{"name":"浏览器特性","slug":"浏览器特性","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"事件循环","slug":"事件循环","permalink":"http://example.com/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"}]},{"title":"javascript中判断数据类型的几种方法","slug":"javascript中判断数据类型的几种方法","date":"2020-10-14T05:36:33.000Z","updated":"2021-04-25T03:06:39.864Z","comments":true,"path":"2020/10/14/javascript中判断数据类型的几种方法/","link":"","permalink":"http://example.com/2020/10/14/javascript%E4%B8%AD%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"javascript中判断数据类型的几种方法在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示： 基本类型：String、Number、Boolean、Symbol、Undefined、Null 引用类型：Object 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。 鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，不同的方法得到的结果参差不齐。 1.typeof操作符typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。 typeof ‘’; // string 有效typeof 1; // number 有效typeof Symbol(); // symbol 有效typeof true; //boolean 有效typeof undefined; //undefined 有效typeof null; //object 无效typeof [] ; //object 无效typeof new Function(); // function 有效typeof new Date(); //object 无效typeof new RegExp(); //object 无效 有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值： 对于基本类型，除 null 以外，均可以返回正确的结果。 对于引用类型，除 function 以外，一律返回 object 类型。 对于 null ，返回 object 类型。 对于 function 返回 function 类型。 其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。 2.instanceof操作符instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，我们用一段伪代码来模拟其内部执行过程： 123456789instanceof (A,B) = &#123; varL = A.__proto__; varR = B.prototype; if(L === R) &#123; // A的内部属性 __proto__ 指向 B 的原型对象 returntrue; &#125; returnfalse;&#125; 从上述过程可以看出，当 A 的 proto 指向 B 的 prototype 时，就认为 A 就是 B 的实例，我们再来看几个例子： 12345678910[] instanceof Array; // true&#123;&#125; instanceof Object; // truenew Date() instanceof Date; // truefunction Person()&#123;&#125;;new Person() instanceof Person; // true[] instanceof Object; // truenew Date() instanceof Object;// truenew Person() instanceof Object;// true 我们发现，虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例，为什么呢？ 我们来分析一下 [ ]、Array、Object 三者之间的关系： 从 instanceof 能够判断出 [ ].proto 指向 Array.prototype，而 Array.prototype.proto 又指向了Object.prototype，最终 Object.prototype.proto 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链： 从原型链可以看出，[] 的 proto 直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。 instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。 12345var iframe = document.createElement(&#x27;iframe&#x27;);document.body.appendChild(iframe);var xArray = window.frames[0].Array;var arr = newxArray(1,2,3); // [1,2,3]arr instanceof Array; // false 针对数组的这个问题，ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建。 123if(Array.isArray(value))&#123; //对数组执行某些操作&#125; Array.isArray() 本质上检测的是对象的 [[Class]] 值，[[Class]] 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 [object Xxx] ，Xxx 就是对应的具体类型 。对于数组而言，[[Class]] 的值就是 [object Array] 。 3.constructor当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。如下所示： 当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor == F 可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。 同样，JavaScript 中的内置对象在内部构建时也是这样做的: 1234567891011121314151617&#x27;&#x27;.constructor === String // truenew Number(1).constructor === Number // truetrue.constructor === Boolean // true(function() &#123;&#125;).constructor === Function // truenew Date().constructor === Date // truenew Error().constructor === Error // true[].constructor === Array // truedocument.constructor === HTMLDocument // truewindow.constructor === Window // true 细节问题: null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object 为什么变成了 Object？ 因为 prototype 被重新赋值的是一个 { }， { } 是 new Object() 的字面量，因此 new Object() 会将 Object 原型上的 constructor 传递给 { }，也就是 Object 本身。 因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。 4.toString方法toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。 12345678910111213Object.prototype.toString.call(&#x27;&#x27;) // [object String]Object.prototype.toString.call(1) // [object Number]Object.prototype.toString.call(true) // [object Boolean]Object.prototype.toString.call(Symbol()) //[object Symbol]Object.prototype.toString.call(undefined) // [object Undefined]Object.prototype.toString.call(null) // [object Null]Object.prototype.toString.call(function() &#123;&#125;) // [object Function]Object.prototype.toString.call(new Date()) // [object Date]Object.prototype.toString.call([]) // [object Array]Object.prototype.toString.call(new RegExp()) // [object RegExp]Object.prototype.toString.call(new Error()) // [object Error]Object.prototype.toString.call(document) // [object HTMLDocument]Object.prototype.toString.call(window) // [object Window]","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"类型判断","slug":"类型判断","permalink":"http://example.com/tags/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2020-10-14T03:09:18.000Z","updated":"2021-04-25T03:06:39.863Z","comments":true,"path":"2020/10/14/git常用命令/","link":"","permalink":"http://example.com/2020/10/14/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"配置123456789101112# 下载一个项目和它的整个代码历史git clone [url] # 显示当前的Git配置git config --list # 编辑Git配置文件 git config -e [--global] # 设置提交代码时的用户信息git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir] # 添加当前目录的所有文件到暂存区 git add . # 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 提交时显示所有diff信息git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 分支操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 基于一个分支创建新的分支git checkout -b [new_branch] [origin-branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支git merge [branch]# 选择一个commit，合并进当前分支git cherry-pick [commit]# 查看尚未被合并到当前分支的分支git branch --no-merged# 查看已经被合并到当前分支的分支git branch --merged# 删除分支git branch -d [branch-name]# 强制删除某个分支(未被合并的分支被删除的时候需要强制)git branch -D [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 显示有变更的文件git status# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示过去5次提交git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 比较当前文件和暂存区文件差异git diff [file]# 显示暂存区和上一个commit的差异git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异git diff HEAD# 显示两次提交之间的差异git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提交发生变化的文件git show --name-only [commit]# 显示某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] --all 撤销操作12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"git命令","slug":"git命令","permalink":"http://example.com/tags/git%E5%91%BD%E4%BB%A4/"}]},{"title":"linux常用命令","slug":"linux常用命令","date":"2020-10-14T03:03:10.000Z","updated":"2021-04-25T03:06:39.866Z","comments":true,"path":"2020/10/14/linux常用命令/","link":"","permalink":"http://example.com/2020/10/14/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738ls 显示文件或目录 -l 列出文件详细信息l(list) -hl 列出详细信息并以可读大小显示文件大小mkdir [dirname] 创建目录 -p 创建目录，若无父目录，则创建p(parent)cd 切换目录pwd 显示当前目录clear 清屏touch [filename] 创建空文件cat [filename] 查看文件内容mv [source] [target] 移动或重命名rm 删除文件 -r 递归删除，可删除子目录及文件 -f 强制删除more [参数] [filename] 全屏幕按页显示文本文件内容 -数字 指定每屏显示的行数 -s 将多个空行压缩成一行显示 +数字 从指定数字的行开始显示 内置快捷键 Enter 向下翻滚一行 空格space 向下滚动一屏 B 显示上一屏 Q 退出命令vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。 :w 保存文件但不退出vi :w file 将修改另外保存到file中，不退出vi :w! 强制保存，不推出vi :wq 保存文件并退出vi :wq! 强制保存文件，并退出vi q: 不保存文件，退出vi :q! 不保存文件，强制退出vi :e! 放弃所有修改，从上次保存文件开始再编辑","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"http://example.com/tags/linux%E5%91%BD%E4%BB%A4/"}]},{"title":"Get请求与Post请求的区别","slug":"Get请求与Post请求的区别","date":"2020-10-14T02:49:39.000Z","updated":"2021-04-25T03:06:39.859Z","comments":true,"path":"2020/10/14/Get请求与Post请求的区别/","link":"","permalink":"http://example.com/2020/10/14/Get%E8%AF%B7%E6%B1%82%E4%B8%8EPost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Get请求与Post请求的区别 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 GET产生一个TCP数据包；POST产生两个TCP数据包。 GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据） POST方式的请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据） 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。","categories":[{"name":"http","slug":"http","permalink":"http://example.com/categories/http/"}],"tags":[{"name":"get/post","slug":"get-post","permalink":"http://example.com/tags/get-post/"}]},{"title":"javascript继承总结","slug":"javascript继承总结","date":"2020-10-13T08:41:21.000Z","updated":"2021-04-25T03:06:39.865Z","comments":true,"path":"2020/10/13/javascript继承总结/","link":"","permalink":"http://example.com/2020/10/13/javascript%E7%BB%A7%E6%89%BF%E6%80%BB%E7%BB%93/","excerpt":"","text":"es6中的继承es6中的继承很简单，使用extends关键字就可以实现 1234567891011121314151617// 父类class Parent &#123; constructor(name) &#123; this.name = name &#125; sayName() &#123; console.log(this.name) &#125;&#125;// 子类继承class Children extends Parent &#123; &#125;let creatChildren = new Children(&#x27;kite&#x27;)creatChildren.sayName() 会输出 kite es5中的继承1.原型继承。继承父类模版和原型对象12345678910111213141516171819function Parent(name) &#123; this.name = name&#125;Parent.prototype = &#123; constructor: Parent, sayName: function () &#123; console.log(this.name) &#125;&#125;function Children () &#123;&#125;// 把父类的实例复制给子类的原型Children.prototype = new Parent(&#x27;kite&#x27;)var createChildren = new Children()createChildren.sayName() 会输出 kite 2.类继承。只继承父类模版,不继承父类原型对象123456789101112131415161718function Parent(name) &#123; this.name = name&#125;Parent.prototype = &#123; constructor: Parent, sayName: function () &#123; console.log(this.name) &#125;&#125;function Children(name) &#123; Parent.call(this, name)&#125;var createChildren = new Children(&#x27;kite&#x27;)createChildren.sayName() 会输出 kite 3.混合继承,推荐使用.缺点：子类继承了2次父类的模版1234567891011121314151617181920function Parent(name) &#123; this.name = name&#125;Parent.prototype = &#123; constructor: Parent, sayName: function () &#123; console.log(this.name) &#125;&#125;function Children(name) &#123; Parent.call(this, name)&#125;Children.prototype = new Parent();var createChildren = new Children(&#x27;kite&#x27;)createChildren.sayName() 会输出 kite 4.最佳继承。只继承一次父类模版和原型对象123456789101112131415161718192021222324252627282930function Parent(name) &#123; this.name = name&#125;Parent.prototype = &#123; constructor: Parent, sayName: function () &#123; console.log(this.name) &#125;&#125;function Children(name) &#123; Parent.call(this, name)&#125;function extendParent(Parent, Children) &#123; var F = new Function() F.prototype = Parent.prototype Children.prototype = new F() // 继承父类原型 Children.prototype.constructor = Children // 还原子类构造器 if (Parent.prototype.constructor === Object.prototype.constructor) &#123; Parent.prototype.constructor = Parent // 还原父类构造器 &#125;&#125;extendParent(Parent, Children)var createChildren = new Children(&#x27;kite&#x27;)createChildren.sayName() 会输出 kite es5中new关键字干了啥 1.创建一个新对象，新对象的原型指向构造函数的原型 2.将新对象赋值给构造函数的this, 并且执行构造函数内部的代码 3.如果构造函数返回的是非空对象，则返回这个对象；否则返回新对象 1234567891011121314151617181920/* @method new操作的实现 new命令的原理 * @param constructor 构造函数 * @param params 参数 */function _new(constructor, params) &#123; // 取出入参中的constructor var constructor = [].shift.call(arguments) // 创建一个新对象，新对象的原型指向构造函数的原型 var context = Object.create(constructor.prototype) // 取出入参中的params var args = [].slice.call(arguments) // 将新对象赋值给构造函数的this, 并且执行构造函数内部的代码 var res = constructor.apply(context, args) // 如果构造函数返回的是非空对象，则返回这个对象；否则返回新对象 return (typeof res === &#x27;object&#x27; &amp;&amp; res !== null) ? res : context&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"继承","slug":"继承","permalink":"http://example.com/tags/%E7%BB%A7%E6%89%BF/"}]},{"title":"作用域链图解","slug":"作用域链图解","date":"2020-10-13T03:36:33.000Z","updated":"2021-04-25T03:06:39.867Z","comments":true,"path":"2020/10/13/作用域链图解/","link":"","permalink":"http://example.com/2020/10/13/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%9B%BE%E8%A7%A3/","excerpt":"","text":"作用域链图解 作用域js采用词法作用域在ES6之前，js中有三种作用域 全局作用域 函数作用域 eval作用域（严格模式下才有） 以上作用域内声明的变量或方法只有当前作用域内有效。 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。 全局作用域不在任何函数内声明的变量称作全局变量，它在js程序中的任何地方都是可见的。代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。 函数作用域在函数内声明的变量具有函数作用域，并且只在函数内可见。在固定的代码片段才能被访问 块级作用域而ES6新增了一个 块级作用域 块级作用域可以简单理解为是: 包在大括号{}里面的内容, 它可以自成一个作用域, 但ES5中也有大括号, 可ES5中并没有块级作用域, 这时该怎样判断 {} 是否具有块级作用域的特点? 这时就得用到 let 和 const 因此, 可以将块级作用域理解为: 使用let和const声明的变量, 只在当前大阔号内生效, 由此构建出了 块级作用域 这么个东西.这里的 “大括号内” 主要指的下面几种情况: 123456789101112131415// 条件语句 if else else ifif () &#123;&#125;// switch语句switch () &#123;&#125;// for / while循环语句for () &#123;&#125;while () &#123;&#125;// try...catch语句try () catch (err) &#123;&#125;// 单大括号&#123;&#125; 通过var定义的变量可以跨块作用域访问到（就相当于块级作用域中的var是定义到上级作用域中的（函数作用域或者全局作用域）），但是不能跨函数作用域访问到 通过下面的代码也可知：if语句和for语句属于块作用域，不属于函数作用域。 1234567891011121314151617181920212223242526&#123; var a = 1; console.log(a); // 1&#125;console.log(a); // 1// 可见，通过var定义的变量可以跨块作用域访问到。(function A() &#123;var b = 2;console.log(b); // 2&#125;)();// console.log(b); // 报错，// 可见，通过var定义的变量不能跨函数作用域访问到if(true) &#123; var c = 3;&#125;console.log(c); // 3for(var i = 0; i &lt; 4; i++) &#123; var d = 5;&#125;;console.log(i); // 4 (循环结束i已经是4，所以此处i为4)console.log(d); // 5// if语句和for语句中用var定义的变量可以在外面访问到，// 可见，if语句和for语句属于块作用域，不属于函数作用域。 var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。可声明提升 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。不可声明提升 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。不可声明提升 123456789101112131415161718192021222324252627282930// 块作用域&#123; var a = 1; let b = 2; const c = 3; // c = 4; // 报错 var aa; let bb; // const cc; // 报错 console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 console.log(aa); // undefined console.log(bb); // undefined&#125;console.log(a); // 1// console.log(b); // 报错// console.log(c); // 报错// 函数作用域(function A() &#123; var d = 5; let e = 6; const f = 7; console.log(d); // 5 console.log(e); // 6 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到) console.log(f); // 7 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到)&#125;)();// console.log(d); // 报错// console.log(e); // 报错// console.log(f); // 报错 自由变量在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。如下 123456var x = 10;function fn() &#123; var b = 20; console.log(b + x); // x变量在这里就是一个自由变量&#125; 作用域链 作用域有上下级关系，上下级关系的确定就看函数是在哪个作用域下创建的。如上，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。 变量取值：到创建 这个变量 的函数的作用域中取值，切记是创建的作用域中取值，而不是调用的作用域中取值！其实这就是所谓的“静态作用域”。 但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。 所以下面的结果是10 1234567891011121314var x = 10;function fn()&#123; console.log(x);&#125;function show(f)&#123; var x = 20; (function()&#123; f(); // 10 而不是20 &#125;)() &#125;show(fn); // 10 对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？ 要到创建fn函数的那个作用域中取, 无论fn函数将在哪里调用。 上面描述的只是跨一步作用域去寻找。 如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。这个一步一步“跨”的路线，我们称之为——作用域链。 以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"作用域链","slug":"作用域链","permalink":"http://example.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"}]},{"title":"HTTP协商缓存VS强缓存原理","slug":"HTTP协商缓存VS强缓存原理","date":"2020-10-12T10:16:17.000Z","updated":"2021-04-25T03:06:39.860Z","comments":true,"path":"2020/10/12/HTTP协商缓存VS强缓存原理/","link":"","permalink":"http://example.com/2020/10/12/HTTP%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98VS%E5%BC%BA%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/","excerpt":"","text":"1.浏览器缓存缓存这东西，第一次必须获取到资源后，然后根据返回的信息来告诉如何缓存资源，可能采用的是强缓存，也可能告诉客户端浏览器是协商缓存，这都需要根据响应的header内容来决定的。下面用两幅图来描述浏览器的缓存是怎么玩的，让大家有个大概的认知。 浏览器第一次请求时: 浏览器后续在进行请求时: 从上图可以知道，浏览器缓存包含两种类型，即强缓存（也叫本地缓存）和协商缓存，浏览器在第一次请求发生后，再次请求时: 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信；在firebug下可以查看某个具有强缓存资源返回的信息，例如本地firebug查看的一个强缓存js文件 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容 强缓存与协商缓存的区别，可以用下表来进行描述: 获取资源形式 状态码 发送请求到服务器 强缓存 从缓存取 200（from cache） 否，直接从缓存取 协商缓存 从缓存取 304（not modified） 是，正如其名，通过服务器来告知缓存是否可用 2.强缓存相关的header字段强缓存上面已经介绍了，直接从缓存中获取资源而不经过服务器；与强缓存相关的header字段有两个: 1.expires，这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源 expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 2.cache-control：max-age=number，这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；cache-control除了该字段外，还有下面几个比较常用的设置值 no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。首次加载一定会从服务器获取，首次加载会慢。 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。 max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。 min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。 注意：如果cache-control与expires同时存在的话，cache-control的优先级高于expires 3.协商缓存相关的header字段协商缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。 1.Last-Modified/If-Modified-Since: 二者的值都是GMT格式的时间字符串，具体过程: 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间 浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header 浏览器收到304的响应后，就会从缓存中加载资源 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值 2.Etag/If-None-Match: 这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。 4.既生Last-Modified何生Etag 你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)； 某些服务器不能精确的得到文件的最后修改时间。这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。 Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 5.用户的行为对缓存的影响 6.强缓存如何重新加载缓存缓存过的资源上面说到，使用强缓存时，浏览器不会发送请求到服务端，根据设置的缓存时间浏览器一直从缓存中获取资源，在这期间若资源产生了变化，浏览器就在缓存期内就一直得不到最新的资源，那么如何防止这种事情发生呢？ 通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。 类似下图所示: 这样每次文件改变后就会生成新的query值，这样query值不同，也就是页面引用的资源路径不同了，之前缓存过的资源就被浏览器忽略了，因为资源请求的路径变了。 7.缓存位置缓存的位置按照获取资源请求优先级，缓存位置依次如下： Memory Cache(内存缓存) Service Worker(离线缓存) Disk Cache(磁盘缓存) Push Cache(推送缓存) 1.Memory CacheMemory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存 内存缓存中有一块重要的缓存资源是preloader相关指令（例如）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。 2.Service WorkerService Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。 Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 可以帮我们实现离线缓存、消息推送和网络代理等功能。 3.Disk CacheDisk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？ 关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘 4.Push CachePush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。","categories":[{"name":"http","slug":"http","permalink":"http://example.com/categories/http/"}],"tags":[{"name":"http缓存","slug":"http缓存","permalink":"http://example.com/tags/http%E7%BC%93%E5%AD%98/"}]},{"title":"DOM解析流程","slug":"dom解析流程","date":"2020-10-10T10:58:12.000Z","updated":"2021-04-25T03:06:39.862Z","comments":true,"path":"2020/10/10/dom解析流程/","link":"","permalink":"http://example.com/2020/10/10/dom%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/","excerpt":"","text":"什么是DOM Document Object Model 文档对象模型 什么是DOM？可能很多人第一反应就是div、p、span等html标签（至少我是），但要知道，DOM是Model，是Object Model，对象模型，是为HTML（and XML）提供的API。HTML(Hyper Text Markup Language)是一种标记语言，HTML在DOM的模型标准中被视为对象，DOM只提供编程接口，却无法实际操作HTML里面的内容。但在浏览器端，前端们可以用脚本语言（JavaScript）通过DOM去操作HTML内容。 那么问题来了，只有JavaScript才能调用DOM这个API吗？ 答案是NO。 Python也可以访问DOM。所以DOM不是提供给Javascript的API，也不是Javascript里的API。 PS: 实质上还存在CSSOM：CSS Object Model，浏览器将CSS代码解析成树形的数据结构，与DOM是两个独立的数据结构。 浏览器渲染过程 讨论DOM操作成本，肯定要先了解该成本的来源，那么就离不开浏览器渲染。 这里暂只讨论浏览器拿到HTML之后开始解析、渲染。（怎么拿到HTML资源的可能后续另开篇总结吧，什么握握握手啊挥挥挥挥手啊，万恶的flag…） 1.解析HTML，构建DOM树（这里遇到外链，此时会发起请求） 2.解析CSS，生成CSS规则树 3.合并DOM树和CSS规则，生成render树 4.布局render树（Layout/reflow），负责各元素尺寸、位置的计算 5.绘制render树（paint），绘制页面像素信息 6.浏览器会将各层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上 1.构建DOM树1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;title&gt;Critical Path&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 无论是DOM还是CSSOM，都是要经过Bytes → characters → tokens → nodes → object model这个过程。 DOM树构建过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 2.构建CSSOM树上述也提到了CSSOM的构建过程，也是树的结构，在最终计算各个节点的样式时，浏览器都会先从该节点的普遍属性（比如body里设置的全局样式）开始，再去应用该节点的具体属性。还有要注意的是，每个浏览器都有自己默认的样式表，因此很多时候这棵CSSOM树只是对这张默认样式表的部分替换。 3.生成render树 DOM树和CSSOM树合并生成render树 简单描述这个过程： DOM树从根节点开始遍历可见节点，这里之所以强调了“可见”，是因为如果遇到设置了类似display: none;的不可见节点，在render过程中是会被跳过的（但visibility: hidden; opacity: 0这种仍旧占据空间的节点不会被跳过render），保存各个节点的样式信息及其余节点的从属关系。 4.Layout 布局有了各个节点的样式信息和属性，但不知道各个节点的确切位置和大小，所以要通过布局将样式信息和属性转换为实际可视窗口的相对大小和位置。 5.Paint 绘制万事俱备，最后只要将确定好位置大小的各节点，通过GPU渲染到屏幕的实际像素。 在上述渲染过程中，前3点可能要多次执行，比如js脚本去操作dom、更改css样式时，浏览器又要重新构建DOM、CSSOM树，重新render，重新layout、paint； Layout在Paint之前，因此每次Layout重新布局（reflow 回流）后都要重新出发Paint渲染，这时又要去消耗GPU； Paint不一定会触发Layout，比如改个颜色改个背景；（repaint 重绘） 图片下载完也会重新出发Layout和Paint； 回流和重绘何时触发reflow和repaint reflow(回流): 根据Render Tree布局(几何属性)，意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树； repaint(重绘): 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了； reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流； GoogleChromeLabs 里面有一个csstriggers，列出了各个CSS属性对浏览器执行Layout、Paint、Composite的影响。 引起reflow回流 现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。 1.页面第一次渲染（初始化） 2.DOM树变化（如：增删节点） 3.Render树变化（如：padding改变） 4.浏览器窗口resize 5.获取元素的某些属性：浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括offsetLeft、offsetTop、offsetWidth、offsetHeight、 scrollTop/Left/Width/Height、clientTop/Left/Width/Height、调用了getComputedStyle()或者IE的currentStyle 引起repaint重绘 1.reflow回流必定引起repaint重绘，重绘可以单独触发2.背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流） 优化reflow、repaint触发次数 避免逐个修改节点样式，尽量一次性修改 使用DocumentFragment将需要多次修改的DOM元素缓存，最后一次性append到真实DOM中渲染 可以将需要多次修改的DOM元素设置display: none，操作完再显示。（因为隐藏元素不在render树内，因此修改隐藏元素不会触发回流重绘） 避免多次读取某些属性（见上） 将复杂的节点元素脱离文档流，降低回流成本 为什么一再强调将css放在头部，将js文件放在尾部DOMContentLoaded 和 load DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片… load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成 CSS 资源阻塞渲染 构建Render树需要DOM和CSSOM，所以HTML和CSS都会阻塞渲染。所以需要让CSS尽早加载（如：放在头部），以缩短首次渲染的时间。 JS 资源 阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML; 这和之前文章提到的浏览器线程有关，浏览器中js引擎线程和渲染线程是互斥的 普通的脚本会阻塞浏览器解析，加上defer或async属性，脚本就变成异步，可等到解析完毕再执行。 async异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在onload前，但不确定在DOMContentLoaded事件的前后； defer延迟执行，相对于放在body最后（理论上在DOMContentLoaded事件前） 1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt; &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器拿到HTML后，从上到下顺序解析文档 此时遇到css、js外链，则同时发起请求 开始构建DOM树 这里要特别注意，由于有CSS资源，CSSOM还未构建前，会阻塞js（如果有的话） 无论JavaScript是内联还是外链，只要浏览器遇到 script 标记，唤醒JavaScript解析器，就会进行暂停 blocked 浏览器解析HTML，并等到 CSSOM 构建完毕，才执行js脚本 渲染首屏（DOMContentLoaded 触发，其实不一定是首屏，可能在js脚本执行前DOM树和CSSOM已经构建完render树，已经paint） 首屏优化Tips 说了这么多，其实可以总结几点浏览器首屏渲染优化的方向 减少资源请求数量（内联亦或是延迟动态加载） 使CSS样式表尽早加载，减少@import的使用，因为需要解析完样式表中所有import的资源才会算CSS资源下载完 异步js：阻塞解析器的 JavaScript 会强制浏览器等待 CSSOM 并暂停 DOM 的构建，导致首次渲染的时间延迟 ……","categories":[{"name":"浏览器特性","slug":"浏览器特性","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"dom解析","slug":"dom解析","permalink":"http://example.com/tags/dom%E8%A7%A3%E6%9E%90/"}]}],"categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/categories/webpack/"},{"name":"vue.js","slug":"vue-js","permalink":"http://example.com/categories/vue-js/"},{"name":"性能优化","slug":"性能优化","permalink":"http://example.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"浏览器特性","slug":"浏览器特性","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%B9%E6%80%A7/"},{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"http","slug":"http","permalink":"http://example.com/categories/http/"},{"name":"node.js","slug":"node-js","permalink":"http://example.com/categories/node-js/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99/"},{"name":"es6","slug":"es6","permalink":"http://example.com/tags/es6/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"},{"name":"组件间通信","slug":"组件间通信","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"name":"指令","slug":"指令","permalink":"http://example.com/tags/%E6%8C%87%E4%BB%A4/"},{"name":"性能优化","slug":"性能优化","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"跨域","slug":"跨域","permalink":"http://example.com/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"call和apply和bind","slug":"call和apply和bind","permalink":"http://example.com/tags/call%E5%92%8Capply%E5%92%8Cbind/"},{"name":"模块化","slug":"模块化","permalink":"http://example.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"函数","slug":"函数","permalink":"http://example.com/tags/%E5%87%BD%E6%95%B0/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"http协议","slug":"http协议","permalink":"http://example.com/tags/http%E5%8D%8F%E8%AE%AE/"},{"name":"express/koa","slug":"express-koa","permalink":"http://example.com/tags/express-koa/"},{"name":"闭包","slug":"闭包","permalink":"http://example.com/tags/%E9%97%AD%E5%8C%85/"},{"name":"map","slug":"map","permalink":"http://example.com/tags/map/"},{"name":"vue.js","slug":"vue-js","permalink":"http://example.com/tags/vue-js/"},{"name":"工具函数","slug":"工具函数","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"懒加载/无限滚动","slug":"懒加载-无限滚动","permalink":"http://example.com/tags/%E6%87%92%E5%8A%A0%E8%BD%BD-%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8/"},{"name":"promise","slug":"promise","permalink":"http://example.com/tags/promise/"},{"name":"进程与线程","slug":"进程与线程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"},{"name":"事件循环","slug":"事件循环","permalink":"http://example.com/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"类型判断","slug":"类型判断","permalink":"http://example.com/tags/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"},{"name":"git命令","slug":"git命令","permalink":"http://example.com/tags/git%E5%91%BD%E4%BB%A4/"},{"name":"linux命令","slug":"linux命令","permalink":"http://example.com/tags/linux%E5%91%BD%E4%BB%A4/"},{"name":"get/post","slug":"get-post","permalink":"http://example.com/tags/get-post/"},{"name":"继承","slug":"继承","permalink":"http://example.com/tags/%E7%BB%A7%E6%89%BF/"},{"name":"作用域链","slug":"作用域链","permalink":"http://example.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"},{"name":"http缓存","slug":"http缓存","permalink":"http://example.com/tags/http%E7%BC%93%E5%AD%98/"},{"name":"dom解析","slug":"dom解析","permalink":"http://example.com/tags/dom%E8%A7%A3%E6%9E%90/"}]}